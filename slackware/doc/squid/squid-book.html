<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  

  <title>Squid-Book oltre le FAQ</title>
  
  <style type="text/css">
  /*<![CDATA[*/
  body {
  background-color: #FFFFFF;
  color: #000000;
  }
  :link { color: #0000FF }
  :visited { color: #840084 }
  :active { color: #0000FF }
  /*]]>*/
  </style>
</head>

<body class="BOOK">
  <div class="BOOK">
    <a name="AEN1" id="AEN1"></a>

    <div class="TITLEPAGE">
      <h1 class="TITLE"><a name="AEN2" id="AEN2"></a>Squid-Book oltre le
      FAQ</h1>

      <h3 class="AUTHOR"><a name="AEN5" id="AEN5"></a>Stefano Tagliaferri
      &lt;squid(at)merlinobbs.net&gt;</h3>

      <div class="REVHISTORY">
        <table width="100%" border="0">
          <tr>
            <th align="left" valign="top" colspan="3"><strong>Diario delle
            revisioni</strong></th>
          </tr>

          <tr>
            <td align="left">Revisione 4.10</td>

            <td align="left">23 Maggio 2004</td>

            <td align="left"></td>
          </tr>

          <tr>
            <td align="left" colspan="3">Correzioni ed integrazioni varie
            relativamente agli schemi di autenticazione <em>Basic</em> ed
            <em>NTLM</em>, note sull&#39;inserimento delle macchine
            UNIX&reg; nei domini Windows, proxy trasparente con
            <em>ipfw</em>(8) ed <em>ipf</em>(8), WCCP</td>
          </tr>

          <tr>
            <td align="left">Revisione 4.00</td>

            <td align="left">24 Aprile 2004</td>

            <td align="left"></td>
          </tr>

          <tr>
            <td align="left" colspan="3">Nuova riorganizzazione documento,
            il capitolo &quot;Controllare Squid&quot; &egrave; stato
            integrato con il paragrafo dedicato al cache manager,
            rivisitato il capitolo dedicato alle ACL al quale sono state
            aggiunte le funzionalit&agrave; dei nuovi helper external ACL
            <em>squid_unix_group</em>, <em>ip_user_check</em> e
            <em>win32_check_group</em>, altre informazioni sulla
            compilazione, avviare una versione compilata con Red Hat Linux,
            IRCACHE e GARR, i modelli di cache store, il tuning del file
            system, acceleratore SSL, alcune aggiunte relative al capitolo
            dedicato ai delay pools, troubleshooting con il file
            <em>access.log</em>, codici di stato, metodi di richiesta e
            codici gerarchici.</td>
          </tr>

          <tr>
            <td align="left">Revisione 3.60</td>

            <td align="left">27 Marzo 2004</td>

            <td align="left"></td>
          </tr>

          <tr>
            <td align="left" colspan="3">Nuova riorganizzazione documento,
            il capitolo &quot;Hardware consigliato per Squid&quot; &egrave;
            stato integrato nel capitolo <a href=
            "#SEC-SISTEMA-OTTIMALE">Configurare Squid</a>, lavorare con il
            codice sorgente di Squid, istruzioni per scegliere
            l&#39;ambiente di lavoro ottimale, compilare ed installare
            Squid, disponibilit&agrave; dei pacchetti precompilati, il
            Cache Manager, Ad Zapping con Squid</td>
          </tr>

          <tr>
            <td align="left">Revisione 3.50</td>

            <td align="left">6 Marzo 2004</td>

            <td align="left"></td>
          </tr>

          <tr>
            <td align="left" colspan="3">Introduzione a Squid: il concetto
            di webcache, i vantaggi di un sistema webcache tra performance,
            policy e sicurezza, elementi che compongono le ACL, ACL basate
            sul MAC address. Configurare WPAD con ISC DHCP, WPAD round
            robin, ulteriori riferimenti, revisioni ed aggiornamenti alla
            versione 2.5.STABLE5 (supporto NTLMv2)</td>
          </tr>

          <tr>
            <td align="left">Revisione 3.40</td>

            <td align="left">23 Gennaio 2004</td>

            <td align="left"></td>
          </tr>

          <tr>
            <td align="left" colspan="3">Problemi comuni riscontrati con il
            sistema di autenticazione NTLM, descrizione delle
            funzionalit&agrave; del nuovo helper external acl
            &quot;<em>squid_ldap_group</em>&quot;, integrazione delle
            istruzioni per l&#39;avvio multipiattaforma, integrazione delle
            istruzioni per l&#39;avvio con GNU Debian Linux e i sistemi
            Windows, nuova riorganizzazione ed adeguamento</td>
          </tr>

          <tr>
            <td align="left">Revisione 3.30</td>

            <td align="left">3 Gennaio 2004</td>

            <td align="left"></td>
          </tr>

          <tr>
            <td align="left" colspan="3">Riorganizzazione ed adeguamento
            del capitolo relativo ai <a href=
            "#CHA-AUTENTICAZIONE-UTENTI">sistemi di autenticazione</a>,
            riorganizzazione ed adeguamento del capitolo relativo ai
            <a href="#CHA-CONTROLLI-DI-ACCESSO">controlli di accesso</a> a
            cura di <a href="mailto:guido.serassio@acmeconsulting.it"
            target="_top">Guido Serassio</a>, aggiornamento della storia
            dello <a href="#SEC-LE-ORIGINI-SQUID-BOOK">Squid-Book</a> con
            relativo riepilogo degli autori, addendum al capitolo <a href=
            "#SEC-CONTROLLO-ACCESSO-SUI-SITI-WEB">relativo al controllo di
            accesso</a>, aggiornamento del capitolo relativo
            all&#39;avviamento di <a href=
            "#CHA-AVVIARE-SQUID">Squid</a></td>
          </tr>

          <tr>
            <td align="left">Revisione 3.22</td>

            <td align="left">9 Novembre 2003</td>

            <td align="left"></td>
          </tr>

          <tr>
            <td align="left" colspan="3">HTCP e Cache Digest, privacy ed
            anonimato, TrendMicro InterScan Web Security Suite e Squid di
            <a href="mailto:squid@merlinobbs.net" target="_top">Stefano
            Tagliaferri</a>, annotazioni sull&#39;utilizzo di <a href=
            "#SUBSEC-WB-GROUP">wb-group 1.20</a>, alcuni cenni
            sull&#39;<a href=
            "#SEC-AUTENTICAZIONE-CON-SAMBA-3.X">Autenticazione con Samba
            3.x</a>, ampliamento della sezione sulle <a href=
            "#SEC-COSA-SONO-LE-CACHE-GERARCHICHE">Cache gerarchiche</a> di
            <a href="mailto:guido.serassio@acmeconsulting.it" target=
            "_top">Guido Serassio</a></td>
          </tr>

          <tr>
            <td align="left">Revisione 3.21</td>

            <td align="left">14 Settembre 2003</td>

            <td align="left"></td>
          </tr>

          <tr>
            <td align="left" colspan="3">Alcune annotazioni
            sull&#39;utilizzo delle <a href=
            "#SEC-LISTE-DI-CONTROLLO-ACL">acl</a> e dei <a href=
            "#CHA-CONTROLLI-DI-ACCESSO">controlli di accesso</a></td>
          </tr>

          <tr>
            <td align="left">Revisione 3.20</td>

            <td align="left">19 Agosto 2003</td>

            <td align="left"></td>
          </tr>

          <tr>
            <td align="left" colspan="3">Correzioni al paragrafo relativo
            alle <a href="#SEC-PUBBLICAZIONI-SU-CARTA">pubblicazioni su
            carta</a> e al paragrafo dei <a href=
            "#SEC-RIFERIMENTI">riferimenti</a>, ulteriore integrazione al
            capitolo relativo a <a href=
            "#SUBSEC-ISTRUZIONE-RISORSE-MRTG">MRTG e Squid</a>,
            rielaborazione dello schema e dei riferimenti sulla questione
            dell&#39;<a href="#SEC-AUTENTICAZIONE">autenticazione</a>,
            integrazione del paragrafo relativo ai <a href=
            "#SUBSEC-CONTROLLI-DI-ACCESSO-SITI-WEB">controlli di accesso
            sui siti web</a> ed altro.</td>
          </tr>

          <tr>
            <td align="left">Revisione 3.10</td>

            <td align="left">26 Giugno 2003</td>

            <td align="left"></td>
          </tr>

          <tr>
            <td align="left" colspan="3">Grazie al grande contributo di
            <a href="mailto:mrshark@libero.it" target="_top">Antonio
            Fragola</a> a.k.a. <a href="http://www.mrshark.it" target=
            "_top">MrShark</a> &egrave; stato possibile rilasciare la
            versione &quot;portabile&quot; dello Squid-Book, apportate
            piccole modifiche alla <a href="#SEC-LICENZA-UTILIZZO">Licenza
            utilizzo</a>, revisione globale di tutti i capitoli.</td>
          </tr>

          <tr>
            <td align="left">Revisione 3.00</td>

            <td align="left">8 Giugno 2003</td>

            <td align="left"></td>
          </tr>

          <tr>
            <td align="left" colspan="3">I log di Squid e la loro analisi,
            salvaguardare la privacy con Junkbuster e Privoxy, aggiornato
            la <a href="#SEC-LE-ORIGINI-SQUID-BOOK">La storia di questo
            documento</a>, <a href="#SEC-INTRO-SQUID-CONCLUSIONI">Squid
            Proxy Server</a>, <a href="#CHA-CONFIGURARE-SNMP">Configurare
            SNMP</a> e le <a href="#SEC-CONTROLLO-ACCESSO-SUI-SITI-WEB">FAQ
            per il controllo accesso ai siti web</a>.</td>
          </tr>

          <tr>
            <td align="left">Revisione 2.01</td>

            <td align="left">25 Aprile 2003</td>

            <td align="left"></td>
          </tr>

          <tr>
            <td align="left" colspan="3">GARR Network&#39;s FTP Archive
            diviene mirror ufficiale dello Squid-Book.</td>
          </tr>

          <tr>
            <td align="left">Revisione 2.00</td>

            <td align="left">7 Aprile 2003</td>

            <td align="left"></td>
          </tr>

          <tr>
            <td align="left" colspan="3">Autenticazione con NTLM nei domini
            Windows NT o in Active directory (<a href=
            "mailto:ego_pfe@inwind.it" target="_top">Federico Lombardo</a>
            - note per la compilazione di <a href=
            "mailto:guido.serassio@acmeconsulting.it" target="_top">Guido
            Serassio</a>), commenti alle configurazioni operative e
            inserimento di nuove configurazioni fornite dagli utenti di
            Squid. Il capitolo 19 &egrave; stato totalmente trasformato:
            gli utilizzi estremi ora sono security ed utilizzi estremi
            (determinante il contributo di Federico Lombardo, le verifiche
            sono a cura dell&#39;autore del libro)</td>
          </tr>

          <tr>
            <td align="left">Revisione 1.30</td>

            <td align="left">12 Gennaio 2003</td>

            <td align="left"></td>
          </tr>

          <tr>
            <td align="left" colspan="3">Differenze tra rel. 2.4 e 2.5
            (<a href="mailto:ego_pfe@inwind.it" target="_top">Federico
            Lombardo</a>), schemi di autenticazione (<a href=
            "mailto:guido.serassio@acmeconsulting.it" target="_top">Guido
            Serassio</a>)</td>
          </tr>

          <tr>
            <td align="left">Revisione 1.29</td>

            <td align="left">16 Novembre 2002</td>

            <td align="left"></td>
          </tr>

          <tr>
            <td align="left" colspan="3">Modificato il capitolo con il
            quale si spiega cosa &egrave; Squid (aggiornato con il link
            relativo al porting per la piattaforma Win32)</td>
          </tr>

          <tr>
            <td align="left">Revisione 1.28</td>

            <td align="left">1 Novembre 2002</td>

            <td align="left"></td>
          </tr>

          <tr>
            <td align="left" colspan="3">Modificato il capitolo dedicato
            alle funzionalit&agrave; di reverse proxy (aggiunta di esempi
            reali sul funzionamento dei reverse proxy)</td>
          </tr>

          <tr>
            <td align="left">Revisione 1.27</td>

            <td align="left">15 Ottobre 2002</td>

            <td align="left"></td>
          </tr>

          <tr>
            <td align="left" colspan="3">Rilascio della prima versione
            pubblica in formato HTML</td>
          </tr>
        </table>
      </div>

      <div class="ABSTRACT">
        <a name="AEN8" id="AEN8"></a>

        <p>Squid-Book oltre le FAQ (Squid-2.5.STABLE5) - L&#39;unica guida
        in lingua italiana a Squid Proxy Server <a href=
        "#SEC-LICENZA-UTILIZZO">Copyright</a> &copy; 1999 - 2004 Stefano
        Tagliaferri</p>

        <p><img src="squid.png" alt="" /></p>

        <p><a href="../HTML/index.html" target="_top">Split HTML</a> -
        <a href="../HTM/index.html" target="_top">Single HTML</a></p>
      </div>
      <hr />
    </div>

    <div class="TOC">
      <dl>
        <dt><strong>Sommario</strong></dt>

        <dt>1. <a href="#CHA-INFORMAZIONI">Informazioni</a></dt>

        <dd>
          <dl>
            <dt>1.1. <a href="#SEC-PUBBLICAZIONI-SU-CARTA">Pubblicazioni su
            carta</a></dt>

            <dt>1.2. <a href="#SEC-NOTE-SUL-LIBRO">Note sul libro</a></dt>

            <dt>1.3. <a href="#SEC-NOTE-SU-AUTORE">Note
            sull&#39;autore</a></dt>

            <dt>1.4. <a href="#SEC-ALTRE-ANNOTAZIONI">Altre
            annotazioni</a></dt>

            <dt>1.5. <a href="#SEC-LICENZA-UTILIZZO">Licenza
            d&#39;utilizzo</a></dt>

            <dt>1.6. <a href="#SEC-RIFERIMENTI">Riferimenti</a></dt>
          </dl>
        </dd>

        <dt>2. <a href="#CHA-LA-STORIA-DI-SQUID">La storia di Squid e dello
        Squid-Book</a></dt>

        <dd>
          <dl>
            <dt>2.1. <a href=
            "#SEC-PREAMBOLO-STORIA-SQUID">Preambolo</a></dt>

            <dt>2.2. <a href="#SEC-UN-PROGRAMMA-LIBERO">Un programma
            libero</a></dt>

            <dt>2.3. <a href="#SEC-SQUID-MAILING-LISTS">Mailing
            lists</a></dt>

            <dt>2.4. <a href="#SEC-LE-ORIGINI-SQUID-BOOK">Le origini dello
            Squid-Book</a></dt>

            <dt>2.5. <a href="#SEC-CHI-SVILUPPA">Chi sviluppa oggi lo
            Squid-Book</a></dt>

            <dt>2.6. <a href="#SEC-SQUID-IN-ITALIA">Squid, il software
            libero e la situazione Italiana</a></dt>
          </dl>
        </dd>

        <dt>3. <a href="#CHA-COSA-E-SQUID">Cosa &egrave; Squid</a></dt>

        <dd>
          <dl>
            <dt>3.1. <a href="#SEC-PREAMBOLO-SQUID">Preambolo</a></dt>

            <dt>3.2. <a href="#SEC-COME-LAVORA-WEBCACHE">Come lavora un
            apparato di webcache</a></dt>

            <dt>3.3. <a href="#SEC-RIDUZIONE-ESIG-BANDA">Riduzione delle
            esigenze di banda</a></dt>

            <dt>3.4. <a href="#SEC-FATTORI">Fattori che determinano il
            risparmio di banda</a></dt>

            <dd>
              <dl>
                <dt>3.4.1. <a href="#SUBSEC-CONTENUTI-PAGINA-WEB">contenuti
                pagina web</a></dt>

                <dt>3.4.2. <a href="#SUBSEC-NUMERO-UTENTI">numero degli
                utenti</a></dt>

                <dt>3.4.3. <a href="#SUBSEC-TIPOLOGIA-UTENTI">tipologia
                degli utenti</a></dt>

                <dt>3.4.4. <a href="#SUBSEC-TIPO-WEBCACHE">tipo di webcache
                utilizzata</a></dt>

                <dt>3.4.5. <a href="#SUBSEC-TIPOLOGIA-RETE">tipologia della
                rete</a></dt>
              </dl>
            </dd>

            <dt>3.5. <a href="#SEC-CONTROLLO-E-SICUREZZA">Controllo e
            sicurezza</a></dt>

            <dt>3.6. <a href="#SEC-UNA-PICCOLA-PANORAMICA-SU-HTTP">Una
            piccola panoramica su <em>HTTP</em></a></dt>

            <dt>3.7. <a href="#SEC-PICCOLA-PANORAMICA-SU-WWWCACHE">Una
            piccola panoramica su <em>WWWCACHE</em></a></dt>

            <dt>3.8. <a href="#SEC-COSA-SONO-LE-CACHE-GERARCHICHE">Cosa
            sono le cache gerarchiche</a></dt>

            <dd>
              <dl>
                <dt>3.8.1. <a href="#SEC-INTERNET-CACHE-PROTOCOL">Internet
                Cache Protocol (<em>ICP</em>)</a></dt>

                <dt>3.8.2. <a href=
                "#SEC-CACHE-ARRAY-ROUTING-PROTOCOL">Cache Array Routing
                Protocol (<em>CARP</em>)</a></dt>

                <dt>3.8.3. <a href="#SEC-HTCP">Hyper Text Caching Protocol
                (<em>HTCP</em>)</a></dt>

                <dt>3.8.4. <a href="#SEC-CACHE-DIGEST">Cache
                Digest</a></dt>
              </dl>
            </dd>

            <dt>3.9. <a href=
            "#SEC-INTRO-SQUID-CONCLUSIONI">Concludendo</a></dt>
          </dl>
        </dd>

        <dt>4. <a href="#CHA-OS-CHE-SUPPORTANO-SQUID">I sistemi operativi
        che supportano Squid</a></dt>

        <dd>
          <dl>
            <dt>4.1. <a href="#SEC-PREAMBOLO-KIND-OS">Preambolo</a></dt>

            <dt>4.2. <a href="#SEC-PIATTAFORME-SPEC">Piattaforme
            specifiche</a></dt>

            <dt>4.3. <a href="#SEC-PLATFORM-UNIX">Sistemi
            UNIX&reg;</a></dt>

            <dd>
              <dl>
                <dt>4.3.1. <a href="#SUBSEC-PLATFORM-LINUX">GNU
                Linux</a></dt>

                <dt>4.3.2. <a href=
                "#SUBSEC-PLATFORM-FREEBSD">FreeBSD</a></dt>
              </dl>
            </dd>

            <dt>4.4. <a href="#SEC-PLATFORM-WINDOZE">Sistemi
            Windows</a></dt>

            <dt>4.5. <a href="#SEC-PLATFORM-OS2">Sistemi OS/2</a></dt>
          </dl>
        </dd>

        <dt>5. <a href="#CHA-DIFFERENZE-TRA-24-E-25">Differenze tra Squid
        2.4 e Squid 2.5</a></dt>

        <dd>
          <dl>
            <dt>5.1. <a href=
            "#SEC-PREAMBOLO-SQUID-DIFF24-25">Preambolo</a></dt>

            <dt>5.2. <a href="#SEC-AUTENTICAZIONE">Autenticazione</a></dt>

            <dt>5.3. <a href="#SEC-SSL-GATEWAYING">SSL Gatewaying</a></dt>

            <dt>5.4. <a href="#SEC-LINK-SATELLITARI">Link
            Satellitari</a></dt>

            <dt>5.5. <a href="#SEC-24VS25-SQUID.CONF">modifiche al file
            <em>squid.conf</em></a></dt>

            <dt>5.6. <a href=
            "#SEC-ALCUNE-CONSIDERAZIONI">Considerazioni</a></dt>
          </dl>
        </dd>

        <dt>6. <a href="#CHA-CASE-OF-STUDY">Casi di studio</a></dt>

        <dd>
          <dl>
            <dt>6.1. <a href="#SEC-SISTEMI-IN-TEST">Sistemi in
            test</a></dt>

            <dt>6.2. <a href="#SEC-SISTEMI-IN-PRODUZIONE">Sistemi in
            produzione</a></dt>
          </dl>
        </dd>

        <dt>7. <a href="#CHA-CONFIGURAZIONE">Configurare ed installare
        Squid</a></dt>

        <dd>
          <dl>
            <dt>7.1. <a href=
            "#SEC-PREAMBOLO-CONFIGURAZIONE">Preambolo</a></dt>

            <dt>7.2. <a href="#SEC-SCEGLI-OS">Scegliere il Sistema
            Operativo</a></dt>

            <dt>7.3. <a href="#SEC-REGOLE-CAPABILITIES">Regole da
            rispettare</a></dt>

            <dd>
              <dl>
                <dt>7.3.1. <a href="#SUBSEC-NOTE-SULLA-RAM">Utilizzo della
                memoria RAM</a></dt>

                <dt>7.3.2. <a href="#SUBSEC-TIPO-DI-CPU">Tipo di
                CPU</a></dt>

                <dt>7.3.3. <a href="#SUBSEC-SISTEMI-SMP">Sistemi
                SMP</a></dt>

                <dt>7.3.4. <a href=
                "#SUBSEC-SOTTOSISTEMA-DISCHI">Sottosistema dischi e
                tecnologie</a></dt>

                <dt>7.3.5. <a href="#SUBSEC-SISTEMI-RAID">Sistemi in
                RAID</a></dt>
              </dl>
            </dd>

            <dt>7.4. <a href="#SEC-SISTEMA-OTTIMALE">Il sistema
            ottimale</a></dt>

            <dt>7.5. <a href="#SEC-SOURCE-CODE">I file sorgenti di
            Squid</a></dt>

            <dd>
              <dl>
                <dt>7.5.1. <a href="#SUBSEC-PRELEVARE-SQUID">Prelevare
                Squid</a></dt>

                <dt>7.5.2. <a href="#SUBSEC-COMPILARE-SQUID">Compilare
                Squid</a></dt>

                <dt>7.5.3. <a href="#SUBSEC-APPLICARE-LE-PATCH">Applicare
                le patch</a></dt>

                <dt>7.5.4. <a href="#SUBSEC-VERSIONE-GIORNALIERA">Versione
                giornaliera autogenerata</a></dt>

                <dt>7.5.5. <a href="#SUBSEC-OPZIONI-DI-CONFIGURE">Opzioni
                di configurazione</a></dt>
              </dl>
            </dd>

            <dt>7.6. <a href="#SEC-FILE-DESCRIPTOR">Il problema dei
            <em>file descriptor</em></a></dt>

            <dd>
              <dl>
                <dt>7.6.1. <a href=
                "#SUBSEC-NUMERO-FILE-DESCRIPTOR">Determinare il numero
                corretto di <em>file descriptor</em></a></dt>

                <dt>7.6.2. <a href="#SUBSEC-FD-LINUX"><em>File
                descriptor</em> con Linux</a></dt>

                <dt>7.6.3. <a href="#SUBSEC-FD-SOLARIS"><em>File
                descriptor</em> con Solaris</a></dt>

                <dt>7.6.4. <a href="#SUBSEC-DF-FREEBSD"><em>File
                descriptors</em> con FreeBSD</a></dt>

                <dt>7.6.5. <a href="#SUBSEC-FD-WINDOWS"><em>File
                descriptors</em> con Windows</a></dt>

                <dt>7.6.6. <a href="#SUBSEC-FILE-HANDLES-OS2"><em>File
                handles</em> con OS/2</a></dt>
              </dl>
            </dd>

            <dt>7.7. <a href="#SEC-INSTALLARE-SQUID-SRC">Installare Squid
            dai sorgenti</a></dt>

            <dd>
              <dl>
                <dt>7.7.1. <a href=
                "#SUBSEC-PERCHE-INS-SQUID-SORGENTI">Perch&egrave;
                installare Squid dai sorgenti</a></dt>

                <dt>7.7.2. <a href="#SUBSEC-INSTALLA-COMANDI-IMPORTANTI">I
                comandi pi&ugrave; importanti</a></dt>

                <dt>7.7.3. <a href=
                "#SUBSEC-ALBERO-DIRECTORY-MAKEINSTALL">L&#39;albero delle
                directory</a></dt>

                <dt>7.7.4. <a href="#SUBSEC-PULIRE-GLI-ESEGUIBILI">Pulire
                gli eseguibili dalle informazioni di debug</a></dt>

                <dt>7.7.5. <a href=
                "#SUBSEC-INFO-INSTALLARE-DA-SORGENTI">Altre informazioni
                per installare correttamente Squid dai sorgenti</a></dt>
              </dl>
            </dd>

            <dt>7.8. <a href=
            "#SEC-PACCHETTI-PRECOMPILATI">Disponibilit&agrave; di pacchetti
            precompilati</a></dt>

            <dd>
              <dl>
                <dt>7.8.1. <a href="#SUBSEC-PACKAGE-AMBIENTI-UNIX">Package
                per i vari ambienti UNIX&reg;</a></dt>

                <dt>7.8.2. <a href="#SUBSEC-PACKAGE-WIN32-OS2">Package per
                Win32 ed OS/2</a></dt>
              </dl>
            </dd>
          </dl>
        </dd>

        <dt>8. <a href="#CHA-POSTINSTALLAZIONE">Postinstallazione</a></dt>

        <dd>
          <dl>
            <dt>8.1. <a href=
            "#SEC-POSTINSTALLAZIONE-PRELIMINARI">Preliminari</a></dt>

            <dt>8.2. <a href="#SEC-OPZIONI-DI-RETE">Opzioni di
            rete</a></dt>

            <dt>8.3. <a href="#SEC-OPZ-CHE-DEF-CACHE-GERAR">Opzioni che
            definiscono una cache gerarchica</a></dt>

            <dt>8.4. <a href="#SEC-OPZIONI-FILES-LOG">Files di log, memoria
            e cache</a></dt>

            <dd>
              <dl>
                <dt>8.4.1. <a href="#SUBSEC-FILES-DI-LOG-PRINCIPALI">Files
                di log principali</a></dt>

                <dt>8.4.2. <a href="#SUBSEC-FILES-DI-LOG-ACCESSORI">Files
                di log accessori</a></dt>

                <dt>8.4.3. <a href="#SUBSEC-FORMATI-FILES-LOG">Formati dei
                files di log</a></dt>

                <dt>8.4.4. <a href="#SUBSEC-RUOTARE-I-FILES-LOG">Ruotare i
                files di log</a></dt>

                <dt>8.4.5. <a href=
                "#SUB-SEC-DISABILITARE-FILES-LOG">Disabilitare i files di
                log</a></dt>

                <dt>8.4.6. <a href="#SUBSEC-MIME-TIPE-E-PIDFILE">Mime tipe
                e file di processo</a></dt>

                <dt>8.4.7. <a href="#SUBSEC-MEMORIA-E-CACHE-DIR">Memoria e
                <em>cache_dir</em></a></dt>
              </dl>
            </dd>

            <dt>8.5. <a href="#SEC-PARAMETRI-AMMINISTRATIVI">Parametri
            amministrativi</a></dt>

            <dt>8.6. <a href="#SEC-UTENTE-E-GROUPID">Utente e Gruppo
            (<em>UID e GID</em>)</a></dt>

            <dt>8.7. <a href="#SEC-REDIRECT">Redirect</a></dt>

            <dt>8.8. <a href="#SEC-CONFIGURAZIONE-STARTUP">La
            configurazione di startup (<em>squid.conf</em>)</a></dt>
          </dl>
        </dd>

        <dt>9. <a href="#CHA-IL-CACHE-STORE">Il Cache Store di
        Squid</a></dt>

        <dd>
          <dl>
            <dt>9.1. <a href=
            "#SEC-PREAMBOLO-CACHE-STORE">Preambolo</a></dt>

            <dt>9.2. <a href="#SEC-PROBLEMATICHE-UFS">Alcune problematiche
            legate al tipo di filesystem</a></dt>

            <dt>9.3. <a href="#SEC-OTTIMIZZAZIONE-FILESYSTEM">Eseguire
            l&#39;ottimizzazione del file system</a></dt>

            <dt>9.4. <a href="#SEC-RISERVARE-SPAZIO-DISCO">Riservare
            correttamente lo spazio al Cache Storage</a></dt>

            <dt>9.5. <a href="#SEC-LE-COMP-DEL-CACHE-STORE">Le componenti
            del Cache Store</a></dt>

            <dt>9.6. <a href="#SEC-DISK-STORAGE">Disk Storage</a></dt>

            <dd>
              <dl>
                <dt>9.6.1. <a href="#SUBSEC-UFS"><em>ufs</em>
                storage</a></dt>

                <dt>9.6.2. <a href="#SUBSEC-AUFS"><em>aufs</em>
                storage</a></dt>

                <dt>9.6.3. <a href="#SUBSEC-AWIN32"><em>awin32</em>
                storage</a></dt>

                <dt>9.6.4. <a href="#SUBSEC-DISKD"><em>diskd</em>
                storage</a></dt>

                <dd>
                  <dl>
                    <dt>9.6.4.1. <a href=
                    "#SUBSUBSEC-TUNING-DEI-PARAMETRI-Q1-Q2">Tuning dei
                    parametri Q1 e Q2</a></dt>

                    <dt>9.6.4.2. <a href=
                    "#SUBSUBSEC-CONFIGURARE-LA-CODA-MESSAGGI">Configurare
                    la coda dei messaggi (<em>message queues</em>)</a></dt>

                    <dt>9.6.4.3. <a href=
                    "#SUBSUBSEC-CODA-DEI-MESSAGGI-BSD">Coda dei messaggi
                    con BSD</a></dt>

                    <dt>9.6.4.4. <a href=
                    "#SUBSUBSEC-CODA-DEI-MESSAGGI-LINUX">Coda dei messaggi
                    con Linux</a></dt>

                    <dt>9.6.4.5. <a href=
                    "#SUBSUBSEC-CODA-DEI-MESSAGGI-SOLARIS">Coda dei
                    messaggi con Solaris</a></dt>

                    <dt>9.6.4.6. <a href=
                    "#SUBSUBSEC-CONFIGURARE-LA-MEMORIA-SHARED">Configurare
                    la memoria condivisa (<em>shared memory</em>)</a></dt>

                    <dt>9.6.4.7. <a href=
                    "#SUBSUCSEC-MEMORIA-CONDIVISA-BSD">Memoria condivisa
                    con BSD</a></dt>

                    <dt>9.6.4.8. <a href=
                    "#SUBSUBSEC-MEMORIA-CONDIVISA-LINUX">Memoria condivisa
                    con Linux</a></dt>

                    <dt>9.6.4.9. <a href=
                    "#SUBSUBSEC-MEMORIA-CONDIVISA-SOLARIS">Memoria
                    condivisa con Solaris</a></dt>
                  </dl>
                </dd>

                <dt>9.6.5. <a href="#SUBSEC-NULL"><em>null</em>
                storage</a></dt>

                <dt>9.6.6. <a href="#SUBSEC-COSS"><em>coss</em>
                storage</a></dt>

                <dt>9.6.7. <a href="#SUBSEC-SCELTA-DEL-DISK">Scelta del
                Disk storage pi&ugrave; adatto</a></dt>

                <dt>9.6.8. <a href=
                "#SUBSEC-ESEMPI-DI-CONFIGURAZIONE-DISK">Esempi di
                configurazione</a></dt>

                <dd>
                  <dl>
                    <dt>9.6.8.1. <a href=
                    "#SUBSUBSEC-CONFIGURARE-DISKD-FREEBSD">Configurare
                    <em>diskd</em> con FreeBSD</a></dt>

                    <dt>9.6.8.2. <a href=
                    "#SUBSUBSEC-CONFIGURARE-UFS">Configurare <em>ufs</em>
                    (multipiattaforma)</a></dt>

                    <dt>9.6.8.3. <a href=
                    "#SUBSUBSEC-CONFIGURARE-AUFS-LINUX">Configurare
                    <em>aufs</em> con Linux</a></dt>

                    <dt>9.6.8.4. <a href=
                    "#SUBSUBSEC-CONFIGURARE-AWIN32-WINDOWS">Configurare
                    <em>awin32</em> con Windows</a></dt>
                  </dl>
                </dd>
              </dl>
            </dd>

            <dt>9.7. <a href="#SEC-MEMORY-STORAGE">Memory storage</a></dt>

            <dd>
              <dl>
                <dt>9.7.1. <a href=
                "#SUBSEC-PARAMETRI-DI-CONFIGURAZIONE-MEM">Parametri di
                configurazione</a></dt>
              </dl>
            </dd>

            <dt>9.8. <a href="#SEC-CACHE-REPLACEMENT-POLICY">Memory e Cache
            Replacement Policy</a></dt>

            <dd>
              <dl>
                <dt>9.8.1. <a href=
                "#SUBSEC-CACHE-REPLACEMENT-POLICY-REPL">Parametri di
                configurazione</a></dt>
              </dl>
            </dd>

            <dt>9.9. <a href=
            "#SEC-REGOLE-DI-DIMENSIONAMENTO-STORE">Indicazione
            dimensionamento del cache store</a></dt>
          </dl>
        </dd>

        <dt>10. <a href="#CHA-CONTROLLI-DI-ACCESSO">Controlli di
        accesso</a></dt>

        <dd>
          <dl>
            <dt>10.1. <a href="#SEC-PREAMBOLO-CONTR-ACC">Preambolo</a></dt>

            <dt>10.2. <a href="#SEC-ELEMENTI-DELLE-ACL">Elementi che
            compongono le <em>ACL</em></a></dt>

            <dt>10.3. <a href="#SEC-LISTE-DI-CONTROLLO-ACL">Capire il
            funzionamento delle <em>ACL</em></a></dt>

            <dt>10.4. <a href="#SEC-ACL-AUTENTICAZIONE-UTENTI">Utilizzare
            le <em>ACL</em> per autenticare degli utenti</a></dt>

            <dt>10.5. <a href="#SEC-EXTERNAL-ACL">External
            <em>ACL</em></a></dt>

            <dd>
              <dl>
                <dt>10.5.1. <a href="#SUBSEC-WB-GROUP">wb_group</a></dt>

                <dt>10.5.2. <a href="#SUBSEC-WBINFO-GROUP-SAMBA3">Utilizzo
                di wbinfo_group con Samba 3</a></dt>

                <dt>10.5.3. <a href=
                "#SUBSEC-WIN32-CHECK-GROUP">win32_check_group</a></dt>

                <dt>10.5.4. <a href=
                "#SUBSEC-SQUID-LDAP-GROUP">squid_ldap_group</a></dt>

                <dt>10.5.5. <a href=
                "#SUBSEC-SQUID-UNIX-GROUP">squid_unix_group</a></dt>

                <dt>10.5.6. <a href=
                "#SUBSEC-IP-GROUP-CHECK">ip_group_check</a></dt>
              </dl>
            </dd>

            <dt>10.6. <a href=
            "#SEC-CONTROLLO-ACCESSO-SUI-SITI-WEB">Controllo d&#39;accesso
            sui siti web</a></dt>

            <dd>
              <dl>
                <dt>10.6.1. <a href=
                "#SUBSEC-CONTROLLI-DI-ACCESSO-SITI-WEB">Controlli di
                accesso e URL filtering</a></dt>

                <dt>10.6.2. <a href="#SUBSEC-DEFINIRE-LISTA-SITI">Definire
                una lista di siti visitabili</a></dt>

                <dt>10.6.3. <a href=
                "#SEC-RAGG-DIRETTAMENTE-SITI">Raggiungere direttamente
                domini o siti predefiniti</a></dt>

                <dt>10.6.4. <a href="#SEC-NO-CACHE">No cache</a></dt>
              </dl>
            </dd>

            <dt>10.7. <a href="#SEC-ACL-BASATE-MACADDRESS"><em>ACL</em>
            basate sul MAC address</a></dt>
          </dl>
        </dd>

        <dt>11. <a href="#CHA-AUTENTICAZIONE-UTENTI">Autenticazione degli
        utenti</a></dt>

        <dd>
          <dl>
            <dt>11.1. <a href=
            "#SEC-PREAMBOLO-AUTENTICAZIONE">Preambolo</a></dt>

            <dt>11.2. <a href="#SEC-SCHEMI-DI-AUTENTICAZIONE">Schemi di
            autenticazione</a></dt>

            <dd>
              <dl>
                <dt>11.2.1. <a href="#SUBSEC-BASIC-AUTHENTICATION">Basic
                authentication</a></dt>

                <dt>11.2.2. <a href="#SUBSEC-NTLM-AUTHENTICATION">NTLM
                authentication</a></dt>

                <dt>11.2.3. <a href="#SUBSEC-DIGEST-AUTHENTICATION">Digest
                authentication</a></dt>
              </dl>
            </dd>

            <dt>11.3. <a href="#SEC-PARAMETRI-DI-CONFIGURAZIONE">Parametri
            di Configurazione</a></dt>

            <dt>11.4. <a href="#SEC-BASIC-AUTHENTICATION">Basic
            Authentication</a></dt>

            <dd>
              <dl>
                <dt>11.4.1. <a href=
                "#SUBSEC-CONF-BASIC-AUTH-2.5">Configurazione in Squid
                2.5</a></dt>

                <dt>11.4.2. <a href=
                "#SUBSEC-CONF-BASIC-AUTH-2.4">Configurazione in Squid
                2.4</a></dt>

                <dt>11.4.3. <a href="#SUBSEC-NCSA">helper NCSA</a></dt>

                <dd>
                  <dl>
                    <dt>11.4.3.1. <a href=
                    "#SUBSUBSEC-GENERARE-IL-DB-DEGLI-UTENTI">Generare il DB
                    degli utenti</a></dt>
                  </dl>
                </dd>

                <dt>11.4.4. <a href="#SUBSEC-PAM">helper PAM</a></dt>

                <dd>
                  <dl>
                    <dt>11.4.4.1. <a href=
                    "#SUBSUBSEC-RED-HAT-LINUX-PAM">Red Hat Linux</a></dt>

                    <dt>11.4.4.2. <a href=
                    "#SUBSUBSEC-UNIX-STANDARD-PAM">Unix Standard</a></dt>
                  </dl>
                </dd>

                <dt>11.4.5. <a href="#SUBSEC-LDAP">helper LDAP</a></dt>

                <dd>
                  <dl>
                    <dt>11.4.5.1. <a href=
                    "#SUBSEC-ES-DI-CONFIGURAZIONE-LDAP">Esempi di
                    configurazione</a></dt>
                  </dl>
                </dd>

                <dt>11.4.6. <a href="#SUBSEC-WINBIND">helper
                Winbindd</a></dt>

                <dt>11.4.7. <a href="#SUBSEC-MSNT">helper MSNT</a></dt>
              </dl>
            </dd>

            <dt>11.5. <a href="#SEC-SQUID-25-AUTENTICAZIONE-NTLM">NTLM
            Authentication</a></dt>

            <dd>
              <dl>
                <dt>11.5.1. <a href=
                "#SUBSEC-CONF-NTLM-AUTHENTICATION">Configurazione</a></dt>

                <dt>11.5.2. <a href="#SEC-AUTH-NTLM-NATIVA">Autenticazione
                NTLM nativa</a></dt>

                <dd>
                  <dl>
                    <dt>11.5.2.1. <a href="#SUBSEC-NTLM-AUTH">helper SMB
                    (ntlm_auth)</a></dt>

                    <dt>11.5.2.2. <a href=
                    "#SUBSEC-FAKEAUTH-AND-NO-CHECK">helper fakeauth &amp;
                    no_check</a></dt>

                    <dt>11.5.2.3. <a href="#SEC-WINDOWS-NTLM-AUTH">helper
                    Windows win32_ntlm_auth</a></dt>
                  </dl>
                </dd>

                <dt>11.5.3. <a href=
                "#SEC-AUTENTICAZIONE-CON-SAMBA-2.2.X">Autenticazione NTLM
                con Samba 2.2.x</a></dt>

                <dd>
                  <dl>
                    <dt>11.5.3.1. <a href=
                    "#SEC-COMPILAZIONE-HELPERS">Compilazione
                    helpers</a></dt>

                    <dt>11.5.3.2. <a href=
                    "#SEC-CONFIGURAZIONE-DI-SAMBA2">Configurazione di
                    Samba2</a></dt>

                    <dt>11.5.3.3. <a href="#SEC-WINBIND">helper
                    wb_ntlmauth</a></dt>
                  </dl>
                </dd>

                <dt>11.5.4. <a href=
                "#SEC-AUTENTICAZIONE-CON-SAMBA-3.X">Autenticazione NTLM con
                Samba3</a></dt>

                <dd>
                  <dl>
                    <dt>11.5.4.1. <a href="#SEC-SAMBA3-NTLM-AUTH">helper
                    esterno Samba 3.x ntlm_auth</a></dt>

                    <dt>11.5.4.2. <a href=
                    "#SUBSEC-INSERIRE-NEL-DOMINIO">Inserire nel dominio la
                    macchina Samba 3.0</a></dt>
                  </dl>
                </dd>

                <dt>11.5.5. <a href="#SEC-PROB-COMUNI-CON-NTLM">Problemi
                comuni con NTLM</a></dt>

                <dd>
                  <dl>
                    <dt>11.5.5.1. <a href="#SUBSEC-JAVA-RUNTIME">Java
                    runtime</a></dt>

                    <dt>11.5.5.2. <a href="#SUBSEC-FTP">ftp</a></dt>

                    <dt>11.5.5.3. <a href="#SUBSEC-WINDOWS-2003">Windows
                    2003</a></dt>

                    <dt>11.5.5.4. <a href=
                    "#SUBSEC-UTENTI-NON-AUTENTICATI">Utenti non
                    autenticati</a></dt>
                  </dl>
                </dd>
              </dl>
            </dd>

            <dt>11.6. <a href="#SEC-DIGEST-AUTHENTICATION">Digest
            Authentication</a></dt>

            <dd>
              <dl>
                <dt>11.6.1. <a href=
                "#SEC-CONFIGURAZIONE-DIGEST">Configurazione</a></dt>

                <dd>
                  <dl>
                    <dt>11.6.1.1. <a href="#SEC-PASSWORD-DIGEST">helper
                    digest_pw_auth</a></dt>
                  </dl>
                </dd>
              </dl>
            </dd>
          </dl>
        </dd>

        <dt>12. <a href="#CHA-AVVIARE-SQUID">Avviare Squid</a></dt>

        <dd>
          <dl>
            <dt>12.1. <a href="#SEC-PREAMBOLO-AVVIO">Preambolo</a></dt>

            <dt>12.2. <a href="#SEC-MULTIPIATTAFORMA">Istruzioni
            multipiattaforma</a></dt>

            <dt>12.3. <a href="#SEC-AVVIARE-SQUID-AUTOMATICAMENTE">Avviare
            Squid automaticamente con il boot del sistema</a></dt>

            <dd>
              <dl>
                <dt>12.3.1. <a href=
                "#SUB-SEC-AVVIARE-SQUID-INITTAB">Avviare Squid utilizzando
                la tabella di <em>inittab</em></a></dt>

                <dt>12.3.2. <a href=
                "#SUBSEC-AVVIARE-UTILIZZANDO-RCLOCAL">Avviare Squid
                utilizzando il file <em>rc.local</em></a></dt>

                <dt>12.3.3. <a href="#SUBSEC-AVVIARE-BSD">Avviare Squid con
                i sistemi <em>*BSD</em></a></dt>
              </dl>
            </dd>

            <dt>12.4. <a href="#SEC-AVVIARE-VERSIONE-COMPILATA-RH">Avviare
            una versione compilata su Red Hat Linux</a></dt>

            <dt>12.5. <a href="#SEC-REDHAT-FEDORA">RedHat, Fedora Core e
            Mandrake Linux</a></dt>

            <dt>12.6. <a href="#SEC-DEBIAN">Debian GNU/Linux</a></dt>

            <dt>12.7. <a href="#SEC-FREEBSD">FreeBSD</a></dt>

            <dt>12.8. <a href="#SEC-OS2">OS/2 o EComStation</a></dt>

            <dt>12.9. <a href="#SEC-WINDOWS">Windows
            NT/2000/XP/2003</a></dt>
          </dl>
        </dd>

        <dt>13. <a href="#CHA-CONFIGURARE-SNMP">Monitorare il funzionamento
        di Squid</a></dt>

        <dd>
          <dl>
            <dt>13.1. <a href=
            "#SEC-PREAMBOLO-MONITORING">Preambolo</a></dt>

            <dt>13.2. <a href="#SEC-SQUID-CON-SNMP">Squid ed SNMP</a></dt>

            <dd>
              <dl>
                <dt>13.2.1. <a href=
                "#SUBSEC-CONFIGURAZIONE-SUPPORTO-SNMP">Configurazione
                supporto SNMP</a></dt>

                <dt>13.2.2. <a href="#SUBSEC-MRTG-E-SQUID">MRTG e
                Squid</a></dt>

                <dt>13.2.3. <a href=
                "#SUBSEC-ISTRUZIONE-RISORSE-MRTG">Istruzioni e risorse per
                utilizzare Squid con MRTG</a></dt>
              </dl>
            </dd>

            <dt>13.3. <a href="#SEC-CACHE-MANAGER">Il Cache
            Manager</a></dt>

            <dd>
              <dl>
                <dt>13.3.1. <a href=
                "#SUBSEC-CONF-CACHEMANAGER-APACHE">Configurare il Cache
                Manager con Apache</a></dt>

                <dt>13.3.2. <a href="#SUBSEC-CACHEMGR-PASSWORD">Impostare
                la password di accesso al Cache Manager</a></dt>

                <dt>13.3.3. <a href="#SUBSEC-ACL-CACHEMGR">Definire una ACL
                per consentire l&#39;accesso al Cache Manager</a></dt>
              </dl>
            </dd>
          </dl>
        </dd>

        <dt>14. <a href="#CHA-OPZIONI-DI-SHELL">Opzioni offerte dal comando
        <em>squid(8)</em></a></dt>

        <dd>
          <dl>
            <dt>14.1. <a href=
            "#SEC-PREAMBOLO-OPZIONI-SHELL">Preambolo</a></dt>

            <dt>14.2. <a href="#SEC-OPZIONI-SQUID">Opzioni di
            squid(8)</a></dt>
          </dl>
        </dd>

        <dt>15. <a href="#CHA-PRIVACY">Privacy</a></dt>

        <dd>
          <dl>
            <dt>15.1. <a href="#SEC-PREAMBOLO-PRIVACY">Preambolo</a></dt>

            <dt>15.2. <a href="#SEC-NOTE-OPERATIVE">Note operative</a></dt>

            <dt>15.3. <a href="#SEC-INTERNET-JUNKBUSTER">Internet
            Junkbuster</a></dt>

            <dd>
              <dl>
                <dt>15.3.1. <a href=
                "#SUBSEC-DEFINIZIONI-ED-ALBERO">Definizioni ed albero delle
                directory, file di configurazione</a></dt>

                <dt>15.3.2. <a href=
                "#SUBSEC-VERIFICARE-IL-FUNZIONAMENTO">Verificare il
                funzionamento di Junkbuster</a></dt>
              </dl>
            </dd>

            <dt>15.4. <a href="#SEC-PRIVOXY">Privoxy</a></dt>

            <dd>
              <dl>
                <dt>15.4.1. <a href=
                "#SUBSEC-FILES-DI-CONFIGURAZIONE-DI-PRIVOXY">files di
                configurazione di Privoxy</a></dt>
              </dl>
            </dd>

            <dt>15.5. <a href="#SEC-ADZAPPING">Ad Zapping con
            Squid</a></dt>

            <dd>
              <dl>
                <dt>15.5.1. <a href=
                "#SUBSEC-DIFF-JUNKBUSTER-PRIVOXY">Differenze con Junkbuster
                e Privoxy</a></dt>

                <dt>15.5.2. <a href="#SUBSEC-VANTAGGI-RIDIREZIONE">Vantaggi
                della ridirezione</a></dt>

                <dt>15.5.3. <a href=
                "#SUBSEC-PREREQUISITI-ADZAP">Prerequisiti di Ad
                Zapping</a></dt>

                <dt>15.5.4. <a href=
                "#SUBSEC-INSTALLARE-AD-ZAPPING">installare Ad
                Zapping</a></dt>
              </dl>
            </dd>

            <dt>15.6. <a href="#SEC-WEBCACHING-ANONIMO">Fornire agli utenti
            un servizio di Web Caching anonimo</a></dt>
          </dl>
        </dd>

        <dt>16. <a href="#CHA-COMUNICARE-CON-ALTRI-PROXY-SERVER">Comunicare
        con altri proxy server</a></dt>

        <dd>
          <dl>
            <dt>16.1. <a href="#SEC-PREAMBOLO-GERARCHIE">Preambolo</a></dt>

            <dt>16.2. <a href="#SEC-ESEMPI-RELAZIONI-WEBCACHE">Esempi e
            relazioni tra webcache</a></dt>

            <dt>16.3. <a href="#SEC-INFO-IRCACHE">Alcune informazioni su
            IRCACHE</a></dt>

            <dt>16.4. <a href="#SEC-GARR">Alcune informazioni sul Servizio
            di Cache Nazionale GARR</a></dt>
          </dl>
        </dd>

        <dt>17. <a href="#CHA-PROXY-TRASPARENTE">Proxy trasparente</a></dt>

        <dd>
          <dl>
            <dt>17.1. <a href=
            "#SEC-PREAMBOLO-TRANSPARENT-PROXY">Preambolo</a></dt>

            <dt>17.2. <a href="#SEC-CONCETTO-IN-LINE-CACHE">Concetto di
            inline cache</a></dt>

            <dd>
              <dl>
                <dt>17.2.1. <a href=
                "#SUBSEC-APP-ESEGUE-FILTRO-PACCHETTI">L&#39;applicazione
                che esegue il filtro dei pacchetti</a></dt>

                <dt>17.2.2. <a href="#SUBSEC-TRANSPARENT-NOTE">Alcune
                annotazioni</a></dt>

                <dt>17.2.3. <a href=
                "#SUBSEC-FILTRAGGIO-CON-GNU-LINUX">Filtraggio con GNU
                Linux</a></dt>

                <dt>17.2.4. <a href=
                "#SUBSEC-FILTRAGGIO-CON-FREEBSD">Filtraggio con
                FreeBSD</a></dt>

                <dd>
                  <dl>
                    <dt>17.2.4.1. <a href="#SUBSUBSEC-IPFW">utilizziamo
                    <em>ipfw</em></a></dt>
                  </dl>
                </dd>

                <dt>17.2.5. <a href="#SUBSUBSEC-ALTRI-OS-UNIX">Filtraggio
                con altri sistemi UNIX&reg;</a></dt>

                <dd>
                  <dl>
                    <dt>17.2.5.1. <a href=
                    "#SUBSUBSEC-UTILIZZIAMO-IPF">utilizziamo
                    <em>ipf</em></a></dt>
                  </dl>
                </dd>

                <dt>17.2.6. <a href="#SUBSEC-INLINE-CACHE-CON-LINUX">Esempi
                di inline cache con Linux</a></dt>

                <dd>
                  <dl>
                    <dt>17.2.6.1. <a href=
                    "#SUBSUBSEC-CONF-TRANSPARENT-PROXY-LINUX20">Configurare
                    il proxy trasparente con Linux kernel 2.0.x</a></dt>

                    <dt>17.2.6.2. <a href=
                    "#SUBSUBSEC-CONF-TRANSPARENT-PROXY-LINUX22">Configurare
                    il proxy trasparente con Linux kernel 2.2.x</a></dt>

                    <dt>17.2.6.3. <a href=
                    "#SUBSUBSEC-CONF-TRANSPARENT-PROXY-LINUX24">Configurare
                    il proxy trasparente con Linux kernel 2.4.x e
                    2.6.x</a></dt>
                  </dl>
                </dd>

                <dt>17.2.7. <a href=
                "#SUBSEC-CONF-SQUID-TRANSPARENT">Abilitare inline cache con
                Squid</a></dt>

                <dt>17.2.8. <a href=
                "#SUBSEC-CONF-IPMASQUERADE">L&#39;<em>ipmasquerade</em> con
                LINUX kernel 2.2.x/2.4.x</a></dt>
              </dl>
            </dd>

            <dt>17.3. <a href="#SEC-SWITCH-DI-LIVELLO-QUATTRO">Gli switch
            di livello quattro</a></dt>

            <dt>17.4. <a href="#SEC-WCCP">WCCP (Web Cache Coordination
            Protocol)</a></dt>

            <dd>
              <dl>
                <dt>17.4.1. <a href=
                "#SUBSEC-CONFIGURARE-WCCP-CON-IOS">Configurare WCCP con
                Cisco IOS</a></dt>

                <dt>17.4.2. <a href=
                "#SUBSEC-CONFIGURARE-WCCP-CON-SQUID">Configurare WCCP con
                Squid</a></dt>

                <dt>17.4.3. <a href="#SEC-FREEBSD-GRE-TUNNEL">Abilitare
                l&#39;interfaccia GRE con FreeBSD</a></dt>

                <dt>17.4.4. <a href="#SEC-LINUX-2.2-GRE-TUNNEL">Abilitare
                l&#39;interfaccia GRE con Linux</a></dt>
              </dl>
            </dd>

            <dt>17.5. <a href="#SEC-I-ROUTER-CISCO">Policy di routing con i
            router Cisco</a></dt>
          </dl>
        </dd>

        <dt>18. <a href="#CHA-REVERSE-PROXY">Reverse proxy</a></dt>

        <dd>
          <dl>
            <dt>18.1. <a href="#SEC-SERVER-HTTPD-E-CONTENT-CACHING">Server
            HTTPD e content caching</a></dt>

            <dt>18.2. <a href="#SEC-REVERSE-PROXY-SEMPLICE">Reverse
            Proxy</a></dt>

            <dt>18.3. <a href="#SEC-SSL-REVERSE-PROXY">SSL Reverse
            Proxy</a></dt>

            <dt>18.4. <a href="#SEC-ESEMPI-E-SITUAZIONI-REALI">Esempi e
            situazioni reali</a></dt>

            <dd>
              <dl>
                <dt>18.4.1. <a href="#SUBSEC-REVERSE-NEWHOST">Reverse Proxy
                di Server web o cluster HA installati su una macchina
                differente</a></dt>

                <dt>18.4.2. <a href="#SUBSEC-REVERSE-LOCALHOST">Reverse
                Proxy di server web installato sulla stessa macchina che
                esegue Squid</a></dt>

                <dt>18.4.3. <a href="#SUBSEC-REVERSE-MULTIDOM">Reverse
                Proxy per domini multipli</a></dt>

                <dt>18.4.4. <a href="#SUBSEC-SSL-REVERSE-PROXY">SSL Reverse
                Proxy di un server web o di un cluster HA installato su una
                macchina differente</a></dt>
              </dl>
            </dd>
          </dl>
        </dd>

        <dt>19. <a href="#CHA-PROXY-LOAD-BALANCER">Proxy load
        balancer</a></dt>

        <dd>
          <dl>
            <dt>19.1. <a href=
            "#SEC-PREAMBOLO-LOAD-BALANCER">Preambolo</a></dt>

            <dt>19.2. <a href="#SEC-WPAD-PROTOCOL">WPAD protocol</a></dt>

            <dt>19.3. <a href="#SEC-DHCP-E-CONF">DHCP e configurazione
            automatica del browser</a></dt>

            <dt>19.4. <a href="#SEC-FAIL-OVER-E-LOAD-BALANCER">Fail over e
            load balancer</a></dt>
          </dl>
        </dd>

        <dt>20. <a href=
        "#CHA-LIMITAZIONE-DELLA-BANDA-PER-CLASSI">Limitazione della banda
        per classi</a></dt>

        <dd>
          <dl>
            <dt>20.1. <a href=
            "#SEC-LIMITARE-LA-BANDA-DISPONIBILE">Preambolo</a></dt>

            <dt>20.2. <a href="#SEC-SQUID-DELAY-POOLS">Squid ed i Delay
            pools</a></dt>

            <dd>
              <dl>
                <dt>20.2.1. <a href="#SUBSEC-LIMITARE-128K">Limitare la
                banda per singole connessioni a 128 kbps</a></dt>

                <dt>20.2.2. <a href="#SUBSEC-LIMITARE-512KBPS">Limitare la
                banda totale a 512 kbps</a></dt>

                <dt>20.2.3. <a href="#SUBSEC-LIMITARE-HDSL">Limitare la
                banda con una linea a 2 Mbps</a></dt>
              </dl>
            </dd>

            <dt>20.3. <a href=
            "#SEC-LIMITAZIONE-DOWNLOAD-ALCUNI-FILES">Limitare il download
            di alcuni files</a></dt>
          </dl>
        </dd>

        <dt>21. <a href="#CHA-SECURITY-ED-UTILIZZI-ESTREMI">Security ed
        utilizzi estremi</a></dt>

        <dd>
          <dl>
            <dt>21.1. <a href="#SEC-PREAMBOLO-SECURITY">Preambolo</a></dt>

            <dt>21.2. <a href="#SEC-SQUID-COME-ULTIMA-RISORSA">Squid come
            ultima risorsa</a></dt>

            <dt>21.3. <a href="#SEC-SQUID-E-LA-SICUREZZA">Squid e la
            sicurezza</a></dt>

            <dd>
              <dl>
                <dt>21.3.1. <a href=
                "#SUBSEC-SICUREZZA-IN-QUANTO-SERVIZIO">Sicurezza in quanto
                Servizio</a></dt>
              </dl>
            </dd>

            <dt>21.4. <a href="#SEC-SQUID-ED-ANTIVIRUS">Squid ed
            Antivirus</a></dt>

            <dd>
              <dl>
                <dt>21.4.1. <a href=
                "#SUBSEC-INTERSCAN-WEB-SECURITY">InterScan Web Security
                Suite</a></dt>
              </dl>
            </dd>

            <dt>21.5. <a href="#SEC-SICUREZZA-CON-OS-OSPITANTE">Sicurezza
            come interazione con il sistema operativo ospitante</a></dt>

            <dd>
              <dl>
                <dt>21.5.1. <a href=
                "#SUBSEC-SISTEMI-UNIX-CLONI-BSD">Sistemi UNIX&reg;, cloni e
                BSD</a></dt>

                <dt>21.5.2. <a href="#SUBSEC-LA-MODALITA-CHROOT">La
                modalit&agrave; <em>chroot()</em> nei sistemi UNIX&reg;
                cloni o BSD</a></dt>
              </dl>
            </dd>

            <dt>21.6. <a href="#SEC-SQUID-E-DAEMONTOOLS">Squid e
            Daemontools</a></dt>

            <dt>21.7. <a href="#SEC-SISTEMI-WINDOWS">Sistemi
            Windows</a></dt>

            <dt>21.8. <a href="#SEC-SISTEMI-OS2">Sistemi OS/2</a></dt>
          </dl>
        </dd>

        <dt>22. <a href="#CHA-I-LOG-DI-SQUID-E-LA-LORO-ANALISI">La analisi
        dei log di Squid</a></dt>

        <dd>
          <dl>
            <dt>22.1. <a href=
            "#SEC-PREAMBOLO-LOG-ANALISI">Preambolo</a></dt>

            <dt>22.2. <a href="#SEC-I-LOG-NATIVI">I log nativi</a></dt>

            <dt>22.3. <a href="#SEC-LOG-IN-ALTRI-FORMATI">Log in altri
            formati</a></dt>

            <dt>22.4. <a href="#SEC-IL-FILE-CACHE.LOG">Troubleshooting con
            il file <em>cache.log</em></a></dt>

            <dd>
              <dl>
                <dt>22.4.1. <a href="#SUBSEC-CACHE-LOG-TAIL">Utilizzare
                <em>tail</em>(8) ed <em>xterm</em>(8)</a></dt>

                <dt>22.4.2. <a href="#SUBSEC-LIVELLI-DI-DEBUG">Livelli di
                debug</a></dt>
              </dl>
            </dd>

            <dt>22.5. <a href="#SEC-CODICI-DI-STATO">I codici di stato di
            Squid</a></dt>

            <dt>22.6. <a href="#SEC-CODICI-DI-STATO-HTTP">Codici di Stato
            HTTP</a></dt>

            <dt>22.7. <a href="#SEC-METODI-DI-RICHIESTA">Metodi di
            richiesta supportati</a></dt>

            <dt>22.8. <a href="#SEC-CODICI-GERARCHICI-PER-PEERING">Codici
            gerarchici per il peering con altre webcache</a></dt>

            <dt>22.9. <a href="#SEC-STRUMENTI-DI-ANALISI-DEI-LOG">Strumenti
            di analisi dei Log</a></dt>

            <dd>
              <dl>
                <dt>22.9.1. <a href="#SUBSEC-CALAMARIS">Calamaris</a></dt>

                <dt>22.9.2. <a href="#SUBSEC-WEBALIZER">Webalizer</a></dt>

                <dt>22.9.3. <a href="#SUBSEC-SARG">Sarg</a></dt>

                <dt>22.9.4. <a href="#SUBSEC-SQUEEZER2">Squeezer2</a></dt>

                <dt>22.9.5. <a href="#SUBSEC-YAALA">Yaala</a></dt>

                <dt>22.9.6. <a href=
                "#SUBSEC-SQUIDALYSER">SquidAlyser</a></dt>

                <dt>22.9.7. <a href="#SUBSEC-LOGREP">Logrep</a></dt>

                <dt>22.9.8. <a href="#SUBSEC-LIRE">LIRE</a></dt>

                <dt>22.9.9. <a href=
                "#SUBSEC-SQUIDEFENDER">Squidefender</a></dt>
              </dl>
            </dd>
          </dl>
        </dd>

        <dt>23. <a href="#CHA-UNA-CONFIGURAZIONE-OPERATIVA">Una
        configurazione operativa</a></dt>

        <dt>24. <a href="#CHA-COLOPHON">Colophon e revisioni</a></dt>

        <dd>
          <dl>
            <dt>24.1. <a href=
            "#SEC-APPLICAZIONI-REALIZZAZIONE-LIBRO">Applicazioni
            utilizzate</a></dt>

            <dt>24.2. <a href="#SEC-REVISIONI-DEL-LIBRO">Revisioni del
            libro</a></dt>
          </dl>
        </dd>

        <dt>25. <a href="#CHA-GNU-FREE-DOCUMENTATION">GNU Free
        Documentation License</a></dt>

        <dt>26. <a href="#CHA-ELENCO-DEI-MIRROR-AUTORIZZATI">Elenco dei
        mirror autorizzati</a></dt>
      </dl>
    </div>

    <div class="CHAPTER">
      <hr />

      <h1><a name="CHA-INFORMAZIONI" id="CHA-INFORMAZIONI"></a>Capitolo 1.
      Informazioni</h1>

      <div class="SECT1">
        <h2 class="SECT1"><a name="SEC-PUBBLICAZIONI-SU-CARTA" id=
        "SEC-PUBBLICAZIONI-SU-CARTA"></a>1.1. Pubblicazioni su carta</h2>

        <p>RedHat Magazine - The journal for Linux System Administrators
        (Anno I - Num. 3 - Marzo/Aprile 2003) - <em>WPAD</em>:
        riconoscimento automatico del proxy server (pagina 10) -
        l&#39;articolo &egrave; un dettagliato approfondimento del capitolo
        relativo al <a href="#SEC-WPAD-PROTOCOL">WPAD Protocol</a> che
        contiene la descrizione di una vera e propria soluzione
        &quot;corporate&quot;.</p>
      </div>

      <div class="SECT1">
        <hr />

        <h2 class="SECT1"><a name="SEC-NOTE-SUL-LIBRO" id=
        "SEC-NOTE-SUL-LIBRO"></a>1.2. Note sul libro</h2>

        <p>Questo libro viene fornito con le stesse garanzie della
        maggioranza dei software commerciali: <em>non esiste alcuna
        garanzia, n&eacute; implicita, n&eacute; esplicita</em>
        relativamente all&#39;adeguatezza per uso particolare o per la
        commerciabilit&agrave;. <em>L&#39;autore non si assume alcuna
        responsabilit&agrave; per eventuali danni diretti o indiretti che
        questa documentazione potrebbe arrecare al vostro sistema
        informatico</em>. L&#39;utilizzo &egrave; a Vostro rischio e
        pericolo ;-)</p>
      </div>

      <div class="SECT1">
        <hr />

        <h2 class="SECT1"><a name="SEC-NOTE-SU-AUTORE" id=
        "SEC-NOTE-SU-AUTORE"></a>1.3. Note sull&#39;autore</h2>

        <p>Stefano Tagliaferri &egrave; <em>Network &amp; Security
        manager</em>, <em>System Engineer</em> e <em>Red Hat Certified
        Engineer</em>, le principali specializzazioni sono la progettazione
        di infrastrutture informatiche, tecnologiche, dei sistemi
        informativi e delle reti perimetrali. Le conoscenze sistemistiche
        vanno dagli apparati di rete della Cisco Systems (routers, firewall
        ecc..) alle piattaforme UNIX&reg; (Linux e *BSD) nonch&egrave;
        sistemi Windows (Active Directory) ed OS/2.</p>
      </div>

      <div class="SECT1">
        <hr />

        <h2 class="SECT1"><a name="SEC-ALTRE-ANNOTAZIONI" id=
        "SEC-ALTRE-ANNOTAZIONI"></a>1.4. Altre annotazioni</h2>

        <p>Questo libro si &egrave; perfezionato senza eventuali protezioni
        di brevetti d&#39;invenzione, inoltre i nomi coperti da eventuale
        marchio registrato vengono utilizzati senza tenerne conto.</p>
      </div>

      <div class="SECT1">
        <hr />

        <h2 class="SECT1"><a name="SEC-LICENZA-UTILIZZO" id=
        "SEC-LICENZA-UTILIZZO"></a>1.5. Licenza d&#39;utilizzo</h2>

        <p>Questo libro viene rilasciato sotto la <a href=
        "http://www.gnu.org/licenses/licenses.html" target="_top">GNU Free
        Documentation License</a>, chiunque pu&ograve; modificarlo e
        migliorarlo rispettandone la sola propriet&agrave; intellettuale
        dell&#39;Autore o di chi con l&#39;Autore ha collaborato, citando
        in modo visibile, in tutte le sue pagine: &quot;Versione originale
        di Stefano Tagliaferri (<a href="mailto:squid@merlinobbs.net"
        target="_top">squid(at)merlinobbs.net</a> - <a href=
        "http://www.merlinobbs.net" target=
        "_top">http://www.merlinobbs.net</a>), alla stesura di alcune parti
        del documento ha partecipato Leo Pedone (<a href=
        "mailto:lan.to@tiscalinet.it" target=
        "_top">lan.to(at)tiscalinet.it</a>). Questo libro &egrave;
        rilasciato sotto <a href=
        "http://www.gnu.org/licenses/licenses.html" target="_top">GNU Free
        Documentation License</a> - &copy; 1999 - 2004 Stefano
        Tagliaferri&quot;.</p>

        <p>Per divenire mirror autorizzato della distribuzione in HTML o in
        altri formati &egrave; necessario richiedere espressa
        autorizzazione a Stefano Tagliaferri (<a href=
        "mailto:squid@merlinobbs.net" target=
        "_top">squid(at)merlinobbs.net</a>),l&#39;elenco dei mirror
        autorizzati dall&#39;autore viene specificato in un capitolo del
        libro stesso.</p>

        <p>Il censimento dei mirror, oltre ad essere una questione di pura
        &quot;statistica&quot;, consente anche di mantenere una versione
        sempre aggiornata e centralizzata dell&#39;opera.</p>

        <p>Questo libro, in tutte le sue versioni (anche quelle modificare
        da terzi in Italiano o in qualsiasi altra lingua), per
        volont&agrave; dell&#39;autore, pu&ograve; essere riprodotto anche
        integralmente senza violare nessuna legge in quanto questo libro
        &egrave; rilasciato sotto <a href=
        "http://www.gnu.org/licenses/licenses.html" target="_top">GNU Free
        Documentation License</a>.</p>

        <p>Questa pubblicazione si &egrave; perfezionata senza eventuali
        protezioni di brevetti d&#39;invenzione, inoltre, i nomi coperti da
        eventuale marchio registrato vengono utilizzati senza tenerne
        conto.</p>
      </div>

      <div class="SECT1">
        <hr />

        <h2 class="SECT1"><a name="SEC-RIFERIMENTI" id=
        "SEC-RIFERIMENTI"></a>1.6. Riferimenti</h2>

        <p>La presente documentazione fa parte del progetto Squid (<a href=
        "http://www.squid-cache.org/Doc/#non-english" target=
        "_top">http://www.squid-cache.org/Doc/#non-english</a>). Oltre al
        lavoro svolto personalmente ed ai contributi di <em>Leo
        Pedone</em>, <em>Federico Lombardo</em>, <em>Guido Serassio</em> e
        <em>Antonio Fragola</em>, cito anche tutti i riferimenti che hanno
        permesso la stesura di alcune parti di questo documento</p>

        <ul>
          <li>
            <p>URLs del progetto Squid: <a href=
            "http://www.squid-cache.org/" target=
            "_top">http://www.squid-cache.org/</a></p>
          </li>

          <li>
            <p>Mirror italiano del progetto Squid: <a href=
            "http://www1.it.squid-cache.org/" target=
            "_top">http://www1.it.squid-cache.org/</a></p>
          </li>

          <li>
            <p>URLs Security Focus per la security: <a href=
            "http://www.securityfocus.com/" target=
            "_top">http://www.securityfocus.com/</a></p>
          </li>

          <li>
            <p>Squid Frequently Asked Questions (FAQ) &copy;2001 Duane
            Wessels: <a href="http://www.squid-cache.org/Doc/FAQ/" target=
            "_top">http://www.squid-cache.org/Doc/FAQ/</a></p>
          </li>

          <li>
            <p>Squid Configuring Hierarchical Squid Caches di Duane
            Wessels: <a href=
            "http://www.squid-cache.org/Doc/Hierarchy-Tutorial/" target=
            "_top">http://www.squid-cache.org/Doc/Hierarchy-Tutorial/</a></p>
          </li>

          <li>
            <p>Squid Programmers Guide di Duane Wessels: <a href=
            "http://www.squid-cache.org/Doc/Prog-Guide/" target=
            "_top">http://www.squid-cache.org/Doc/Prog-Guide/</a></p>
          </li>

          <li>
            <p>Squid User&#39;s Guide di Oskar Pearson: <a href=
            "http://squid-docs.sourceforge.net/" target=
            "_top">http://squid-docs.sourceforge.net/</a></p>
          </li>

          <li>
            <p>IRCache Project: <a href="http://www.ircache.net/" target=
            "_top">http://www.ircache.net/</a></p>
          </li>

          <li>
            <p>Benefits of Web Caching di <a href=
            "mailto:joe@swelltech.com" target="_top">Joe Cooper</a> alla
            URLs: <a href="http://www.swelltech.com/support/benefits/"
            target=
            "_top">http://www.swelltech.com/support/benefits/</a></p>
          </li>

          <li>
            <p>Designing a Web Caching Infrastructure for Your Network di
            <a href="mailto:joe@swelltech.com" target="_top">Joe Cooper</a>
            alla URLs: <a href=
            "http://www.swelltech.com/support/sizecache/index.html" target=
            "_top">http://www.swelltech.com/support/sizecache/index.html</a></p>
          </li>
        </ul>
      </div>
    </div>

    <div class="CHAPTER">
      <hr />

      <h1><a name="CHA-LA-STORIA-DI-SQUID" id=
      "CHA-LA-STORIA-DI-SQUID"></a>Capitolo 2. La storia di Squid e dello
      Squid-Book</h1>

      <div class="SECT1">
        <h2 class="SECT1"><a name="SEC-PREAMBOLO-STORIA-SQUID" id=
        "SEC-PREAMBOLO-STORIA-SQUID"></a>2.1. Preambolo</h2>

        <p>Squid HTTP Proxy &egrave; il pi&ugrave; conosciuto nonch&egrave;
        il pi&ugrave; utilizzato dei Web Proxy Server che fornisce
        funzionalit&agrave; di caching e proxing per il traffico HTTP, FTP
        e Gopher. Squid pu&ograve; anche essere utilizzato come motore
        HTTP/HTTPs per eseguire avanzate tecniche di reverse proxy. Squid
        &egrave; fondamentalmente il risultato del lavoro di moltissime
        persone della comunit&agrave; internet mondiale, in particolare
        &egrave; stato ideato e realizzato da <em>Duane Wessels</em> che
        &egrave; anche membro del Laboratorio Nazionale di Ricerca per le
        Applicazioni di Rete; Duane ha dato vita alla Fondazione Nazionale
        delle Scienze.</p>
      </div>

      <div class="SECT1">
        <hr />

        <h2 class="SECT1"><a name="SEC-UN-PROGRAMMA-LIBERO" id=
        "SEC-UN-PROGRAMMA-LIBERO"></a>2.2. Un programma libero</h2>

        <p>Squid &egrave; un programma libero (<em>Free Software</em>)
        coperto da copyright &quot;Regents of the University of California
        San Diego&quot; (<a href=
        "http://www.squid-cache.org/Doc/FAQ/squid-copyright.txt" target=
        "_top">http://www.squid-cache.org/Doc/FAQ/squid-copyright.txt</a>)
        e pu&ograve; essere ridistribuito e modificato secondo quanto
        previsto dall&#39;accordo della Licenza Pubblica GNU (<a href=
        "http://www.gnu.org/licenses/licenses.html" target=
        "_top">http://www.gnu.org/licenses/licenses.html</a>) ed il
        programma viene distribuito all&#39;utente finale senza nessuna
        garanzia.</p>

        <p>Nella GNU Pubblice License (<a href=
        "http://www.gnu.org/licenses/gpl.html" target=
        "_top">http://www.gnu.org/licenses/gpl.html</a>) sono contenuti
        tutti i dettagli che regolano la distribuzione del prodotto, Squid
        trae la sua origine dal programma &quot;cached&quot; che fu
        realizzato dalla <em>ARPA-Founded Harvest Research</em>. Per
        distinguere questo nuovo proxy server da quello prodotto dalla
        <em>Harvest</em>, si decise di chiamarlo con il nome del progetto
        iniziale: <em>Squid</em> &quot;il calamaro&quot;. <em>Henrik
        Nordstrom</em>, uno dei migliori hackers del progetto Squid, a tale
        proposito afferma: &quot;il nome Squid non &egrave; una
        abbreviazione, il calamaro &egrave; un animale marino che in
        qualche modo si comporta proprio come il nostro proxy server. Le
        cache gerarchiche ed il protocollo ICP (Internet Cache Protocol)
        possono essere paragonati ai tentacoli che il calamaro utilizza per
        fare suo tutto quello che lo interessa&quot; (<a href=
        "http://www.squid-cache.org/mail-archive/squid-users/200404/0954.html"
           target=
           "_top">http://www.squid-cache.org/mail-archive/squid-users/200404/0954.html</a>).</p>
      </div>

      <div class="SECT1">
        <hr />

        <h2 class="SECT1"><a name="SEC-SQUID-MAILING-LISTS" id=
        "SEC-SQUID-MAILING-LISTS"></a>2.3. Mailing lists</h2>

        <p>Per migliorare l&#39;utilizzo di Squid, le sue
        funzionalit&agrave;, le performance e per contribuire al lavoro di
        miglioramento nonch&egrave; alla continua correzione dei problemi,
        &egrave; possibile aderire a cinque mailing lists</p>

        <ul>
          <li>
            <p><a href="mailto:squid-users@squid-cache.org" target=
            "_top">squid-users@squid-cache.org</a> - discussioni generali
            sull&#39;utilizzo di squid</p>
          </li>

          <li>
            <p><a href="mailto:squid-announce@squid-cache.org" target=
            "_top">squid-announce@squid-cache.org</a> - lista per il
            rilascio delle nuove release</p>
          </li>

          <li>
            <p><a href="mailto:squid-bugs@squid-cache.org" target=
            "_top">squid-bugs@squid-cache.org</a> - lista per
            l&#39;annuncio dei nuovi bugs e problemi</p>
          </li>

          <li>
            <p><a href="mailto:squid@squid-cache.org" target=
            "_top">squid@squid-cache.org</a> - lista per il feedback e
            nuove idee</p>
          </li>

          <li>
            <p><a href="mailto:squid-faq@squid-cache.org" target=
            "_top">squid-faq@squid-cache.org</a> - lista per il feedback,
            gli aggiornamenti e contributi addizionali per le Squid FAQ</p>
          </li>
        </ul>

        <p>mailing lists non strettamente legate al progetto Squid</p>

        <ul>
          <li>
            <p><a href="mailto:cache-snmp@ircache.net" target=
            "_top">cache-snmp@ircache.net</a> - lista sulle implementazioni
            del protocollo SNMP in ambito webcaching</p>
          </li>

          <li>
            <p><a href="mailto:icp-wg@ircache.net" target=
            "_top">icp-wg@ircache.net</a> - lista dell&#39;ICP Working
            Group e di IETF (<a href="http://www.ietf.org/" target=
            "_top">The Internet Engineering Task Force</a>)</p>
          </li>
        </ul>
      </div>

      <div class="SECT1">
        <hr />

        <h2 class="SECT1"><a name="SEC-LE-ORIGINI-SQUID-BOOK" id=
        "SEC-LE-ORIGINI-SQUID-BOOK"></a>2.4. Le origini dello
        Squid-Book</h2>

        <p>Questo documento nasce nell&#39;estate del 1999 perch&egrave;
        all&#39;epoca, in Italia, ancora nessuno aveva avuto l&#39;idea di
        scrivere della documentazione su Squid per facilitarne e
        sponsorizzarne l&#39;utilizzo. In particolare il documento prendeva
        corpo come risposta alle esigenze dei partecipanti del gruppo di
        discussione della rete usenet italiana <a href=
        "news:it.comp.os.os2" target="_top">it.comp.os.os2</a>.</p>

        <p>Gli utenti del gruppo desideravano avere maggiori informazioni
        sulle funzionalit&agrave; di Squid ed allora decisi di creare
        quello che nessuno in Italia aveva mai realizzato: <em>le FAQ in
        lingua Italiana</em>.</p>

        <p>Le prime versioni dell&#39;opera sono state pubblicate alla URLs
        <a href="http://merlino.ghostbbs.tk/" target=
        "_top">http://merlino.ghostbbs.cx/</a>, in seguito, le nuove
        versioni, complete di nuove informazioni, sono state pubblicate
        alla URLs <a href="http://www.merlinobbs.net/" target=
        "_top">http://www.merlinobbs.net/</a>.</p>

        <p>Negli anni la documentazione &egrave; rimasta a disposizione
        della comunit&agrave; internet sino a quando alcuni individui
        decisero di copiare l&#39;opera perseguendo evidenti scopi di
        lucro: la pubblicazione avvenne senza avvertire e/o citare i
        legittimi proprietari del lavoro.</p>

        <p>Alla nascita ed allo sviluppo primordiale di questo documento ha
        collaborato con grande entusiasmo <em>Leo Pedone</em> (<a href=
        "mailto:lan.to@tiscalinet.it" target=
        "_top">lan.to@tiscalinet.it</a>), al quale sar&ograve; sempre grato
        per tutti i grandi ed i piccoli insegnamenti che mi ha voluto
        donare. Anche se il documento ben presto divenne un vero e proprio
        punto di riferimento per chi lavorava nell&#39;ambito
        &quot;networking&quot;, nessun membro della comunit&agrave; OS/2
        italiana ha mai contribuito allo sviluppo successivo o
        all&#39;integrazione dell&#39;opera.</p>

        <p>Per questi motivi e per altre questioni che in questo contesto
        non sono degne di nota, l&#39;opera non &egrave; stata pi&ugrave;
        disponibile agli utenti internet. Contemporaneamente decisi di
        abbandonare lo studio e la ricerca sulla piattaforma OS/2 e tutte
        le modifiche apportate successivamente al documento si sono
        evolute, in prima istanza, sulla piattaforma GNU Linux. In
        particolare molte informazioni contenute in questo tomo fanno
        riferimento alla distribuzione commerciale <a href=
        "http://www.redhat.com" target="_top">Red Hat</a> Linux.</p>

        <p>Viste le politiche di supporto e il nuovo modello commerciale
        imposto dall&#39;attuale business alle varie distribuzioni Linux,
        negli ultimi tempi si &egrave; provveduto a migrare tutte le
        configurazioni operative e di produzione sulla piattaforma FreeBSD
        (4.9-STABLE e 5.2.1-RELEASE).</p>

        <p>Con il rilascio della <em>release 1.27</em> questo libro
        &egrave; tornato finalmente a disposizione degli utenti internet.
        L&#39;idea nacque durante una discussione con gli amici del
        <a href="http://www.llg.it/" target="_top">Latina LUG</a> e
        l&#39;unico vincolo imposto all&#39;utilizzo del libro &egrave; il
        rispetto della licenza <a href="#SEC-LICENZA-UTILIZZO">GNU Free
        Documentation License</a> e delle note in &quot;addendum&quot;
        volute dall&#39;autore stesso.</p>

        <p>Qualche anno fa questa era l&#39;umile FAQ aperta al contributo
        di tutti coloro che utilizzavano Squid in Italia.</p>
      </div>

      <div class="SECT1">
        <hr />

        <h2 class="SECT1"><a name="SEC-CHI-SVILUPPA" id=
        "SEC-CHI-SVILUPPA"></a>2.5. Chi sviluppa oggi lo Squid-Book</h2>

        <p>Attualmente il progetto &quot;Italian <em>Squid-Book</em>: oltre
        le FAQ&quot; viene sviluppato da una squadra di
        <em>professionisti</em> e di <em>ricercatori</em> nel campo
        dell&#39;ICT, queste persone si sono poste l&#39;ambizioso
        obiettivo di rendere questo lavoro un vero e proprio punto di
        riferimento multipiattaforma in lingua italiana</p>

        <ul>
          <li>
            <p>responsabile del progetto: <a href=
            "mailto:stefano@merlinobbs.net" target="_top">Stefano
            Tagliaferri</a></p>
          </li>

          <li>
            <p>schemi di autenticazione ed integrazione in Active
            Directory, progetto Squid per Windows: <a href=
            "mailto:guido.serassio@acmeconsulting.it" target="_top">Guido
            Serassio</a></p>
          </li>

          <li>
            <p>integrazione in Active Directory, external ACL, sicurezza e
            sistemi di logging: <a href="mailto:ego_pfe@inwind.it" target=
            "_top">Federico Lombardo</a></p>
          </li>

          <li>
            <p>revisioni, forma espositiva, formattazione e rilascio delle
            nuove versioni: <a href="mailto:stefano@merlinobbs.net" target=
            "_top">Stefano Tagliaferri</a></p>
          </li>

          <li>
            <p>formattazione e distribuzione nei vari formati incluso SGML:
            <a href="mailto:mrshark@libero.it" target="_top">Antonio
            Fragola</a> aka Mr.Shark</p>
          </li>
        </ul>

        <p>Le ultime versioni del libro che hanno ampliato e sviluppato
        piuttosto approfonditamente tutte le funzionalit&agrave; pi&ugrave;
        importanti offerte da Squid, riflettono fondamentalmente due tipi
        di approccio sull&#39;utilizzo del Proxy stesso. Da una parte
        c&#39;&egrave; l&#39;utente ed il sistemista di rete esigente che
        viene impersonificato dal lavoro svolto da Stefano, dall&#39;altra
        c&#39;&egrave; l&#39;approccio proprio del programmatore che viene
        impersonificato dalla figura di Guido. Le due concezioni
        nell&#39;approccio all&#39;utilizzo di Squid finiscono per fondersi
        dando all&#39;opera quel tocco di fruibilit&agrave; e di
        funzionalit&agrave; che certo non guasta e rende interessante
        l&#39;intero progetto documentale. Lo Squid-Book rimane comunque
        aperto all&#39;eventuale contributo di nuovi sviluppatori, per
        maggiori dettagli fare riferimento al responsabile del
        progetto.</p>
      </div>

      <div class="SECT1">
        <hr />

        <h2 class="SECT1"><a name="SEC-SQUID-IN-ITALIA" id=
        "SEC-SQUID-IN-ITALIA"></a>2.6. Squid, il software libero e la
        situazione Italiana</h2>

        <p>I proxy servers, oltre ad essere utilizzati anche sulla rete
        internet, vengono installati soprattutto nelle LAN/WAN private di
        grandi dimensioni. Come vedremo in seguito, gli amministratori di
        rete possono trarre grande vantaggio dall&#39;utilizzo di Squid
        grazie alle sue comprovate capacit&agrave; di velocizzazione, di
        controllo sugli accessi, di gestione delle risorse e del suo
        elevatissimo livello di sicurezza.</p>

        <p>In Italia sino a qualche anno fa era molto difficile trovare in
        produzione dei software Open Source con queste caratteristiche,
        molto spesso il compito di caching veniva affidato ad alcuni
        software commerciali che non presentavano n&egrave; la
        stabilit&agrave; n&egrave; le performance applicative che sono
        proprie di un prodotto come Squid Proxy. La situazione, grazie
        anche a questo documento, sta rapidamente evolvendo ed il numero
        dei programmi installati &egrave; in continua crescita.</p>

        <p>Ancora una volta ci troviamo di fronte il dilemma tra lo
        scegliere un prodotto commerciale che viene supportato da uno
        specifico produttore, ed il <em>software libero</em> che viene
        invece sorretto da una immensa comunit&agrave; di sviluppatori,
        appassionati ed utenti. Le risorse economiche del business
        contrapposte alla conoscenza, alla genialit&agrave; ed
        all&#39;ingegno. L&#39;immobilit&agrave; della cattedrale
        contrapposta con la velocit&agrave; del modello bazar (cfr. saggio
        di Eric S. Raymond disponibile alla URL <a href=
        "http://www.apogeonline.com/openpress/doc/cathedral.html" target=
        "_top">http://www.apogeonline.com/openpress/doc/cathedral.html</a>).</p>
      </div>
    </div>

    <div class="CHAPTER">
      <hr />

      <h1><a name="CHA-COSA-E-SQUID" id="CHA-COSA-E-SQUID"></a>Capitolo 3.
      Cosa &egrave; Squid</h1>

      <div class="SECT1">
        <h2 class="SECT1"><a name="SEC-PREAMBOLO-SQUID" id=
        "SEC-PREAMBOLO-SQUID"></a>3.1. Preambolo</h2>

        <p>&Eacute; fondamentale effettuare alcune premesse per la
        comprensione delle funzionalit&agrave; di un sistema dedicato alla
        webcache e quindi del proxy server Squid.</p>

        <p>Un sistema di webcache viene generalmente implementato con un
        apparato di rete dedicato che &egrave; stato progettato per
        memorizzare e trattenere nella memoria locale, la cache, tutti gli
        oggetti web che sono stati richiesti dagli utenti con maggiore
        frequenza. Tale sistema fa in modo che gli oggetti, memorizzati
        nella cache locale, non debbano pi&ugrave; essere richiesti
        direttamente dalla rete internet e quindi riduce la
        necessit&agrave; di utilizzo della banda dedicata. Grazie
        all&#39;utilizzo di queste device di webcache, gli utenti della
        reti aziendali o dei vari ISP (Internet Service Provider)
        rimarranno soddisfatti per la velocit&agrave; con la quale
        accederanno alle risorse web e le contestuali necessit&agrave; di
        banda dedicata verranno decisamente ridotte.</p>

        <p>Come sappiamo, internet &egrave; una rete immensa ed il world
        wide web &egrave; principalmente composto da ipertesti, immagini ed
        altri files che vengono offerti dai rispettivi server di origine;
        tali apparati sono dislocati nei posti pi&ugrave; disparati del
        pianeta e la richiesta degli oggetti <em>www</em> necessita di
        banda ed alta velocit&agrave;. Gli amministratori delle reti
        studiano e progettano i sistemi di accesso alle risorse web e
        cercano di garantire un livello di servizio molto elevato, uno
        degli obiettivi principali che viene perseguito &egrave; quello di
        ridurre i costi mantenendo le performance molto elevate senza dover
        incrementare le risorse di banda internet dedicate.</p>

        <p>Una device di webcaching &egrave; l&#39;unico sistema che
        consente di mantenere alto il livello del servizio e ridurre i
        costi: l&#39;inserimento di queste device all&#39;interno del
        nostro network determina la riduzione di utilizzo della banda
        disponibile, nel caso di pagine statiche i valori percentuali
        relativi alla riduzione varieranno dal 30% al 40%, ma molto dipende
        anche dal numero e dal tipo di utenti presenti sulla rete.</p>
      </div>

      <div class="SECT1">
        <hr />

        <h2 class="SECT1"><a name="SEC-COME-LAVORA-WEBCACHE" id=
        "SEC-COME-LAVORA-WEBCACHE"></a>3.2. Come lavora un apparato di
        webcache</h2>

        <p>Un dispositivo di webcache memorizza una copia degli oggetti web
        e dei dati maggiormente richiesti in uno spazio disco dedicato
        (cfr. capitolo dedicato al <a href="#CHA-IL-CACHE-STORE">Cache
        Store</a> di Squid). Un utente che si trova all&#39;interno di una
        rete che non fa ricorso all&#39;utilizzo di questi apparati
        visualizzer&agrave; una pagina web eseguendo una richiesta diretta
        che verr&agrave; inoltrata immediatamente al servente remoto. Il
        giorno successivo lo stesso utente richieder&agrave; nuovamente
        quella pagina web e probabilmente ne disporr&agrave; di una copia
        memorizzata nella cache del suo browser. Se nello stesso momento
        pi&ugrave; utenti all&#39;interno della medesima rete richiederanno
        l&#39;accesso alla stessa pagina web, effettueranno ciascuno una
        connessione al server d&#39;origine utilizzando sempre la stessa
        banda. L&#39;installazione di una o pi&ugrave; device di webcache
        consente di richiedere il contenuto di un oggetto web una sola
        volta per poi memorizzarlo sulla cache locale e renderlo
        disponibile per tutti gli utenti.</p>
      </div>

      <div class="SECT1">
        <hr />

        <h2 class="SECT1"><a name="SEC-RIDUZIONE-ESIG-BANDA" id=
        "SEC-RIDUZIONE-ESIG-BANDA"></a>3.3. Riduzione delle esigenze di
        banda</h2>

        <p>Quando una device di webcache viene inserita in un network
        sar&agrave; il solo apparato di rete abilitato a contattare i
        serventi di origine dei dati. In questo contesto l&#39;apparato
        viene normalmente situato all&#39;interno di una Local Area Network
        (LAN) e solo gli utenti accreditati all&#39;interno di quella rete
        potranno accedervi. I dati transiteranno unicamente sulla rete
        locale senza appesantire le esigenze di banda relative alla
        connettivit&agrave; internet ed il maggior traffico dati
        avverr&agrave; tra il browser web utilizzato dagli utenti e
        l&#39;apparato di webcache stesso.</p>
      </div>

      <div class="SECT1">
        <hr />

        <h2 class="SECT1"><a name="SEC-FATTORI" id="SEC-FATTORI"></a>3.4.
        Fattori che determinano il risparmio di banda</h2>

        <p>Il relativo risparmio di banda che abbiamo gi&agrave;
        quantificato in precedenza con un valore percentuale tra il 30% e
        il 40% nel caso di pagine totalmente statiche, pu&ograve; variare
        sulla base di diversi fattori.</p>

        <div class="SECT2">
          <hr />

          <h3 class="SECT2"><a name="SUBSEC-CONTENUTI-PAGINA-WEB" id=
          "SUBSEC-CONTENUTI-PAGINA-WEB"></a>3.4.1. contenuti pagina
          web</h3>

          <p>Negli ultimi anni si &eacute; assistito ad un proliferare di
          siti web bastati su pagine che vengono create dinamicamente al
          momento della navigazione (<em>.asp</em>, <em>.mspx</em>,
          <em>.aspx</em>, <em>.jsp</em>, <em>.php</em> ecc...). &Eacute;
          evidente che con l&#39;utilizzo di tali applicazioni la
          funzionalit&agrave; di caching ne risente negativamente e quindi,
          al crescere dell&#39;utilizzo di tali tecnologie, ci si deve
          attendere un&#39;aumento dell&#39;occupazione della banda
          dedicata al traffico Internet.</p>
        </div>

        <div class="SECT2">
          <hr />

          <h3 class="SECT2"><a name="SUBSEC-NUMERO-UTENTI" id=
          "SUBSEC-NUMERO-UTENTI"></a>3.4.2. numero degli utenti</h3>

          <p>In linea di massima, maggiore sar&agrave; il numero degli
          utenti che accedono all&#39;apparato di webcache, superiore
          sar&agrave; il risparmio di banda internet. Un corretto
          dimensionamento di Squid dipende anche da altri fattori come la
          disponibilit&agrave; di una quantit&agrave; ottimale di memoria
          RAM, la possibilit&agrave; di disporre di un cache storage di
          grandi dimensioni, l&#39;utilizzo di un filesystem appropriato e
          un corretto sistema operativo di classe UNIX&reg; possono fare la
          differenza.</p>
        </div>

        <div class="SECT2">
          <hr />

          <h3 class="SECT2"><a name="SUBSEC-TIPOLOGIA-UTENTI" id=
          "SUBSEC-TIPOLOGIA-UTENTI"></a>3.4.3. tipologia degli utenti</h3>

          <p>Se vi sono gruppi di utenti dagli interessi diversi si
          visiteranno un numero sempre pi&ugrave; alto di siti web con la
          contestuale memorizzazione della pagine nella cache
          dell&#39;apparato. In questo caso, il risparmio di banda sara
          minore, perch&egrave; la probabilit&agrave; che le stesse pagine
          web visitate vengano richieste nuovamente si riducono. Se vi sono
          molti grandi utenti, meglio conosciuti come &quot;power
          users&quot;, che visitano sempre gli stessi siti internet e che
          quindi hanno abitudini di browsing simili, &egrave; decisamente
          possibile aumentare il risparmio di banda. Se una squadra di
          tecnici addetta alla manutenzione dei sistemi decide di
          aggiornare il browser web utilizzato dagli utenti,
          provveder&agrave; ad effettuare il download del programma. Il
          file rimarr&agrave; memorizzato nella memoria cache della device
          eliminando totalmente le successive richieste di banda.</p>
        </div>

        <div class="SECT2">
          <hr />

          <h3 class="SECT2"><a name="SUBSEC-TIPO-WEBCACHE" id=
          "SUBSEC-TIPO-WEBCACHE"></a>3.4.4. tipo di webcache
          utilizzata</h3>

          <p>Il tipo di dimensionamento dello spazio dedicato al Cache
          Storage pu&ograve; avere un impatto consistente
          sull&#39;ammontare della banda che &egrave; possibile
          risparmiare. Maggiore sar&agrave; la dimensione della cache e
          superiore sar&agrave; il numero degli oggetti che verranno
          salvati nella memoria tampone. Sar&agrave; determinante anche la
          velocit&agrave; di accesso dell&#39;apparato di memorizzazione:
          un sistema di disk storage efficente ed un disco rigido di
          dimensioni contenute che presenti delle performance molto elevate
          consentiranno di ottenere un incremento delle performance.</p>
        </div>

        <div class="SECT2">
          <hr />

          <h3 class="SECT2"><a name="SUBSEC-TIPOLOGIA-RETE" id=
          "SUBSEC-TIPOLOGIA-RETE"></a>3.4.5. tipologia della rete</h3>

          <p>All&#39;interno di una rete corporate composta unicamente di
          &quot;power users&quot; la webcache pu&ograve; essere un sistema
          eccezionale per la riduzione della banda. In altri casi, come ad
          esempio un Internet Service Provider (ISP) o un Application
          Service Provider (ASP) il taglio di banda sar&agrave; decisamente
          inferiore.</p>
        </div>
      </div>

      <div class="SECT1">
        <hr />

        <h2 class="SECT1"><a name="SEC-CONTROLLO-E-SICUREZZA" id=
        "SEC-CONTROLLO-E-SICUREZZA"></a>3.5. Controllo e sicurezza</h2>

        <p>Vedremo in seguito come un&#39;apparato di webcache sia in grado
        di migliorare la sicurezza della rete. Nell&#39;ambito di una
        organizzazione commerciale circa il 40% degli utenti visitano dei
        siti internet che non hanno nulla a che vedere con
        l&#39;attivit&agrave; &quot;core business&quot;
        dell&#39;organizzazione stessa.</p>

        <p>L&#39;utilizzo di uno strumento come Squid quale device di
        webcache consente di pianificare e stabilire delle regole che
        potrebbero rappresentare la politica di utilizzo delle risorse
        internet. Nell&#39;ambito delle <em>normative vigenti</em> in
        materia di data privacy Squid consente di sorvegliare il rispetto
        delle regole predefinite ed i log del proxy server possono anche
        essere utilizzati per creare dei report sugli accessi; inoltre
        consentir&agrave; agli amministratori di rete di mettere in pratica
        la politica di sicurezza filtrando i siti secondo i criteri
        impostati all&#39;interno della policy stessa.</p>

        <p>Nel segmento di rete che si trova all&#39;interno
        dell&#39;organizzazione &egrave; possibile collegare l&#39;apparato
        di webcache con il database aziendale che assolve ai servizi di
        directory (il database che si occupa di eseguire
        l&#39;autenticazione e l&#39;autorizzazione degli utenti). In
        questo caso Squid controller&agrave; le corrette autorizzazioni
        relativamente all&#39;accesso utilizzando diversi schemi di
        <a href="#CHA-AUTENTICAZIONE-UTENTI">autenticazione</a> come
        vedremo dettagliatamente in seguito.</p>

        <p>Squid come apparato di webcache pu&ograve; dunque incorporare un
        database di siti internet accessibili o vietati e tale sistema
        pu&ograve; contenere delle <em>keyworld</em> in grado di
        identificare i siti da rendere irraggiungibili (ad es. siti
        pornografici, video giochi, internet radio ecc....).</p>

        <p>In definitiva un sistema di webcache si occupa di gestire la
        &quot;policy&quot; internet, le politiche di accesso per classi di
        indirizzi IP o di singoli indirizzi e, per finire, pu&ograve;
        eseguire delle limitazioni per i gruppi di utenti che accedono al
        sistema.</p>
      </div>

      <div class="SECT1">
        <hr />

        <h2 class="SECT1"><a name="SEC-UNA-PICCOLA-PANORAMICA-SU-HTTP" id=
        "SEC-UNA-PICCOLA-PANORAMICA-SU-HTTP"></a>3.6. Una piccola
        panoramica su <em>HTTP</em></h2>

        <p><em>HTTP</em> &egrave; l&#39;acronimo di <em>Hypertext Transfer
        Protocol</em> (HTTP - RFC 2616 - <a href=
        "http://www.w3.org/Protocols/rfc2616/rfc2616.txt" target=
        "_top">http://www.w3.org/Protocols/rfc2616/rfc2616.txt</a>) e si
        tratta di un metodo standard per l&#39;invio dei documenti
        attraverso la rete web. In particolare possiamo definire
        <em>HTTP</em> come un protocollo di livello sette che viene
        utilizzato per trasferire gli ipertesti tra gli <em>HTTP</em>
        server (Apache, Internet Information Server, etc) e gli
        <em>HTTP</em> Client (Mozilla, Opera, Konqueror, Internet
        Explorer....). <em>HTTP</em> ricorre al protocollo TCP per
        trasportare i pacchetti sulla rete, stabilendo dunque una
        connessione TCP tra il client ed il server. Gli <em>HTTP</em>
        server sono anche conosciuti come server web e normalmente restano
        in attesa di richieste sulla porta 80. Gli <em>HTTP</em> client
        prendono il nome di browser web e per trasferire le informazioni
        dal server utilizzano una richiesta conforme al protocollo
        <em>HTTP</em> 1.1 oppure ricorrono ad una richiesta conforme con la
        vecchia implementazione <em>HTTP</em> 1.0.</p>
      </div>

      <div class="SECT1">
        <hr />

        <h2 class="SECT1"><a name="SEC-PICCOLA-PANORAMICA-SU-WWWCACHE" id=
        "SEC-PICCOLA-PANORAMICA-SU-WWWCACHE"></a>3.7. Una piccola
        panoramica su <em>WWWCACHE</em></h2>

        <p>Il <em>world wide web cache</em> viene implementato dai proxy
        server. Come abbiamo visto anche in precedenza, normalmente i
        browser web effettuano una connessione diretta al server
        <em>HTTP</em> contattandone la porta 80, ma possono anche essere
        configurati per raggiungere direttamente ai proxy server: in tal
        caso &egrave; specificatamente quest&#39;ultimo che inoltra le
        richieste al server web, frapponendosi e mediando la connessione.
        La memoria cache del Proxy si occupa di salvare sul disco le pagine
        web che sono state maggiormente richieste, rendendone cos&igrave;
        la consultazione veloce ed immediata. Come abbiamo visto uno dei
        benefici indotti dall&#39;utilizzo dei proxy server &egrave; quello
        di ridurre il traffico, nelle WAN di grandi dimensioni ed in
        presenza di pagine statiche, una cache web pu&ograve; ridurre il
        traffico <em>HTTP</em> anche del 30% - 40%.</p>
      </div>

      <div class="SECT1">
        <hr />

        <h2 class="SECT1"><a name="SEC-COSA-SONO-LE-CACHE-GERARCHICHE" id=
        "SEC-COSA-SONO-LE-CACHE-GERARCHICHE"></a>3.8. Cosa sono le cache
        gerarchiche</h2>

        <p>Le cache gerarchiche sono un&#39;estensione logica del concetto
        di cache. Un gruppo di web proxy server pu&ograve; trarre beneficio
        dalla condivisione della propria cache allo stesso modo di un
        gruppo di client web. Tuttavia, oltre ai vantaggi, &eacute;
        possibile identificare anche possibili aspetti negativi determinati
        da situazioni specifiche.</p>

        <ul>
          <li>
            <p>I principali <em>vantaggi</em> sono</p>

            <ul>
              <li>
                <p>un maggior numero di <em>cache hits</em>: in generale,
                ci si pu&ograve; aspettare che almeno il 10% delle
                richieste ricevute da una cache si traducano in <em>cache
                hit</em> (risposte positive) in quelle adiacenti</p>
              </li>

              <li>
                <p>routing delle richieste: eseguendo un routing verso una
                certa cache adiacente, &eacute; possibile instradare il
                traffico <em>HTTP</em> su un determinato percorso. Per
                esempio, avendo due link di connessione con la rete
                internet, &eacute; possibile instradare il traffico
                <em>HTTP</em> su uno dei due, lasciando il secondo
                collegamento a disposizione per tutti gli altri
                utilizzi</p>
              </li>
            </ul>
          </li>

          <li>
            <p>Alcuni possibili <em>svantaggi</em> possono essere</p>

            <ul>
              <li>
                <p>maggiore complessit&agrave; della configurazione: per
                ogni singola relazione di &quot;parentela&quot; &eacute;
                necessario coordinare gli interventi di configurazione di
                entrambi i nodi coinvolti ed al crescere del numero delle
                cache componenti la gerarchia, l&#39;attivit&agrave; di
                configurazione tende a divenire pi&ugrave; impegnativa</p>
              </li>

              <li>
                <p>maggiore ritardo nella risoluzione di un <em>cache
                miss</em> (risposta negativa): il fatto che l&#39;utilizzo
                od il mancato utilizzo di una cache adiacente si traduca in
                un aumento della velocit&agrave; percepita dall&#39;utente
                finale pu&ograve; dipendere da svariati fattori: il ritardo
                tra i nodi, la congestione dei link, l&#39;utilizzo o il
                mancato utilizzo di protocolli di comunicazione intercache
                ed altro ancora</p>
              </li>
            </ul>
          </li>
        </ul>

        <p>Squid offre supporto per le seguenti architetture di cache
        gerarchiche</p>

        <ul>
          <li>
            <p><a href="#SEC-INTERNET-CACHE-PROTOCOL">Internet Cache
            Protocol (ICP)</a></p>
          </li>

          <li>
            <p><a href="#SEC-CACHE-ARRAY-ROUTING-PROTOCOL">Cache Array
            Routing Protocol (CARP)</a></p>
          </li>

          <li>
            <p><a href="#SEC-HTCP">Hyper Text Caching Protocol
            (HTCP)</a></p>
          </li>

          <li>
            <p><a href="#SEC-CACHE-DIGEST">Cache Digest</a></p>
          </li>
        </ul>

        <div class="SECT2">
          <hr />

          <h3 class="SECT2"><a name="SEC-INTERNET-CACHE-PROTOCOL" id=
          "SEC-INTERNET-CACHE-PROTOCOL"></a>3.8.1. Internet Cache Protocol
          (<em>ICP</em>)</h3>

          <p>L&#39;Internet Cache Protocol &egrave; stato sviluppato come
          parte fondamentale del progetto Harvest. Il protocollo ICP
          fornisce un metodo efficiente e veloce di comunicazione
          intercache e si tratta di un meccanismo che instaura una
          complessa gerarchia di cache. Il protocollo ICP viene
          pricipalmente utilizzato all&#39;interno di gerarchie per
          localizzare uno specifico oggetto nelle cache di livello
          superiore.</p>

          <ul>
            <li>
              <p><em>OBJECT (oggetto)</em>: il temine definisce un valore
              generico con il quale si identifica qualsiasi documento o
              altro tipo di dato disponibile via web, le URL (Uniform
              Resource Locator) solitamente identificano gli oggetti</p>
            </li>

            <li>
              <p><em>HIT</em>: il temine cache hit definisce una copia
              valida di un oggetto</p>
            </li>

            <li>
              <p><em>MISS</em>: una cache miss identifica un oggetto che
              non esiste pi&ugrave; in una cache o che ha perso
              validit&agrave;</p>
            </li>
          </ul>

          <p>Se una cache Squid non contiene un documento richiesto, invia
          una richiesta ICP alle cache partner, le quali inviano una
          risposta ICP indicante un <em>HIT</em> o un <em>MISS</em>; quindi
          vengono analizzate le risposte ricevute per scegliere quale cache
          parent utilizzare per risolvere il proprio <em>MISS</em>. I
          termini <em>neighbours</em> e <em>peer</em> sono dei sinonimi e
          si riferiscono a dei sistemi di webcache in relazione tra
          loro.</p>

          <p>ICP supporta inoltre la trasmissione di tipo
          <em>multiplexed</em> di stream di oggetti multipli su una singola
          connessione TCP. Attualmente ICP &eacute; implementato su
          trasporto di tipo UDP, le versioni correnti di Squid supportano
          anche ICP via multicast.</p>

          <ul>
            <li>
              <p>RFC 2186 (<a href="http://icp.ircache.net/rfc2186.txt"
              target="_top">http://icp.ircache.net/rfc2186.txt</a>)
              specifiche del protocollo ICPv2</p>
            </li>

            <li>
              <p>RFC 2187 (<a href="http://icp.ircache.net/rfc2187.txt"
              target="_top">http://icp.ircache.net/rfc2187.txt</a>)
              specifiche applicative del protocollo ICPv2</p>
            </li>

            <li>
              <p>ICP (<a href=
              "http://www.ircache.net/~wessels/Papers/icp-squid.ps.gz"
              target=
              "_top">http://www.ircache.net/~wessels/Papers/icp-squid.ps.gz</a>)
              con Squid web cache</p>
            </li>
          </ul>

          <p>Le implementazioni applicative o i sistemi di webcache che
          utilizzano ICP oltre a Squid attualmente sono:</p>

          <ul>
            <li>
              <p>Network Appliance (<a href=
              "http://www.netapp.com/products/netcache/" target=
              "_top">http://www.netapp.com/products/netcache/</a>)</p>
            </li>

            <li>
              <p>Cisco Cache Engine (<a href=
              "http://www.cisco.com/go/cache/" target=
              "_top">http://www.cisco.com/go/cache/</a>)</p>
            </li>

            <li>
              <p>Volera (<a href="http://www.volera.com/" target=
              "_top">http://www.volera.com/</a>)</p>
            </li>

            <li>
              <p>BlueCoat (<a href="http://www.bluecoat.com/" target=
              "_top">http://www.bluecoat.com/</a>)</p>
            </li>

            <li>
              <p>iMimic DataReactor (<a href="http://www.imimic.com/"
              target="_top">http://www.imimic.com/</a>)</p>
            </li>
          </ul>
        </div>

        <div class="SECT2">
          <hr />

          <h3 class="SECT2"><a name="SEC-CACHE-ARRAY-ROUTING-PROTOCOL" id=
          "SEC-CACHE-ARRAY-ROUTING-PROTOCOL"></a>3.8.2. Cache Array Routing
          Protocol (<em>CARP</em>)</h3>

          <p>Il Cache Array Routing Protocol &egrave; stato sviluppato da
          Microsoft come parte fondamentale dei propri prodotti Proxy
          Server. Le regole del protocollo CARP forniscono un metodo veloce
          ed efficiente per creare un&#39;insieme di WEB cache (array),
          gestirne la relativa comunicazione e stabilire un meccanismo
          complesso di gerarchie di tipo fault tolerant e load
          balanced.</p>

          <ul>
            <li>
              <p>CARP 1.0 Internet-Draft (<a href=
              "http://icp.ircache.net/carp.txt" target=
              "_top">http://icp.ircache.net/carp.txt</a>)</p>
            </li>

            <li>
              <p>Carp white paper (<a href=
              "http://www.microsoft.com/TechNet/Proxy/technote/prxcarp.asp"
              target=
              "_top">http://www.microsoft.com/TechNet/Proxy/technote/prxcarp.asp</a>)</p>
            </li>
          </ul>

          <p><em>Squid</em> utilizza il protocollo CARP solamente come
          client per selezionare uno dei membri dell&#39;array di livello
          gerarchico superiore, non &eacute; in grado di partecipare
          attivamente a tale array, le implementazioni applicative o i
          sistemi di webcache che utilizzano CARP attualmente sono</p>

          <ul>
            <li>
              <p>Microsoft Proxy &amp; ISA Server (<a href=
              "http://www.microsoft.com/isaserver/" target=
              "_top">http://www.microsoft.com/isaserver/</a>)</p>
            </li>
          </ul>
        </div>

        <div class="SECT2">
          <hr />

          <h3 class="SECT2"><a name="SEC-HTCP" id="SEC-HTCP"></a>3.8.3.
          Hyper Text Caching Protocol (<em>HTCP</em>)</h3>

          <p>Si tratta di un protocollo sperimentale che consente di
          eseguire la ricerca delle cache HTTP e dei dati in esse contenute
          ed &egrave; in grado di eseguire il controllo e il monitoraggio
          della attivit&agrave; delle wabcache. E&#39; regolamentato dalla
          RFC 2756 (<a href=
          "http://www.networksorcery.com/enp/rfc/rfc2756.txt" target=
          "_top">http://www.networksorcery.com/enp/rfc/rfc2756.txt</a>).</p>
        </div>

        <div class="SECT2">
          <hr />

          <h3 class="SECT2"><a name="SEC-CACHE-DIGEST" id=
          "SEC-CACHE-DIGEST"></a>3.8.4. Cache Digest</h3>

          <p>Cache Digest &egrave; un nuovo protocollo che tratta di una
          tecnica di ottimizzazione per il Web caching cooperativo.
          Autorizza i proxies componenti una gerarchia collegata a generare
          delle informazioni relativamente al contenuto della propria
          cache. Una web cache componente dello stesso peer &egrave;
          cos&igrave; in grado di identificare al meglio quale delle web
          cache gemelle pu&ograve; fornirgli pi&ugrave; velocemente i
          documenti richiesti.</p>
        </div>
      </div>

      <div class="SECT1">
        <hr />

        <h2 class="SECT1"><a name="SEC-INTRO-SQUID-CONCLUSIONI" id=
        "SEC-INTRO-SQUID-CONCLUSIONI"></a>3.9. Concludendo</h2>

        <p>Squid HTTP Proxy &egrave; il pi&ugrave; conosciuto nonch&egrave;
        il pi&ugrave; utilizzato dei Web Proxy Server che fornisce
        funzionalit&agrave; di caching e proxing per il traffico
        <em>HTTP</em>, <em>FTP</em> e <em>Gopher</em>. Fornisce inoltre un
        framework per il webcaching, per il controllo degli accessi e per
        il controllo dei contenuti. Squid pu&ograve; anche essere
        utilizzato come motore HTTP/HTTPs per eseguire avanzate tecniche di
        reverse proxy. Il motore della sua webcache &egrave; stato anche
        disegnato per supportare le connessioni di tipo SSL/TLS (Secure
        Soket Layer<em>/</em>Transport Layer Security). Squid controlla
        completamente gli accessi grazie alle sue potenzialit&agrave; di
        logging delle connessioni, inoltre supporta il concetto di caching
        cooperativo implementando protocolli come <em>ICP</em>,
        <em>HTCP</em> e <em>Cache Digest</em>. Per finire il sistema di
        cache storage, o memoria cache di Squid, viene sistemato
        gerarchicamente ed esistono diversi strumenti che consentono di
        interpretare anche visivamente i log delle transazioni.</p>

        <p>A livello applicativo Squid &egrave; composto da un proxy server
        vero e proprio e da diversi programmi esterni. Nelle prime versioni
        uno dei programmi esterni che veniva maggiormente utilizzato era
        l&#39;applicazione che effettuava la risoluzione dei nomi, ovvero
        assolveva il compito di tradurre il nome internet nel corrispettivo
        indirizzo IP. Nel contesto attuale uno dei programmi esterni
        pi&ugrave; diffusi &egrave; quello che consente di eseguire
        l&#39;autenticazione degli utenti. A partire dalla release 2.3, la
        risoluzione dei nomi viene demandata direttamente al server DNS
        presente sulla LAN/WAN (<em>ISC Bind</em>) o, in alternativa, al
        server DNS di propriet&agrave; dell&#39;Internet Service Provider.
        Oggi Squid risolve i nomi di dominio utilizzando lo standard di
        tutti i Sistemi UNIX&reg;, riferendosi direttamente ai server DNS
        che sono stati specificati nel file <em>/etc/resolv.conf</em>.</p>
      </div>
    </div>

    <div class="CHAPTER">
      <hr />

      <h1><a name="CHA-OS-CHE-SUPPORTANO-SQUID" id=
      "CHA-OS-CHE-SUPPORTANO-SQUID"></a>Capitolo 4. I sistemi operativi che
      supportano Squid</h1>

      <div class="SECT1">
        <h2 class="SECT1"><a name="SEC-PREAMBOLO-KIND-OS" id=
        "SEC-PREAMBOLO-KIND-OS"></a>4.1. Preambolo</h2>

        <p>Squid &egrave; stato disegnato per funzionare con qualsiasi
        moderno sistema UNIX&reg;, di seguito elenchiamo tutti i sistemi
        operativi con i quali &egrave; oggi possibile utilizzare Squid
        proxy server</p>

        <ul>
          <li>
            <p>Linux</p>
          </li>

          <li>
            <p>FreeBSD</p>
          </li>

          <li>
            <p>NetBSD</p>
          </li>

          <li>
            <p>OpenBSD</p>
          </li>

          <li>
            <p>BSDI</p>
          </li>

          <li>
            <p>OSF and Digital Unix&reg;</p>
          </li>

          <li>
            <p>IRIX</p>
          </li>

          <li>
            <p>SunOS Solaris</p>
          </li>

          <li>
            <p>NeXTStep</p>
          </li>

          <li>
            <p>SCO Unix</p>
          </li>

          <li>
            <p>AIX</p>
          </li>

          <li>
            <p>HP-UX</p>
          </li>

          <li>
            <p>OS/2</p>
          </li>

          <li>
            <p>Windows NT</p>
          </li>

          <li>
            <p>Windows 2000</p>
          </li>

          <li>
            <p>Windows 2003 &amp; XP</p>
          </li>
        </ul>

        <p>i problemi che possono essere ricondotti a specifiche
        piattaforme vanno segnalati a <a href=
        "mailto:squid-bugs@squid-cache.org" target=
        "_top">squid-bugs@squid-cache.org</a></p>
      </div>

      <div class="SECT1">
        <hr />

        <h2 class="SECT1"><a name="SEC-PIATTAFORME-SPEC" id=
        "SEC-PIATTAFORME-SPEC"></a>4.2. Piattaforme specifiche</h2>

        <p>In questo capitolo &egrave; nostra intenzione trattare alcune
        delle piattaforme e dei Sistemi Operativi sui quali viene oggi
        sviluppato Squid. <em>OS/2</em> &egrave; la piattaforma sulla quale
        si &egrave; sviluppato inizialmente questo documento, <em>GNU
        Linux</em> e <em>FreeBSD</em> sono le piattaforme UNIX&reg; per
        eccellenza mentre la piattaforma <em>Windows</em> rappresenta un
        nuovo ramo nello sviluppo di Squid Proxy Server. Su questi Sistemi
        Operativi sono stati eseguiti i test e sono anche state provate
        moltissime delle configurazioni che verranno trattate in
        seguito.</p>
      </div>

      <div class="SECT1">
        <hr />

        <h2 class="SECT1"><a name="SEC-PLATFORM-UNIX" id=
        "SEC-PLATFORM-UNIX"></a>4.3. Sistemi UNIX&reg;</h2>

        <p>Come abbiamo detto Squid &egrave; un software studiato per i
        moderni sistemi UNIX&reg; e da diverso tempo <em>Linux</em> e
        <em>FreeBSD</em> si dimostrano tra le piattaforme migliori.</p>

        <div class="SECT2">
          <hr />

          <h3 class="SECT2"><a name="SUBSEC-PLATFORM-LINUX" id=
          "SUBSEC-PLATFORM-LINUX"></a>4.3.1. GNU Linux</h3>

          <p>Le distribuzioni Linux che vengono trattate all&#39;interno di
          questo documento, in relazione alle configurazioni con Squid
          Proxy Server, sono <em>Debian</em> <em>GNU/Linux</em>,
          <em>Slackware</em>, <em>RedHat</em>, <em>Mandrake</em> e
          <em>Fedora Core</em>.</p>
        </div>

        <div class="SECT2">
          <hr />

          <h3 class="SECT2"><a name="SUBSEC-PLATFORM-FREEBSD" id=
          "SUBSEC-PLATFORM-FREEBSD"></a>4.3.2. FreeBSD</h3>

          <p><em>Thomas-Martin Seck</em> &lt;<a href=
          "mailto:tmseck@netcologne.de" target=
          "_top">tmseck(at)netcologne.de</a>&gt; &egrave; l&#39;attuale
          maintainer del ports per <em>FreeBSD</em> (<a href=
          "http://www.freshports.org/www/squid/" target=
          "_top">http://www.freshports.org/www/squid/</a>) e molte delle
          configurazioni trattate in questo documento vengono testate su
          questi sistemi. Nelle ultime versioni del ports &egrave; stato
          anche inserito un semplice ed utile men&ugrave; interattivo che
          consente di selezionare, in maniera visuale, alcune delle opzioni
          di configurazione del software come il supporto <a href=
          "#CHA-CONFIGURARE-SNMP">SNMP</a> (Simple Network Managemet
          Protocol) o le ACL ARP based <a href=
          "#SEC-ACL-BASATE-MACADDRESS">ACL ARP based</a>.</p>
        </div>
      </div>

      <div class="SECT1">
        <hr />

        <h2 class="SECT1"><a name="SEC-PLATFORM-WINDOZE" id=
        "SEC-PLATFORM-WINDOZE"></a>4.4. Sistemi Windows</h2>

        <p>A partire dalla versione 2.5.STABLE1, Squid Proxy Server
        &eacute; anche disponibile per i sistemi <em>Windows</em> e
        pu&ograve; essere compilato con due differenti modalit&agrave;</p>

        <ol type="1">
          <li>
            <p>modalit&agrave; <em>nativa</em></p>
          </li>

          <li>
            <p>modalit&agrave; <em>emulata</em></p>
          </li>
        </ol>

        <p>La modalit&agrave; <em>emulata</em> si caratterizza con un
        livello di prestazioni inferiori, mentre la modalit&agrave;
        <em>nativa</em> pu&ograve; non supportare alcune
        funzionalit&agrave; che sono disponibili per altri Sistemi
        Operativi. In modalit&agrave; <em>nativa</em>, Squid pu&ograve;
        essere compilato utilizzando l&#39;ambiente di sviluppo Open Source
        <a href="http://www.mingw.org/" target="_top">MinGW</a> o
        l&#39;ambiente di sviluppo proprietario Microsoft Visual Studio 6.0
        SP5, in modalit&agrave; <em>emulata</em> viene compilato
        utilizzando l&#39;ambiente Open Source <a href=
        "http://www.cygwin.com/" target="_top">Cygwin</a>, purch&egrave;
        sia stato correttamente installato e configurato anche sul sistema
        sul quale si intende eseguire Squid. Le configurazioni trattate da
        questo libro si applicano per entrambi gli ambienti e sono state
        solitamente implementate su macchine Windows 2000 e testate da
        <a href="mailto:guido.serassio@acmeconsulting.it" target=
        "_top">Guido Serassio</a>.</p>

        <p>Il progetto di porting di Squid su Windows &egrave;
        sponsorizzato da <a href="http://www.acmeconsulting.it" target=
        "_top">Acmeconsulting S.r.l.</a> e viene seguito in prima persona
        da Guido Serassio. Gli eseguibili per le piattaforme Win32 e tutte
        le informazioni sullo stato di avanzamento del progetto possono
        essere reperite alla URL <a href=
        "http://www.acmeconsulting.it/SquidNT/" target=
        "_top">http://www.acmeconsulting.it/SquidNT/</a>.</p>
      </div>

      <div class="SECT1">
        <hr />

        <h2 class="SECT1"><a name="SEC-PLATFORM-OS2" id=
        "SEC-PLATFORM-OS2"></a>4.5. Sistemi OS/2</h2>

        <p>Il porting di Squid per <em>OS/2</em> viene effettuato tramite
        alcune librerie di runtime denominate <a href=
        "http://homepages.tu-darmstadt.de/~st002279/os2/html/porting.html"
        target="_top">EMX</a> (The UN*X to OS/2-EMX Porting), l&#39;autore
        del porting &egrave; Peter Meerwald &lt;<a href=
        "mailto:seawood@very.priv.at" target=
        "_top">seawood(at)very.priv.at</a>&gt; e non &egrave; previsto
        alcun supporto commerciale. Attualmente &egrave; in fase di
        sviluppo il progetto &quot;Squid Cache Version 2.5.OS2_VAC&quot;,
        si tratta del port di Squid-2.5 sviluppato in maniera
        <em>nativa</em> utilizzando lo strumento VACPP. Maggiori
        informazioni sul progetto sono disponibili alla URLs <a href=
        "http://www.laser.ru/evgen/soft/Squid2/index_l.html" target=
        "_top">http://www.laser.ru/evgen/soft/Squid2/index_l.html</a>.</p>
      </div>
    </div>

    <div class="CHAPTER">
      <hr />

      <h1><a name="CHA-DIFFERENZE-TRA-24-E-25" id=
      "CHA-DIFFERENZE-TRA-24-E-25"></a>Capitolo 5. Differenze tra Squid 2.4
      e Squid 2.5</h1>

      <div class="SECT1">
        <h2 class="SECT1"><a name="SEC-PREAMBOLO-SQUID-DIFF24-25" id=
        "SEC-PREAMBOLO-SQUID-DIFF24-25"></a>5.1. Preambolo</h2>

        <p>Nel 1998 &egrave; stata sviluppata la versione 2 di Squid ed in
        questa <em>release</em> sono state introdotte moltissime migliorie
        progettuali che gli hanno poi consentito di affermarsi come una
        delle migliori applicazioni nel suo segmento di mercato.</p>

        <p>Tra le varie novit&agrave; possiamo citare</p>

        <ul>
          <li>
            <p>un basso utilizzo della VM (Virtual Machine)</p>
          </li>

          <li>
            <p>gli oggetti in transito non vengono salvati nella memoria
            RAM</p>
          </li>

          <li>
            <p>le directory dedicate al cache storage possono anche essere
            indipendenti</p>
          </li>

          <li>
            <p>i messaggi di errore possono essere modificati sulla base
            delle nostre esigenze</p>
          </li>

          <li>
            <p>il sistema FTP &egrave; stato integrato come processo
            interno di Squid</p>
          </li>

          <li>
            <p>&egrave; stato inserito il supporto opzionale per la
            scrittura asincrona delle operazioni del disk I/O</p>
          </li>

          <li>
            <p>le icone per il supporto FTP e GOPHER sono un processo
            interno</p>
          </li>

          <li>
            <p>&egrave; stato inserito supporto SNMP (Simple Network
            Management Protocol) per consentire un miglior controllo sulle
            operazioni svolte da Squid</p>
          </li>

          <li>
            <p>le richieste di routing vengono basate su un numero AS</p>
          </li>

          <li>
            <p>&egrave; stato inserito il supporto per il Cache Digest</p>
          </li>
        </ul>

        <p>in questo capitolo &egrave; nostra intenzione analizzare le
        differenze, che sono anche sostanziali, tra la versione 2.5 di
        Squid e le precedenti releases. Comprendere le differenze
        aiuter&agrave; il lettore a valutare al meglio l&#39;evoluzione di
        Squid Proxy Server nel corso del tempo, ma prima di addentrarci nei
        dettagli analizzeremo i punti cardine che caratterizzano la
        versione 2.5</p>

        <ul>
          <li>
            <p>completa riprogettazione e riscrittura di tutto il supporto
            d&#39;autenticazione dell&#39;accesso alla cache e
            dell&#39;algoritmo di ricerca e visita all&#39;interno delle
            ACL</p>
          </li>

          <li>
            <p>supporto per la traduzione e l&#39;instradamento di
            connessioni SSL (<em>Secure Socket Layer</em>)</p>
          </li>

          <li>
            <p>supporto delle richieste a link Satellitari</p>
          </li>

          <li>
            <p>varie altre migliorie per aumentare le performance</p>
          </li>
        </ul>
      </div>

      <div class="SECT1">
        <hr />

        <h2 class="SECT1"><a name="SEC-AUTENTICAZIONE" id=
        "SEC-AUTENTICAZIONE"></a>5.2. Autenticazione</h2>

        <p>Nella versione 2.5 di Squid la struttura del sistema di
        autenticazione &egrave; stata riprogettata per facilitare
        l&#39;inserimento di nuovi <em>schemi di autenticazione</em></p>

        <ul>
          <li>
            <p>digest</p>
          </li>

          <li>
            <p>NTLM</p>
          </li>

          <li>
            <p>basic</p>
          </li>
        </ul>

        <p>Come vedremo pi&ugrave; avanti nelle configurazioni specifiche,
        lo schema di autenticazione <em>basic</em> si occuper&agrave; di
        gestire il sistema di autenticazione cos&igrave; come avveniva
        nelle precedenti versioni di Squid. Per essere precisi, secondo la
        RFC 2617 (<a href="http://www.ietf.org/rfc/rfc2617.txt" target=
        "_top">http://www.ietf.org/rfc/rfc2617.txt</a>), questa tipologia
        di autenticazione identifica una procedura con la quale le
        credenziali vengono inviate sulla rete in &quot;chiaro&quot; per
        ogni sessione.</p>

        <p>Ricordiamo per&ograve; che questa funzionalit&agrave; viene
        usata in congiunzione con gli helpers, che nel nostro caso possono
        sfruttare le pi&ugrave; disparate caratteristiche come
        <em>PAM</em>, <em>NCSA</em>, <em>LDAP</em> ecc.</p>

        <p>Lo schema <em>digest</em> a sua volta ci fornir&agrave; una
        struttura d&#39;autenticazione basata su parole chiave in
        modalit&agrave; <em>digest</em> (fare sempre riferimento alla RFC
        2617 - <a href="http://www.ietf.org/rfc/rfc2617.txt" target=
        "_top">http://www.ietf.org/rfc/rfc2617.txt</a>). L&#39;invio delle
        credenziali nel formato <em>CheckSum</em> ci permetter&agrave; di
        verificare la veridicit&agrave; delle credenziali stesse. Con
        questa modalit&agrave; di autenticazione le password transitano
        sulla rete in formato crittato.</p>

        <p>L&#39;<em>NTLM</em> ci permetter&agrave; l&#39;integrazione con
        il sistema di autenticazione nativo di Microsoft Windows
        (<em>Protocollo NTLMv1, NTLMv2</em>) che pu&ograve; avvenire con
        modalit&agrave; diverse a secondo del tipo di <em>helpers</em> che
        verr&agrave; utilizzato. Nei capitoli seguenti analizzeremo tutte
        le possibili configurazioni. Ricordiamo per completezza che lo
        schema di autenticazione <em>NTLM</em> rispetta uno standard di
        validazione proprietario della <em>Microsoft</em> e pu&ograve;
        quindi funzionare automaticamente soltanto utilizzando il browser
        Internet Explorer (almeno sino alla data odierna).</p>

        <p>A riguardo delle tre modalit&agrave; di autenticazione, vale la
        pena citare anche un&#39;altra metodologia denominata
        <em>External</em>. Tale sistema consente di integrare tutti i
        validatori non direttamente interni a Squid che rispettano le
        caratteristiche di ritorno di un <em>helper</em>. <em>External</em>
        pu&ograve; essere considerato una diretta estensione dello schema
        di funzionamento delle ACL che viene applicato tramite alcuni
        programmi esterni. Con la parola <em>helper</em> identifichiamo
        nello specifico un programma che viene utilizzato da Squid per
        verificare le credenziali di un&#39;utente sulla base dello schema
        di autenticazione che abbiamo deciso di utilizzare
        (<em>digest</em>, <em>NTLM</em> e <em>basic</em>).</p>
      </div>

      <div class="SECT1">
        <hr />

        <h2 class="SECT1"><a name="SEC-SSL-GATEWAYING" id=
        "SEC-SSL-GATEWAYING"></a>5.3. SSL Gatewaying</h2>

        <p>Questa nuova funzionalit&agrave; consente, nelle configurazioni
        di &quot;acceleratore&quot;, di utilizzare Squid come un server SSL
        (<em>Secure Socket Layer</em>) per instradare connessioni
        caratterizzate da tale tecnologia e creare un&#39;amministrazione
        controllata dei certificati del richiedente.</p>
      </div>

      <div class="SECT1">
        <hr />

        <h2 class="SECT1"><a name="SEC-LINK-SATELLITARI" id=
        "SEC-LINK-SATELLITARI"></a>5.4. Link Satellitari</h2>

        <p>Nella nuova versione 2.5 di Squid &egrave; stata migliorata sia
        la modularit&agrave; di configurazione sia la tecnica di richiesta
        delle informazioni nel caso in cui una istanza faccia riferimento
        ad un link satellitare. Non ci dilungheremo ora nella spiegazione
        delle problematiche inerenti le connessioni satellitari, diciamo
        che tali richieste sono caratterizzate da un RTT (<em>Round Trip
        Time</em>) di funzionamento diverso ed da una latenza differente
        rispetto a quanto richiesto da un link terrestre via cavo. Squid si
        pu&ograve; comportare in modo da bilanciare le connessioni tra il
        satellite ed il cavo quando il primo link &egrave; in sovraccarico,
        utilizzando appunto le variabili sopracitate.</p>
      </div>

      <div class="SECT1">
        <hr />

        <h2 class="SECT1"><a name="SEC-24VS25-SQUID.CONF" id=
        "SEC-24VS25-SQUID.CONF"></a>5.5. modifiche al file
        <em>squid.conf</em></h2>

        <p>Il passaggio da Squid-2.4 alla release 2.5 &egrave; stato un
        vero e proprio salto tecnologico che ha determinato alcune
        modifiche alla sintassi del file <em>squid.conf</em> oltre
        all&#39;aggiunta di nuovi TAG. Le modifiche hanno riguardato
        sopratutto la sintassi dei TAG relativi all&#39;autenticazione,
        come abbiamo visto, con Squid-2.5 viene introdotto il concetto
        degli <em>schemi di autenticazione</em>, la versione 2.4 invece
        lavorava esclusivamente con lo schema di autenticazione
        <em>basic</em>. Tra i nuovi TAG citiamo quello relativo
        all&#39;acceleratore SSL (<em>https_port</em>) che consente anche
        la gestione dei certificati digitali, altre modifiche hanno
        riguardato le tipologie delle ACL (<a href=
        "#CHA-CONTROLLI-DI-ACCESSO">Access Control List</a>) e
        l&#39;inserimento dei TAG relativi alla gestione delle <a href=
        "#SEC-EXTERNAL-ACL">external</a> ACL (<em>external_acl_type</em>),
        maggiori dettagli a riguardo possono essere reperiti nelle note di
        release (<a href=
        "http://www.squid-cache.org/Versions/v2/2.5/RELEASENOTES.html"
        target=
        "_top">http://www.squid-cache.org/Versions/v2/2.5/RELEASENOTES.html</a>).</p>

        <p>In linea di massima <em>si sconsiglia</em> sempre al lettore di
        riutilizzare lo stesso file di configurazione. Questa regola
        &egrave; sempre valida quando si intende passare da una major
        release all&#39;altra. Consigliamo sempre di eseguire una copia di
        sicurezza del vecchio file di configurazione, riportando gli stessi
        TAG nel nuovo file che comunque contiene i commenti a tutte le
        nuove features offerte dalla nuova major release. A tale riguardo
        possono aiutarci i comandi UNIX&reg; <em>more</em>(8) e
        <em>tail</em>(8), maggiori dettagli ed esempi sulla migrazione
        verranno trattati in <a href=
        "#SEC-AVVIARE-VERSIONE-COMPILATA-RH">seguito</a>.</p>
      </div>

      <div class="SECT1">
        <hr />

        <h2 class="SECT1"><a name="SEC-ALCUNE-CONSIDERAZIONI" id=
        "SEC-ALCUNE-CONSIDERAZIONI"></a>5.6. Considerazioni</h2>

        <p>La versione 2.5 di Squid probabilmente pu&ograve; essere
        considerata come una <em>release di transizione</em>,
        l&#39;elemento che la contraddistingue fortemente &egrave;
        l&#39;inserimento degli schemi di autenticazione ed in particolare
        dell&#39;integrazione con i domini Windows NT o con le Active
        Directory di Windows 2000 Server. Questa nuova features &egrave;
        intrinsecamente legata allo sviluppo di Samba (<a href=
        "http://www.samba.org/" target="_top">http://www.samba.org/</a>),
        il team di sviluppo di Squid ha lavorato intensamente con il team
        di sviluppo di Samba per integrare al meglio questo <em>schema di
        autenticazione</em>. Samba &egrave; una applicazione
        fondamentalmente basata sul processo di <em>reverse
        engineering</em> del protocollo SMB adottato dai sistemi
        <em>Microsoft</em> per la condivisione di files e stampanti.</p>

        <p>La dipendenza tra Squid e Samba, se da una parte svincola gli
        amministratori di sistema dalle briglie dei protocolli proprietari,
        dall&#39;altra introduce lo stato di transizione. A partire dalla
        release 2.5.STABLE5 &egrave; stata decisamente migliorata
        l&#39;integrazione ed il funzionamento dello schema di
        autenticazione <em>NTLM</em> sia per queanto concerne
        l&#39;<em>helper</em> nativo <em><a href=
        "#SUBSEC-NTLM-AUTH">ntlm_auth</a></em> che per
        l&#39;<em>helper</em> esterno basato su Samba. Ora gli
        amministratori di sistema possono finalmente utilizzare senza
        problemi sia il protocollo NTLMv1 che NTLMv2.</p>

        <p>Utile, indicato e necessario &egrave; il supporto per
        l&#39;accelerazione <a href="#CHA-REVERSE-PROXY">HTTPs</a> con la
        relativa gestione dei certificati digitali. In questo caso si
        tratta di un grande passo in avanti, la soluzione &egrave;
        particolarmente indicata per gli amministratori si sistema che
        hanno la necessit&agrave; di gestire degli apparati di content
        caching particolarmente efficenti e performanti.</p>
      </div>
    </div>

    <div class="CHAPTER">
      <hr />

      <h1><a name="CHA-CASE-OF-STUDY" id="CHA-CASE-OF-STUDY"></a>Capitolo
      6. Casi di studio</h1>

      <div class="SECT1">
        <h2 class="SECT1"><a name="SEC-SISTEMI-IN-TEST" id=
        "SEC-SISTEMI-IN-TEST"></a>6.1. Sistemi in test</h2>

        <p>La configurazione del server sul quale &egrave; stato testato
        originariamente Squid a partire dalla sua versione 2.1 e sino alla
        versione 2.4 era basata sulla seguente configurazione:</p>

        <ul>
          <li>
            <p>motherboard MSI bus 100Mhz chipset ADI Alladin 5, processore
            AMD K6/333 Mhz, 196 Mb di Ram (Dimm 100Mhz).</p>

            <p>Per un lungo periodo &egrave; stato adottato il sistema
            operativo IBM OS/2 Warp 4.0, FixPack 14 con stack TCP/IP v. 4.1
            di diretta derivazione *BSD (a partire dal FixPack 13 il kernel
            del sistema &egrave; IBM OS/2 Warp Server for E-Business). La
            stessa configurazione ha anche lavorato con un sistema Linux
            Red Hat 7.1 (Kernel 2.4.18-27)</p>
          </li>
        </ul>

        <p>attualmente i nuovi test vengono effettuati su Squid 2.5 e
        vengono eseguiti su diverse macchine che sono cos&igrave;
        equipaggiate:</p>

        <ul>
          <li>
            <p>motherboard MSI bus 100Mhz chipset ADI Alladin 5, processore
            AMD K6/333 Mhz, 64 Mb di Ram (Dimm 100Mhz), il sistema
            operativo attuale &egrave; FreeBSD 4.9-STABLE, ufs Disk Store,
            filesystem UFS</p>
          </li>

          <li>
            <p>motherboard Asus P4PE, processore Pentium IV 2 Ghz, 1Gb di
            RAM (Dimm 233Mhz), il sistema operativo attuale &egrave;
            FreeBSD 5.2.1-RELEASE, diskd Disk Store, filesystem UFS2</p>
          </li>

          <li>
            <p>motherboard ECS-K7S5A Pro, processore AMD Athlon XP+ 2400,
            256 Mb di RAM (Dimm 233Mhz), il sistema operativo attuale
            &egrave; FreeBSD 4.9-STABLE, ufs Disk Store, filesystem UFS</p>
          </li>

          <li>
            <p>motherboard P51430PX Titanium, processore AMD K6/3D 300Mhz,
            98 Mb di RAM (Simm), il sistema operativo attuale &egrave;
            FreeBSD 4.9-STABLE, filesystem UFS</p>
          </li>
        </ul>
      </div>

      <div class="SECT1">
        <hr />

        <h2 class="SECT1"><a name="SEC-SISTEMI-IN-PRODUZIONE" id=
        "SEC-SISTEMI-IN-PRODUZIONE"></a>6.2. Sistemi in produzione</h2>

        <p>Di seguito viene fornito anche un&#39;elenco di server che sono
        attualmente in produzione e che eseguono il proxy server Squid in
        realt&agrave; aziendali molto diverse tra loro, verr&agrave;
        specificata anche la versione di Squid in produzione e alcune
        informazioni relative al carico ed alla configurazione.</p>

        <ul>
          <li>
            <p>Server HP Netserver Lp 2000r -PIII 933Mhz - 512MB RAM -
            dischi SCSI RAID1</p>

            <ul>
              <li>
                <p>FreeBSD 4.9-STABLE</p>
              </li>

              <li>
                <p>Squid-2.5.STABLE5</p>
              </li>

              <li>
                <p>200 utenti</p>
              </li>

              <li>
                <p>diskd disk store (filesystem UFS <a name="AEN748" href=
                "#FTN.AEN748" id="AEN748">[1]</a>), autenticazione ntlm in
                AD<a name="AEN751" href="#FTN.AEN751" id=
                "AEN751">[2]</a></p>
              </li>
            </ul>
          </li>

          <li>
            <p>Server Fujitsu-Siemens Primergy L200 - PIII 1,3GHz - 1GB RAM
            - dischi SCSI RAID 5 <a name="AEN755" href="#FTN.AEN755" id=
            "AEN755">[3]</a></p>

            <ul>
              <li>
                <p>FreeBSD 4.9-STABLE</p>
              </li>

              <li>
                <p>Squid-2.5.STABLE5</p>
              </li>

              <li>
                <p>200 utenti</p>
              </li>

              <li>
                <p>diskd disk store (filesystem UFS), autenticazione ntlm
                in AD</p>
              </li>
            </ul>
          </li>

          <li>
            <p>Server Compaq Proliant - PII 450 MHz - 128 MB RAM - disco
            SCSI</p>

            <ul>
              <li>
                <p>FreeBSD 4.9-STABLE</p>
              </li>

              <li>
                <p>Squid-2.5.STABLE5</p>
              </li>

              <li>
                <p>40 utenti</p>
              </li>

              <li>
                <p>ufs disk store (filesystem UFS), autenticazione ntlm in
                AD</p>
              </li>
            </ul>
          </li>

          <li>
            <p>Server IBM x340 e-Server 2xPIII 1.2 Ghz - 1 GB RAM - dischi
            SCSI RAID 5</p>

            <ul>
              <li>
                <p>Linux Slackware Kernel 2.4</p>
              </li>

              <li>
                <p>Squid-2.5STABLE1</p>
              </li>

              <li>
                <p>300 utenti</p>
              </li>

              <li>
                <p>diskd disk store (filesystem RaiserFS), autenticazione
                ntlm in AD</p>
              </li>
            </ul>
          </li>

          <li>
            <p>PC AMD Duron 1,3 GHz - 512 MB RAM - 2 x IDE 40 GB RAID 1 HW
            Promise FastTrack TX100</p>

            <ul>
              <li>
                <p>Debian GNU/Linux 3.0r1 kernel 2.4.20</p>
              </li>

              <li>
                <p>Squid-2.5STABLE3</p>
              </li>

              <li>
                <p>80 utenti</p>
              </li>

              <li>
                <p>aufs disk store <a name="AEN802" href="#FTN.AEN802" id=
                "AEN802">[4]</a> (filesystem Ext3), autenticazione basic
                NCSA</p>
              </li>
            </ul>
          </li>

          <li>
            <p>PC PII 266 MHz - 512 MB RAM - 2 x IDE 30 GB mirror SW</p>

            <ul>
              <li>
                <p>Windows 2000 Server SP4</p>
              </li>

              <li>
                <p>Squid-2.5STABLE4</p>
              </li>

              <li>
                <p>15 utenti</p>
              </li>

              <li>
                <p>awin32 disk store (filesystem NTFS), autenticazione
                basic e NTLM in AD</p>
              </li>
            </ul>
          </li>

          <li>
            <p>PC AMD Athlon XP 1,4 GZ - 256 MB RAM - 1 x IDE 20 GB (SO)
            con 2 x IDE 120 GB</p>

            <ul>
              <li>
                <p>Red Hat Linux 7.3</p>
              </li>

              <li>
                <p>Squid-2.5.STABLE5</p>
              </li>

              <li>
                <p>4 utenti</p>
              </li>

              <li>
                <p>aufs disk store (file system ext3), autenticazione
                BASIC</p>
              </li>
            </ul>
          </li>
        </ul>
      </div>
    </div>

    <div class="CHAPTER">
      <hr />

      <h1><a name="CHA-CONFIGURAZIONE" id="CHA-CONFIGURAZIONE"></a>Capitolo
      7. Configurare ed installare Squid</h1>

      <div class="SECT1">
        <h2 class="SECT1"><a name="SEC-PREAMBOLO-CONFIGURAZIONE" id=
        "SEC-PREAMBOLO-CONFIGURAZIONE"></a>7.1. Preambolo</h2>

        <p>Nel settore informatico, cos&igrave; come accade per moltissime
        altre attivit&agrave; ed altri aspetti della vita quotidiana, si
        tende sempre a generalizzare anche su questioni che nel futuro
        potranno rivelarsi di importanza strategica, purtroppo siamo
        nell&#39;era del profitto e per il denaro saremmo disposti anche ad
        immolare il futuro dei nostri figli.</p>

        <p>Prepararsi per installare un sistema di web cache come Squid,
        comporta una serie di scelte progettuali che devono essere
        effettuate prima di procedere con l&#39;installazione vera e
        propria. I fattori che determineranno questo tipo di scelta vanno
        dalla realt&agrave; nella quale si dovr&agrave; operare, al numero
        degli utenti che si dovranno servire. La scelta del Sistema
        Operativo, la RAM, il tipo di CPU e la modalit&agrave; di
        preparazione dei codici sorgenti di Squid, rappresentano la
        strategia che ci consentir&agrave; di ottenere un ambiente
        performante, stabile ed affidabile. In questo capitolo tratteremo
        molti dei fattori che possono influenzare la scelta del sistema
        migliore, questa decisione determiner&agrave; il successo o il
        fallimento del progetto.</p>

        <p>Tratteremo alcune informazioni di carattere generale
        relativamente al processo di postinstazione di Squid, spiegheremo
        agli utenti quanto sia determinante il corretto utilizzo del file
        di configurazione <em>squid.conf</em>. Infine elencheremo e
        spiegheremo alcuni dei TAG principali contenuti nel file
        <em>squid.conf</em> per consentire i lettori ad utilizzare con
        successo Squid.</p>
      </div>

      <div class="SECT1">
        <hr />

        <h2 class="SECT1"><a name="SEC-SCEGLI-OS" id=
        "SEC-SCEGLI-OS"></a>7.2. Scegliere il Sistema Operativo</h2>

        <p>I pi&ugrave; moderni sistemi a codice libero di classe UNIX&reg;
        forniscono delle prestazioni piuttosto simili e tutti i Sistemi
        Operativi compatibili allo standard POSIX vengono supportati da
        Squid. I Sistemi Operativi che utilizzano il compilatore <em>GNU
        C</em>, le librerie <em>gcc</em> e i Sistemi Operativi
        genericamente compatibili con lo standard <em>ANSI C</em>,
        rappresentano la scelta migliore per utilizzare Squid.</p>

        <p>Ci sono anche molte distribuzioni Linux che includono dei
        package precompilati secondo diversi standard. Fedora Core, Red Hat
        Linux (non pi&ugrave; supportata), Mandrake Linux e SuSe Linux
        forniscono i loro pacchetti <em>RPM</em>, Debian GNU Linux iclude i
        pacchetti <em>deb</em> e per finire i classici pacchetti
        <em>tgz</em> vengono inclusi nella distribuzione Linux
        Slackware.</p>

        <p>Un&#39;ottima scelta pu&ograve; essere rappresentata da un
        Sistema Operativo <em>*BSD</em>, per quello che concerne
        l&#39;esperienza di chi scrive, <em>FreeBSD</em> &egrave; senza
        dubbio una scelta di eccellenza perch&egrave; fornisce la giusta
        miscela di funzionalit&agrave; e standardizzazione. Non
        dimentichiamo che, a livello di performance, <em>FreeBSD</em> si
        posiziona in testa al gruppo dei Sistemi Operativi che abbiamo
        sinora elencato. A livello di compatibilit&agrave; con il codice
        sorgente, il Sistema Operativo che meglio si integra con Squid
        &egrave; <em>GNU Linux</em>. A tale riguardo si consiglia di
        installare con il Sistema Operativo anche tutti i tools necessari
        allo sviluppo del software, in questo modo potremmo avere la
        possibilit&agrave; di mantenere una versione di Squid sempre
        aggiornata compilata sulla macchina in produzione. A tale riguardo,
        nel proseguio di questo capitolo, vedremo come preparare delle
        versioni personalizzate di Squid compilando ed installando
        direttamente il codice sorgente.</p>

        <p>Parleremo anche dei Sistemi Operativi &quot;proprietari&quot;
        come <em>Sun Solaris</em>, <em>Digital UNIX</em>&reg;,
        <em>OS/2</em> (oramai non pi&ugrave; supportato o quasi) ed i
        Sistemi <em>Windows NT/2000/2003/XP</em> per i quali esistono dei
        ports perfettamente in linea con le versioni per i sistemi a codice
        libero.</p>
      </div>

      <div class="SECT1">
        <hr />

        <h2 class="SECT1"><a name="SEC-REGOLE-CAPABILITIES" id=
        "SEC-REGOLE-CAPABILITIES"></a>7.3. Regole da rispettare</h2>

        <p>Una delle risorse pi&ugrave; importanti da offrire a Squid
        &egrave; la memoria RAM, non &egrave; infatti fondamentale avere un
        processore particolarmente veloce e non &egrave; da sottovalutare
        il sottosistema dischi.</p>

        <div class="SECT2">
          <hr />

          <h3 class="SECT2"><a name="SUBSEC-NOTE-SULLA-RAM" id=
          "SUBSEC-NOTE-SULLA-RAM"></a>7.3.1. Utilizzo della memoria
          RAM</h3>

          <p>Squid utilizza la memoria RAM per tenere una traccia della
          tabella degli oggetti<a name="AEN865" href="#FTN.AEN865" id=
          "AEN865">[5]</a>, un&#39;accesso rapido a questa tabella &egrave;
          fondamentale, il ricorso alla memoria di swap penalizza le
          prestazioni di Squid sino a renderlo inservibile.</p>

          <p>Qualsiasi oggetto memorizzato su disco utilizza circa 75 bytes
          di memoria RAM, la grandezza media di un oggetto &egrave; di
          circa 13 Kb. Utilizzando questi valori &egrave; possibile
          definire uno standard di calcolo in merito al fabbisogno di
          memoria RAM da parte di Squid.</p>

          <div class="INFORMALTABLE">
            <a name="AEN870" id="AEN870"></a>

            <table border="1" class="CALSTABLE">
              <tbody>
                <tr>
                  <td width="33%" align="center" valign="top">
                    <p>1GB <em>cache_dir</em></p>
                  </td>

                  <td width="33%" align="right" valign="top">
                    <p>1.000.000/13</p>
                  </td>

                  <td width="33%" align="left" valign="top">
                    <p>= 76.923,07692 oggetti su disco</p>
                  </td>
                </tr>

                <tr>
                  <td width="33%" align="center" valign="top"></td>

                  <td width="33%" align="right" valign="top">
                    <p>75*76.923,07692</p>
                  </td>

                  <td width="33%" align="left" valign="top">
                    <p>= 5.769.230,769 pari a circa 6 MB di RAM</p>
                  </td>
                </tr>
              </tbody>
            </table>
          </div>per 1 GB di disk storage Squid richieder&agrave; circa 6 MB
          di RAM per funzionare correttamente
          <br />
          <br />

          <div class="INFORMALTABLE">
            <a name="AEN892" id="AEN892"></a>

            <table border="1" class="CALSTABLE">
              <tbody>
                <tr>
                  <td width="33%" align="center" valign="top">
                    <p>8GB <em>cache_dir</em></p>
                  </td>

                  <td width="33%" align="right" valign="top">
                    <p>8.000.000/13</p>
                  </td>

                  <td width="33%" align="left" valign="top">
                    <p>= 615.384,6154 oggetti su disco</p>
                  </td>
                </tr>

                <tr>
                  <td width="33%" align="center" valign="top"></td>

                  <td width="33%" align="right" valign="top">
                    <p>75*615.384,6154</p>
                  </td>

                  <td width="33%" align="left" valign="top">
                    <p>= 46.153.846,16 pari a circa 48 MB di RAM</p>
                  </td>
                </tr>
              </tbody>
            </table>
          </div>per 8 GB di disk storage Squid richieder&agrave; circa 48
          MB di RAM per funzionare correttamente
        </div>
        <br />

        <div class="SECT2">
          <hr />

          <h3 class="SECT2"><a name="SUBSEC-TIPO-DI-CPU" id=
          "SUBSEC-TIPO-DI-CPU"></a>7.3.2. Tipo di CPU</h3>

          <p>Squid non utilizza in maniera intensiva la CPU, solo al
          momento dell&#39;avviamento la CPU lavora a pieno regime
          perch&egrave; Squid deve verificare la validit&agrave; gli
          oggetti contenuti nella cache. Ne consegue che una CPU di vecchia
          generazione pu&ograve; penalizzare l&#39;accesso agli oggetti
          presenti nella cache unicamente nei minuti successivi
          all&#39;avviamento di Squid. Un sistema Pentium 300 Mhz
          pu&ograve; gi&agrave; essere sufficente per eseguire Squid in
          piccole realt&agrave; aziendali.</p>
        </div>

        <div class="SECT2">
          <hr />

          <h3 class="SECT2"><a name="SUBSEC-SISTEMI-SMP" id=
          "SUBSEC-SISTEMI-SMP"></a>7.3.3. Sistemi SMP</h3>

          <p>L&#39;utilizzo di un sistema multiprocessore non aumenta in
          modo significativo le performance di Squid in quanto
          l&#39;applicazione &egrave; basata su un processo singolo che non
          ricorre alla tecnologia SMP<a name="AEN919" href="#FTN.AEN919"
          id="AEN919">[6]</a>. Lievi benefici possono essere ottenuti nel
          caso di webcache con elevato carico di I/O su disco utilizzando
          configurazioni di Disk Storage asincrono (Cfr. la sezione
          relativa al <a href="#SEC-DISK-STORAGE">Disk Storage</a>).</p>

          <p>Nel caso volessimo ottenere dei grandi benefici
          dall&#39;utilizzo di SMP dovremo eseguire istanze multiple di
          Squid e trovare il sistema di distribuire gli utenti sulle
          diverse istanze.</p>
        </div>

        <div class="SECT2">
          <hr />

          <h3 class="SECT2"><a name="SUBSEC-SOTTOSISTEMA-DISCHI" id=
          "SUBSEC-SOTTOSISTEMA-DISCHI"></a>7.3.4. Sottosistema dischi e
          tecnologie</h3>

          <p>Per quanto concerne il sottositema dischi lo standard su bus
          SCSI &egrave; la soluzione consigliata, a tale riguardo si
          rammenta che oggi &egrave; possibile utilizzare dei sistemi su
          bus EIDE<a name="AEN926" href="#FTN.AEN926" id="AEN926">[7]</a> o
          ATA<a name="AEN928" href="#FTN.AEN928" id="AEN928">[8]</a> che
          prevedono il collegamento con delle unit&agrave; a disco molto
          veloci, queste unit&agrave; devono essere in grado di supportare
          il trasfermento dei dati tramite DMA<a name="AEN930" href=
          "#FTN.AEN930" id="AEN930">[9]</a> e devono disporre di una
          capacit&agrave; di rotazione pari almeno 7.200 rpm. Per
          bilanciare al meglio le performance di Squid &egrave; necessario
          valutare anche altri fattori a riguardo della scelta delle
          unit&agrave; a disco</p>

          <ul>
            <li>
              <p>il numero delle unit&agrave; a disco</p>
            </li>

            <li>
              <p>il tipo di file system</p>
            </li>

            <li>
              <p>lo spazio libero su disco</p>
            </li>

            <li>
              <p>il numero di files presenti sul file system</p>
            </li>
          </ul>
        </div>

        <div class="SECT2">
          <hr />

          <h3 class="SECT2"><a name="SUBSEC-SISTEMI-RAID" id=
          "SUBSEC-SISTEMI-RAID"></a>7.3.5. Sistemi in RAID</h3>

          <p>A livello progettuale, la soluzione migliore che possiamo
          proporre al lettore &egrave; quella di utilizzare i dischi in
          RAID<a name="AEN944" href="#FTN.AEN944" id="AEN944">[10]</a>
          Livello 1 per il sistema Operativo e utilizzare uno o pi&ugrave;
          dischi per lo spazio dedicato al disk storage (cache)</p>

          <ul>
            <li>
              <p>RAID Livello 1 &egrave; una ottima soluzione, lo stesso
              vale per unit&agrave; a disco separate</p>
            </li>

            <li>
              <p>RAID Livello 0 (striping) non determina nessun vantaggio a
              livello di performance</p>
            </li>

            <li>
              <p>RAID Livello 5 &egrave; la soluzione meno indicata</p>
            </li>
          </ul>

          <p>la soluzione RAID Livello 5 degrada le prestazioni in quanto
          lo spazio dedicato al disk storage viene scritto diverse volte in
          modalit&agrave; randomica. Questa modalit&agrave; di scrittura
          dei dati su disco riduce la velocit&agrave; e quindi le
          performance se paragonata con un sistema a disco singolo.
          Dobbiamo per&ograve; anche dire che i sistemi RAID garantiscono
          un livello di stabilit&agrave; e di affidabilit&agrave; superiore
          in quanto sono stati progettati per ridondare delle componenti
          che sono molto sensibili ai guasti come le unit&agrave; a
          disco.</p>
        </div>
      </div>

      <div class="SECT1">
        <hr />

        <h2 class="SECT1"><a name="SEC-SISTEMA-OTTIMALE" id=
        "SEC-SISTEMA-OTTIMALE"></a>7.4. Il sistema ottimale</h2>

        <p>Proponiamo ora al lettore una configurazione che pu&ograve;
        essere presa come punto di riferimento nella costruzione di una
        webcache appliance efficente. I valori sono riferiti
        all&#39;attuale mercato dell&#39;Information and Communication
        Technology</p>

        <ul>
          <li>
            <p>Si consiglia una CPU Intel Pentium =&gt;300 Mhz o AMD K6
            =&gt; 300 Mhz</p>
          </li>

          <li>
            <p>Si consiglia una CPU di tipo i686/K7/Athlon se si intende
            utilizzare Squid in modalit&agrave; threaded<a name="AEN962"
            href="#FTN.AEN962" id="AEN962">[11]</a></p>
          </li>

          <li>
            <p>La tecnologia SCSI &egrave; altamente raccomandata</p>
          </li>

          <li>
            <p>&Eacute; possibile utilizzare un disco IDE UDMA 66/100</p>
          </li>

          <li>
            <p>Le capacit&agrave; del disco devono essere tipicamente =&gt;
            9Gb</p>
          </li>

          <li>
            <p>Nel caso si utilizzino unit&agrave; a disco EIDE/UDMA 66/100
            &egrave; consigliabile utilizzare una CPU veloce per compensare
            il gap sul consumo dei cicli di clock<a name="AEN973" href=
            "#FTN.AEN973" id="AEN973">[12]</a></p>
          </li>

          <li>
            <p>Una o pi&ugrave; schede di rete ad alta capacit&agrave;
            10/100Mb/s sono sufficenti</p>
          </li>

          <li>
            <p>Nei valori da impostare per ottenere un corretto
            dimensionamento della memoria RAM di sistema &egrave; bene non
            dimenticare il fatto che per ogni Gb di disk storage sono
            richiesti circa 6Mb di RAM, quindi 8Gb di <em>cache_dir</em>
            rappresentano 48 Mb di memoria RAM</p>
          </li>

          <li>
            <p>RAM minima: 128 Mb</p>
          </li>

          <li>
            <p>RAM massima: 1024 Mb</p>
          </li>
        </ul>

        <p>Ulteriori dettagli alla URLs: <a href=
        "http://www.squid-cache.org/Doc/FAQ/FAQ-3.html#ss3.1" target=
        "_top">http://www.squid-cache.org/Doc/FAQ/FAQ-3.html#ss3.1</a></p>
      </div>

      <div class="SECT1">
        <hr />

        <h2 class="SECT1"><a name="SEC-SOURCE-CODE" id=
        "SEC-SOURCE-CODE"></a>7.5. I file sorgenti di Squid</h2>

        <p>I file contenenti i codici sorgenti di Squid possono essere
        prelevati direttamente dal sito ufficiale del progetto di Squid
        alla URL <a href="http://www.squid-cache.org/" target=
        "_top">http://www.squid-cache.org/</a>, il formato del file
        contenente i sorgenti &egrave; un file compresso, con estensione
        .<em>bz2</em>, se &egrave; stato trattato con <em>bzip</em>(8).
        Bzip2 &egrave; un nuovo algoritmo per la compressione dei dati che
        generalmente crea file che sono pari al 60-70% della dimensione dei
        corrispondenti ottenuti usando gzip (<a href=
        "http://www.digistar.com/bzip2/index.html" target=
        "_top">http://www.digistar.com/bzip2/index.html</a>)</p>

        <table border="0" bgcolor="#E0E0E0" width="100%">
          <tr>
            <td>
              <pre class="PROGRAMLISTING">
squid-z.y.STABLEx.tar.bz2
  
</pre>
            </td>
          </tr>
        </table>

        <p>oppure &egrave; possibile prelevare sempre un file compresso,
        con estensione .<em>gz</em>, se &egrave; stato trattato con
        <em>gzip</em>(8). GNU zip &egrave; un programma destinato a
        rimpiazzare compress ovvero il programma originario di compressione
        dei sistemi UNIX&reg;, le specifiche applicative sono descritte
        nelle RFC 1951 e 1952 (<a href=
        "http://www.ietf.org/rfc/rfc1951.txt" target=
        "_top">http://www.ietf.org/rfc/rfc1951.txt</a> - <a href=
        "http://www.ietf.org/rfc/rfc1952.txt" target=
        "_top">http://www.ietf.org/rfc/rfc1952.txt</a>)</p>

        <table border="0" bgcolor="#E0E0E0" width="100%">
          <tr>
            <td>
              <pre class="PROGRAMLISTING">
squid-z.y.STABLEx.tar.gz
  
</pre>
            </td>
          </tr>
        </table>

        <p>dove <em>z</em> sta ad indicare la versione, <em>y</em> indica
        la sottoversione e la <em>x</em> indica la release STABLE. Seguendo
        lo standard descrittivo appena citato, il file contenente
        l&#39;archivio dei codici sorgenti per la versione squid-2.5STABLE5
        sar&agrave; dunque</p>

        <table border="0" bgcolor="#E0E0E0" width="100%">
          <tr>
            <td>
              <pre class="PROGRAMLISTING">
squid-2.5.STABLE5.tar.bz2
  
</pre>
            </td>
          </tr>
        </table>

        <p>oppure</p>

        <table border="0" bgcolor="#E0E0E0" width="100%">
          <tr>
            <td>
              <pre class="PROGRAMLISTING">
squid-2.5.STABLE5.tar.gz
  
</pre>
            </td>
          </tr>
        </table>

        <div class="SECT2">
          <hr />

          <h3 class="SECT2"><a name="SUBSEC-PRELEVARE-SQUID" id=
          "SUBSEC-PRELEVARE-SQUID"></a>7.5.1. Prelevare Squid</h3>

          <p>il file contenente il codice sorgente &egrave; disponibile sul
          sito ftp del progetto Squid (<a href=
          "ftp://ftp.squid-cache.org/pub/squid-2/STABLE/" target=
          "_top">ftp://ftp.squid-cache.org/pub/squid-2/STABLE/</a>), presso
          la home page del progetto Squid sono anche disponibili tutte le
          patch che consentono di aggiungere funzionalit&agrave; o di
          aggiornare la versione di Squid.</p>
        </div>

        <div class="SECT2">
          <hr />

          <h3 class="SECT2"><a name="SUBSEC-COMPILARE-SQUID" id=
          "SUBSEC-COMPILARE-SQUID"></a>7.5.2. Compilare Squid</h3>

          <p>Per compilare Squid &egrave; necessario disporre di un
          compilatore <em>ANSI C</em><a name="AEN1015" href="#FTN.AEN1015"
          id="AEN1015">[13]</a>, tutti i moderni sistemi UNIX&reg;
          includono un compilatore con queste caratteristiche
          preinstallato. I vecchi Sistemi <em>SunOS</em> non dispongono di
          compilatori compatibili con lo standard <em>ANSI C</em> ed il
          compilatore per i Sistemi <em>Sun Solaris</em> deve essere
          acquistato a parte.</p>

          <p>Il compilatore <em>GNU C</em> &egrave; disponibile presso il
          sito ftp del progetto GNU (<a href="ftp://ftp.gnu.org/" target=
          "_top">ftp://ftp.gnu.org/</a>), inoltre per compilare ed
          installare correttamente Squid sono anche necessarie le librerie
          <em>gcc</em> (<a href="ftp://ftp.gnu.org/gnu/gcc/" target=
          "_top">ftp://ftp.gnu.org/gnu/gcc/</a>), il package
          <em>binutils</em> (<a href="ftp://ftp.gnu.org/gnu/binutils/"
          target="_top">ftp://ftp.gnu.org/gnu/binutils/</a>) ed i linguaggi
          <em>Awk</em> e <em>Perl</em> (<a href="http://www.perl.org/"
          target="_top">http://www.perl.org/</a>).A seconda delle opzioni
          di compilazione e dei moduli di Squid selezionati, possono
          inoltre essere necessarie le librerie <em>OpenLDAP</em> ed
          <em>OpenSSL</em>, nonch&eacute; i Sorgenti di <em>Samba
          2.2.x</em>.</p>

          <p>In ogni caso, per compilare ed installare tutte le versioni di
          Squid, &egrave; necessario eseguire lo script di
          <em>configure</em> prima di lanciare il comando <em>make</em></p>

          <table border="0" bgcolor="#E0E0E0" width="100%">
            <tr>
              <td>
                <pre class="PROGRAMLISTING">
# bunzip2 squid-2.5.STABLE5.tar.bz2
# tar xvf squid-2.5.STABLE5.tar
# cd squid-2.5.STABLE5
# ./configure
# make
   
</pre>
              </td>
            </tr>
          </table>

          <p>Tutte le caratteristiche di Squid vengono attivate utilizzando
          lo script di configurazione (<em>configure</em>), alcune di
          queste opzioni devono essere dichiarate specificatamente al
          momento della compilazione, per ottenere una configurazione
          ottimale pu&ograve; anche rendersi necessario ricompilare
          ulterioramente.</p>

          <p>Una delle ragioni per le quali una specifica caratteristica di
          Squid possa non essere disponibile &egrave; determinata dal
          livello di compatibilit&agrave; del Sistema Operativo con i
          codici sorgenti. Anche se Squid viene rilasciato con un codice
          sorgente valido per un&#39;utilizzo generico e multipiattaforma,
          &egrave; comunque possibile che determinate funzioni, come
          <em>async-IO</em> o le ACL <em>ARP-based</em>, non siano
          disponibili per quel tipo di Sistema Operativo. Lo script di
          configurazione (<em>configure</em>) pu&ograve; contenere alcune
          caratteristiche che informano gli utenti sullo stato delle
          opzioni di configurazione disponibili.</p>

          <p>Alcuni Amministratori di Sistema disabilitano volutamente
          determinate caratteristiche di Squid per rendere sempre
          pi&ugrave; performante il funzionamento delle loro piattaforme,
          come abbiamo accennato prima, &egrave; possibile includere in
          Squid le funzionalit&agrave; che oggi non sono richieste senza
          problemi o effetti collaterali ricompilando i sorgenti in un
          secondo momento.</p>

          <p>Il programma di configurazione (<em>configure</em>) ha inoltre
          una seconda funzione, infatti inserisce una sorta di intestazione
          che informa il compilatore C relativamente alle chiamate o alle
          funzioni di Sistema. Questo fatto, molto spesso, rende la
          compilazione del codice sorgente piuttosto difficile. Il
          compilatore <em>GNU</em> configura i controlli dello script per
          programmare le librerie e le chiamate di Sistema realmente
          disponibili sul Vostro Sistema Operativo. Questa
          funzionalit&agrave; del compilatore <em>GNU</em> facilita la
          messa a punto del codice.</p>

          <p>Il file di configurazione (<em>configure</em>) &egrave;
          generico, in particolare si tratta di uno script realizzato per
          la Bourne Shell <a name="AEN1050" href="#FTN.AEN1050" id=
          "AEN1050">[14]</a> (<em>/bin/sh</em>), se avete sostituito il
          comando <em>/bin/sh</em> con una Shell non compatibile o con una
          Shell che effettua delle chiamate non conformi allo standard
          Posix, non potrete compilare ed installare Squid sul Vostro
          Sistema Operativo.</p>

          <p>Tutte le opzioni di configurazione vengono regolate
          dall&#39;opzione <em>./configure</em>. Nell&#39;esempio che
          tratteremo di seguito, compileremo Squid con diversi supporti tra
          cui, il tipo di autenticazione, lo schema di autenticazione ed i
          relativi helpers, diskd Disk Storage ed il supporto <em>Simple
          Network Management Protocol</em> (SNMP)</p>

          <table border="0" bgcolor="#E0E0E0" width="100%">
            <tr>
              <td>
                <pre class="PROGRAMLISTING">
[root@portatilo squid-2.5.STABLE5]# ./configure --prefix=/usr/local/squid/ \
--enable-snmp \
--bindir=/usr/local/sbin \
--sysconfdir=/usr/local/etc/squid \
--datadir=/usr/local/etc/squid \
--libexecdir=/usr/local/libexec/squid \
--localstatedir=/usr/local/squid \
--enable-removal-policies=&quot;lru heap&quot; \
--enable-auth=&quot;basic ntlm digest&quot; \
--enable-basic-auth-helpers=&quot;NCSA PAM YP MSNT winbind&quot; \
--enable-digest-auth-helpers=password \
--enable-external-acl-helpers=&quot;ip_user unix_group wbinfo_group winbind_group&quot; \
--enable-ntlm-auth-helpers=&quot;SMB winbind&quot; \
--enable-async-io --with-pthreads \
--enable-storeio=&quot;ufs diskd null aufs&quot; \
--enable-snmp \
--enable-ssl \
--enable-htcp \
--disable-http-violations \
--disable-ident-lookups \
--enable-useragent-log \
--enable-arp-acl \
--enable-err-languages=&quot;English Italian&quot; \
--enable-default-err-language=&quot;Italian&quot; \
--prefix=/usr/local
   
</pre>
              </td>
            </tr>
          </table>

          <p>molte di queste opzioni sono tra quelle che vengono pi&ugrave;
          comunemente utilizzate.</p>
        </div>

        <div class="SECT2">
          <hr />

          <h3 class="SECT2"><a name="SUBSEC-APPLICARE-LE-PATCH" id=
          "SUBSEC-APPLICARE-LE-PATCH"></a>7.5.3. Applicare le patch</h3>

          <p>Per eseguire questa operazione &egrave; richiesta la presenza
          del programma <em>patch</em>, questo programma &egrave;
          disponibile sul sito ftp del progetto GNU (<a href=
          "ftp://ftp.gnu.org/gnu/patch/" target=
          "_top">ftp://ftp.gnu.org/gnu/patch/</a>).</p>

          <p>E&#39; sempre una buona norma duplicare l&#39;intera struttura
          della directory che contiene i codici sorgenti di Squid prima di
          applicare qualsiasi patch, se si sta aggiornando Squid dalla
          versione squid-2.5.STABLE4 alla versione 2.5.STABLE5, sar&agrave;
          necessario eseguire i seguenti comandi:</p>

          <table border="0" bgcolor="#E0E0E0" width="100%">
            <tr>
              <td>
                <pre class="PROGRAMLISTING">
# cp -rl squid-2.5.STABLE4 squid-2.5.STABLE5
# cd squid-2.5.STABLE5
# zcat /tmp/squid-2.5.STABLE4-STABLE5.diff.gz | patch -p1
   
</pre>
              </td>
            </tr>
          </table>

          <p>Dopo aver applicato la patch potremo finalmente eseguire il
          rebuild di Squid</p>

          <table border="0" bgcolor="#E0E0E0" width="100%">
            <tr>
              <td>
                <pre class="PROGRAMLISTING">
# make distclean
# ./configure
# make
# make install
   
</pre>
              </td>
            </tr>
          </table>

          <p>Se il programma patch si dovesse rifiutare di funzionare
          &egrave; possibile utilizzare una versione pi&ugrave; recente
          prelevandola direttamente dal repository ftp del progetto GNU
          (<a href="ftp://ftp.gnu.org/gnu/patch/" target=
          "_top">ftp://ftp.gnu.org/gnu/patch/</a>).</p>
        </div>

        <div class="SECT2">
          <hr />

          <h3 class="SECT2"><a name="SUBSEC-VERSIONE-GIORNALIERA" id=
          "SUBSEC-VERSIONE-GIORNALIERA"></a>7.5.4. Versione giornaliera
          autogenerata</h3>

          <p>Il daily snapshot dei sorgenti di Squid &egrave; il rilascio
          del codice sorgente pi&ugrave; aggiornato per il branch corrente
          (attualmente SQUID_2_5). Dalla data di rilascio dell&#39;ultima
          versione STABLE occasionalmente vengono rilasciate delle patch
          che correggono gli errori che sono stati rilevati dagli utenti e
          dagli sviluppatori. Queste fix oltre ad altre correzioni minori,
          vengono incluse in una versione corrente di Squid, questa release
          prende il nome di <em>current Squid-2.5 snapshots</em> e viene
          rilasciata giornalmente. Le versione current pu&ograve; essere
          considerata alla stregua della successiva release di
          Squid-2.5.STABLE. La procedura per installare e compilare la
          versione current &egrave; la medesima e la URLs dalla quale
          prelevare il codice sorgente &egrave; <a href=
          "http://www.squid-cache.org/Versions/v2/2.5/" target=
          "_top">http://www.squid-cache.org/Versions/v2/2.5/</a>, sezione
          Daily auto-generated release</p>

          <table border="0" bgcolor="#E0E0E0" width="100%">
            <tr>
              <td>
                <pre class="PROGRAMLISTING">
[root@portatilo mywork]# wget \
http://www.squid-cache.org/Versions/v2/2.5/squid-2.5.STABLE5-20040403.tar.gz
--12:26:17-- http://www.squid-cache.org/Versions/v2/2.5/squid-2.5.STABLE5-20040403.tar.gz 
=&gt; `squid-2.5.STABLE5-20040403.tar.gz&#39;
Resolving www.squid-cache.org... fatto.
Connecting to www.squid-cache.org[206.168.0.9]:80... connected.
HTTP richiesta inviata, aspetto la risposta... 200 OK
Lunghezza: 1,353,227 [application/x-tar]
100%[====================================&gt;] 1,353,227 67.76K/s ETA 00:00
12:26:37 (67.76 KB/s) - `squid-2.5.STABLE5-20040403.tar.gz&#39; salvato
[1353227/1353227]
   
</pre>
              </td>
            </tr>
          </table>

          <p>ora scompattiamo l&#39;archivio contenente i sorgenti e
          compiliamo il codice</p>

          <table border="0" bgcolor="#E0E0E0" width="100%">
            <tr>
              <td>
                <pre class="PROGRAMLISTING">
[root@portatilo mywork]# tar zxvf squid-2.5.STABLE5-20040403.tar.gz
[root@portatilo mywork]# cd squid-2.5.STABLE5-20040403
[root@portatilo squid-2.5.STABLE5-20040403]# ./configure \
--enable-removal-policies=&quot;lru heap&quot; \
--enable-auth=&quot;basic ntlm digest&quot; \
--enable-basic-auth-helpers=&quot;NCSA PAM YP MSNT winbind&quot; \
--enable-digest-auth-helpers=password \
--enable-external-acl-helpers=&quot;ip_user unix_group wbinfo_group winbind_group&quot; \
--enable-ntlm-auth-helpers=&quot;SMB winbind&quot; \
--enable-async-io --with-pthreads \
--enable-storeio=&quot;ufs diskd null aufs&quot; \
--enable-snmp \
--enable-ssl \
--enable-htcp \
--disable-http-violations \
--disable-ident-lookups \
--enable-useragent-log \
--enable-arp-acl \
--enable-err-languages=&quot;English Italian&quot; \
--enable-default-err-language=Italian
   
</pre>
              </td>
            </tr>
          </table>

          <p>naturalmente dovremo scegliere le opzioni di configurazione
          (<em>configure</em>) pi&ugrave; adeguate al nostro tipo di
          configurazione</p>

          <table border="0" bgcolor="#E0E0E0" width="100%">
            <tr>
              <td>
                <pre class="PROGRAMLISTING">
[root@portatilo squid-2.5.STABLE5-20040403]# make
[root@portatilo squid-2.5.STABLE5-20040403]# make install
[root@portatilo squid-2.5.STABLE5-20040403]# make clean
   
</pre>
              </td>
            </tr>
          </table>
        </div>

        <div class="SECT2">
          <hr />

          <h3 class="SECT2"><a name="SUBSEC-OPZIONI-DI-CONFIGURE" id=
          "SUBSEC-OPZIONI-DI-CONFIGURE"></a>7.5.5. Opzioni di
          configurazione</h3>

          <p>Come abbiamo visto, lo script di <em>configure</em> pu&ograve;
          essere avviato con numerose opzioni, una di quelle pi&ugrave;
          utilizzate &egrave;</p>

          <table border="0" bgcolor="#E0E0E0" width="100%">
            <tr>
              <td>
                <pre class="PROGRAMLISTING">
--prefix
   
</pre>
              </td>
            </tr>
          </table>

          <p>con questa opzione si definisce il percorso nel quale verranno
          installati i file eseguibili di Squid, la directory che viene
          utilizzata come default &egrave;</p>

          <table border="0" bgcolor="#E0E0E0" width="100%">
            <tr>
              <td>
                <pre class="PROGRAMLISTING">
/usr/local/squid/
   
</pre>
              </td>
            </tr>
          </table>

          <p>&egrave; possibile modificare questo valore eseguendo lo
          script di <em>configure</em> utilizzando le seguenti opzioni</p>

          <table border="0" bgcolor="#E0E0E0" width="100%">
            <tr>
              <td>
                <pre class="PROGRAMLISTING">
# cd squid-2.5.STABLE5
# ./configure --prefix=/path/path2/directory/squid
   
</pre>
              </td>
            </tr>
          </table>

          <p>eseguendo il comando</p>

          <table border="0" bgcolor="#E0E0E0" width="100%">
            <tr>
              <td>
                <pre class="PROGRAMLISTING">
# ./configure --help
   
</pre>
              </td>
            </tr>
          </table>

          <p>&egrave; possibile visualizzare tutte le opzioni di
          <em>configure</em> attualmente disponibili. Per abilitare o
          disabilitare alcune delle features di Squid, dovremo specificare
          diverse opzioni di configurazione. Mostriamo ora tutte le opzioni
          di <em>configure</em>, la lista &egrave; aggiornata a
          squid-2.5.STABLE5</p>

          <table border="0" bgcolor="#E0E0E0" width="100%">
            <tr>
              <td>
                <pre class="PROGRAMLISTING">
Usage: configure [options] [host]
Options: [defaults in brackets after descriptions]
<em>Configuration:</em>
  --cache-file=FILE       cache test results in FILE
  --help                  print this message
  --no-create             do not create output files
  --quiet, --silent       do not print `checking...&#39; messages
  --site-file=FILE        use FILE as the site file
  --version               print the version of autoconf that created configure
<em>Directory and file names:</em>
  --prefix=PREFIX         install architecture-independent files in PREFIX
                          [/usr/local/squid]
  --exec-prefix=EPREFIX   install architecture-dependent files in EPREFIX
                          [same as prefix]
  --bindir=DIR            user executables in DIR [EPREFIX/bin]
  --sbindir=DIR           system admin executables in DIR [EPREFIX/sbin]
  --libexecdir=DIR        program executables in DIR [EPREFIX/libexec]
  --datadir=DIR           read-only architecture-independent data in DIR
                          [PREFIX/share]
  --sysconfdir=DIR        read-only single-machine data in DIR [PREFIX/etc]
  --sharedstatedir=DIR    modifiable architecture-independent data in DIR
                          [PREFIX/com]
  --localstatedir=DIR     modifiable single-machine data in DIR [PREFIX/var]
  --libdir=DIR            object code libraries in DIR [EPREFIX/lib]
  --includedir=DIR        C header files in DIR [PREFIX/include]
  --oldincludedir=DIR     C header files for non-gcc in DIR [/usr/include]
  --infodir=DIR           info documentation in DIR [PREFIX/info]
  --mandir=DIR            man documentation in DIR [PREFIX/man]
  --srcdir=DIR            find the sources in DIR [configure dir or ..]
  --program-prefix=PREFIX prepend PREFIX to installed program names
  --program-suffix=SUFFIX append SUFFIX to installed program names
  --program-transform-name=PROGRAM
                          run sed PROGRAM on installed program names
<em>Host type:</em>
  --build=BUILD           configure for building on BUILD [BUILD=HOST]
  --host=HOST             configure for HOST [guessed]
  --target=TARGET         configure for TARGET [TARGET=HOST]
<em>Features and packages:</em>
  --disable-FEATURE       do not include FEATURE (same as --enable-FEATURE=no)
  --enable-FEATURE[=ARG]  include FEATURE [ARG=yes]
  --with-PACKAGE[=ARG]    use PACKAGE [ARG=yes]
  --without-PACKAGE       do not use PACKAGE (same as --with-PACKAGE=no)
  --x-includes=DIR        X include files are in DIR
  --x-libraries=DIR       X library files are in DIR
--enable and --with options recognized:
  --disable-dependency-tracking Speeds up one-time builds
  --enable-dependency-tracking  Do not reject slow dependency extractors
  --enable-maintainer-mode enable make rules and dependencies not useful
                          (and sometimes confusing) to the casual installer
  --enable-dlmalloc[=LIB] Compile &amp; use the malloc package by Doug Lea
  --enable-gnuregex       Compile GNUregex
  --enable-xmalloc-statistics
                          Show malloc statistics in status page
  --enable-carp           Enable CARP support
  --enable-async-io[=N_THREADS]
                          Shorthand for
                          --with-aufs-threads=N_THREADS
                          --with-pthreads
                          --enable-storeio=ufs,aufs
  --with-aufs-threads=N_THREADS
                          Tune the number of worker threads for the aufs object
                          store.
  --with-pthreads         Use POSIX Threads
  --with-aio              Use POSIX AIO
  --with-dl               Use dynamic linking
  --enable-storeio=&quot;list of modules&quot;
                          Build support for the list of store I/O modules.
                          The default is only to build the ufs module.
                          See src/fs for a list of available modules, or
                          Programmers Guide section &lt;not yet written&gt;
                          for details on how to build your custom store module
  --enable-heap-replacement
                          Backwards compability option. Please use the
                          new --enable-removal-policies directive instead.
  --enable-removal-policies=&quot;list of policies&quot;
                          Build support for the list of removal policies.
                          The default is only to build the lru module.
                          See src/repl for a list of available modules, or
                          Programmers Guide section 9.9 for details on how
                          to build your custom policy
  --enable-icmp           Enable ICMP pinging
  --enable-delay-pools    Enable delay pools to limit bandwidth usage
  --enable-useragent-log  Enable logging of User-Agent header
  --enable-referer-log    Enable logging of Referer header
  --disable-wccp          Disable Web Cache Coordination Protocol
  --enable-kill-parent-hack
                          Kill parent on shutdown
  --enable-snmp           Enable SNMP monitoring
  --enable-cachemgr-hostname[=hostname]
                          Make cachemgr.cgi default to this host
  --enable-arp-acl        Enable use of ARP ACL lists (ether address)
  --enable-htcp           Enable HTCP protocol
  --enable-ssl            Enable ssl gatewaying support using OpenSSL
  --with-openssl[=prefix]
                          Compile with the OpenSSL libraries. The path to
                          the OpenSSL development libraries and headers
                          installation can be specified if outside of the
                          system standard directories
  --enable-forw-via-db    Enable Forw/Via database
  --enable-cache-digests  Use Cache Digests
                          see http://www.squid-cache.org/FAQ/FAQ-16.html
  --enable-default-err-language=lang
                          Select default language for Error pages (see
                          errors directory) 
  --enable-err-languages=&quot;lang1 lang2..&quot;
                          Select languages to be installed. (All will be
                          installed by default) 
  --with-coss-membuf-size COSS membuf size (default 1048576 bytes) 
  --enable-poll           Enable poll() instead of select().  Normally poll
                          is preferred over select, but configure knows poll
                          is broken on some platforms.  If you think you are
                          smarter than the configure script, you may enable
                          poll with this option.
  --disable-poll          Disable the use of poll().
  --disable-http-violations
                          This allows you to remove code which is known to
                          violate the HTTP protocol specification.
  --enable-ipf-transparent
                          Enable Transparent Proxy support for systems
                          using IP-Filter network address redirection.
  --enable-pf-transparent
                          Enable Transparent Proxy support for systems
                          using PF network address redirection.
  --enable-linux-netfilter
                          Enable Transparent Proxy support for Linux 2.4.
  --enable-leakfinder
                          Enable Leak Finding code.  Enabling this alone
                          does nothing; you also have to modify the source
                          code to use the leak finding functions.  Probably
                          Useful for hackers only.
  --disable-ident-lookups
                          This allows you to remove code that performs
                          Ident (RFC 931) lookups.
  --disable-internal-dns  This prevents Squid from directly sending and
                          receiving DNS messages, and instead enables the
                          old external &#39;dnsserver&#39; processes.
  --enable-truncate       This uses truncate() instead of unlink() when
                          removing cache files.  Truncate gives a little
                          performance improvement, but may cause problems
                          when used with async I/O.  Truncate uses more
                          filesystem inodes than unlink..
  --disable-hostname-checks
                          Squid by default rejects any host names with
                          odd characters in their name to conform with
                          internet standards. If you disagree with this
                          you may use this switch to turn off any such
                          checks, provided that the resolver used by
                          Squid does not reject such host names.. This
                          may be required to participate in testbeds for
                          international domain names.
  --enable-underscores    Squid by default rejects any host names with _
                          in their name to conform with internet standards.
                          If you disagree with this you may allow _ in
                          hostnames by using this switch, provided that
                          the resolver library on the host where Squid runs
                          does not reject _ in hostnames...
  --enable-auth=&quot;list of auth scheme modules&quot;
                          Build support for the list of authentication schemes.
                          The default is to build support for the Basic scheme.
                          See src/auth for a list of available modules, or
                          Programmers Guide section authentication schemes
                          for details on how to build your custom auth scheme
                          module
  --enable-auth-modules=&quot;list of helpers&quot;
                          Backwards compability alias for
                          --enable-basic-auth-helpers
  --enable-basic-auth-helpers=&quot;list of helpers&quot;
                          This option selects which basic scheme proxy_auth
                          helpers to build and install as part of the normal 
                          build process. For a list of available
                          helpers see the helpers/basic_auth directory.
  --enable-ntlm-auth-helpers=&quot;list of helpers&quot;
                          This option selects which proxy_auth ntlm helpers
                          to build and install as part of the normal build 
                          process. For a list of available helpers see
                          the helpers/ntlm_auth directory.
  --enable-digest-auth-helpers=&quot;list of helpers&quot;
                          This option selects which digest scheme authentication
                          helpers to build and install as part of the normal build
                          process. For a list of available helpers see the
                          helpers/digest_auth directory.
  --enable-ntlm-fail-open Enable NTLM fail open, where a helper that fails one of the
                          Authentication steps can allow squid to still authenticate
                          the user.
  --enable-external-acl-helpers=&quot;list of helpers&quot;
                          This option selects which external_acl helpers to
                          build and install as part of the normal build
                          process. For a list of available helpers see the
                          helpers/external_acl directory.
  --with-samba-sources=/path/to/samba-source-tree
                          Path where the correct Samba source files can be
                          found while building winbind helpers. (defaults to
                          use internal copies of the headers from Samba-2.2.7)
                          
  --disable-unlinkd       Do not use unlinkd
  --enable-stacktraces    Enable automatic call backtrace on fatal errors
  --enable-x-accelerator-vary
                          Enable support for the X-Accelerator-Vary
                          HTTP header. Can be used to indicate
                          variance within an accelerator setup.
                          Typically used together with other code
                          that adds custom HTTP headers to the requests.
   
</pre>
              </td>
            </tr>
          </table>
        </div>
      </div>

      <div class="SECT1">
        <hr />

        <h2 class="SECT1"><a name="SEC-FILE-DESCRIPTOR" id=
        "SEC-FILE-DESCRIPTOR"></a>7.6. Il problema dei <em>file
        descriptor</em></h2>

        <p>Un <em>file descriptor</em> &egrave; un numero che viene
        rappresentato da un file o da un socket aperto, ogni volta che un
        processo di Sistema apre un file o un socket viene allocato un
        <em>file descriptor</em>, quando questo file viene chiuso il
        relativo <em>file descriptor</em> verr&agrave; liberato. Per
        gestire l&#39;accesso ai file e ai socket, Squid utilizza una
        tabella di processo che contiene l&#39;elenco di tutti i <em>file
        descriptor</em> aperti. La dimensione di questa tabella &eacute;
        statica e viene impostata al momento dell&#39;esecuzione del
        comando <em>configure</em>. I diversi Sistemi Operativi oggi sul
        mercato utilizzano uno schema proprietario nella gestione dei
        processi e pu&ograve; accadere che il valore dei <em>file
        descriptor</em> predefinito nel Kernel del Sistema sia troppo
        piccolo per garantire il funzionamento di alcuni apparati di
        webcache la cui peculiariet&agrave; &egrave; quella di gestire dei
        carichi di traffico molto elevati. Pu&ograve; quindi rendersi
        necessario aumentare il valore dei <em>file descriptor</em> prima
        di eseguire il comando <em>configure</em>. Per determinare un
        valore adeguato si deve tenere conto dei seguenti fattori</p>

        <ol type="1">
          <li>
            <p>la singola richiesta HTTP utilizza contemporaneamente sino a
            <em>3</em> file descriptor</p>

            <p>connessione HTTP lato client, connessione HTTP lato server e
            la scrittura o la lettura della cache su disco (scrivere nella
            cache un MISS o leggere nella cache un HIT)</p>
          </li>

          <li>
            <p>la scrittura delle informazioni nei file di log utilizza
            contemporaneamente sino a <em>4</em> file descriptor</p>

            <p>Squid utilizza solitamente quattro file di log principali
            (<em>access.log</em>, <em>cache.log</em>, <em>store.log</em> e
            <em>swap.state</em>) e nel momento in cui accede a detti file
            apre un <em>file descriptor</em></p>
          </li>

          <li>
            <p>le comunicazioni tra Squid ed i processi esterni utilizzano
            mediamente sino a <em>20</em> file descriptors</p>

            <p>gli autenticatori, i redirectors e le porte in ascolto,
            mantengono sempre un certo numero di <em>file descriptors</em>
            attivi, il valore medio dipende molto dal numero degli helpers
            utilizzati e dal numero dei socket che vengono aperti da Squid
            (porte HTTP, ICP, SNMP ed altro).</p>
          </li>

          <li>
            <p>un browser web esegue mediamente 2 o 3 richieste HTTP
            persistenti (idle time)</p>

            <p>ci&ograve; significa che per ogni browser web, volendo fare
            un dimensionamento pessimistico, si deve prevedere un utilizzo
            di circa 8 <em>file descriptor</em>.</p>
          </li>
        </ol>

        <div class="SECT2">
          <hr />

          <h3 class="SECT2"><a name="SUBSEC-NUMERO-FILE-DESCRIPTOR" id=
          "SUBSEC-NUMERO-FILE-DESCRIPTOR"></a>7.6.1. Determinare il numero
          corretto di <em>file descriptor</em></h3>

          <p>Quando Squid &egrave; fermo in attesa di richieste utilizza in
          media <em>24</em> <em>file descriptor</em> (file di log e
          comunicazioni tra processi), ogni singola richiesta HTTP
          determina l&#39;apertura di una media di <em>8</em> <em>file
          descriptor</em> (singola richiesta e connessioni
          persistenti).</p>

          <div class="INFORMALTABLE">
            <a name="AEN1146" id="AEN1146"></a>

            <table border="1" class="CALSTABLE">
              <tbody>
                <tr>
                  <td width="25%" align="center" valign="top">
                    <p><em>file descriptor medi</em></p>
                  </td>

                  <td width="25%" align="center" valign="top">
                    <p><em>utenti concorrenti</em></p>
                  </td>

                  <td width="25%" align="center" valign="top">
                    <p><em>connessioni persistenti</em></p>
                  </td>

                  <td width="25%" align="right" valign="top">
                    <p><em>totale file descriptor</em></p>
                  </td>
                </tr>

                <tr>
                  <td width="25%" align="center" valign="top">
                    <p>24</p>
                  </td>

                  <td width="25%" align="center" valign="top">
                    <p>20</p>
                  </td>

                  <td width="25%" align="center" valign="top">
                    <p>20*8</p>
                  </td>

                  <td width="25%" align="right" valign="top">
                    <p>160+24=184</p>
                  </td>
                </tr>

                <tr>
                  <td width="25%" align="center" valign="top">
                    <p>24</p>
                  </td>

                  <td width="25%" align="center" valign="top">
                    <p>50</p>
                  </td>

                  <td width="25%" align="center" valign="top">
                    <p>50*8</p>
                  </td>

                  <td width="25%" align="right" valign="top">
                    <p>400+24=424</p>
                  </td>
                </tr>

                <tr>
                  <td width="25%" align="center" valign="top">
                    <p>24</p>
                  </td>

                  <td width="25%" align="center" valign="top">
                    <p>100</p>
                  </td>

                  <td width="25%" align="center" valign="top">
                    <p>100*8</p>
                  </td>

                  <td width="25%" align="right" valign="top">
                    <p>800+24=824</p>
                  </td>
                </tr>

                <tr>
                  <td width="25%" align="center" valign="top">
                    <p>24</p>
                  </td>

                  <td width="25%" align="center" valign="top">
                    <p>200</p>
                  </td>

                  <td width="25%" align="center" valign="top">
                    <p>200*8</p>
                  </td>

                  <td width="25%" align="right" valign="top">
                    <p>1600+24=1624</p>
                  </td>
                </tr>

                <tr>
                  <td width="25%" align="center" valign="top">
                    <p>24</p>
                  </td>

                  <td width="25%" align="center" valign="top">
                    <p>400</p>
                  </td>

                  <td width="25%" align="center" valign="top">
                    <p>400*8</p>
                  </td>

                  <td width="25%" align="right" valign="top">
                    <p>3200+24=2324</p>
                  </td>
                </tr>

                <tr>
                  <td width="25%" align="center" valign="top">
                    <p>24</p>
                  </td>

                  <td width="25%" align="center" valign="top">
                    <p>500</p>
                  </td>

                  <td width="25%" align="center" valign="top">
                    <p>500*8</p>
                  </td>

                  <td width="25%" align="right" valign="top">
                    <p>4000+24=4024</p>
                  </td>
                </tr>
              </tbody>
            </table>
          </div>
          <br />
          <br />

          <p>Nell&#39;ipotesi pi&ugrave; pessimistica con la quale si
          prevede l&#39;apertura di 10 o pi&ugrave; <em>file
          descriptors</em> per connessione persistente, con 400 client
          concorrenti saranno necessari almeno 4096 <em>file
          descriptor</em>. Una buona configurazione pu&ograve; prevedere
          1024 <em>file descriptor</em>, tale impostazione pu&ograve;
          andare bene se si prevede un traffico medio. La tabella riportata
          in calce pu&ograve; essere utilizzata per dimensionare al meglio
          il nostro sistema di webcache, se desideriamo verificare il
          numero di <em>file descriptor</em> configurati per una versione
          pacchettizzata e preinstallata di Squid, possiamo determinare
          questo valore ricavandolo dal file <em>cache.log</em></p>

          <table border="0" bgcolor="#E0E0E0" width="100%">
            <tr>
              <td>
                <pre class="PROGRAMLISTING">
2004/04/03 13:08:29| With 1024 file descriptors available
   
</pre>
              </td>
            </tr>
          </table>

          <p>Squid pu&ograve; presentare dei problemi con i <em>file
          descriptor</em> nel momento in cui viene eseguito, anche in
          questo caso l&#39;avviso potr&agrave; essere rilevato dal file
          <em>cache.log</em></p>

          <table border="0" bgcolor="#E0E0E0" width="100%">
            <tr>
              <td>
                <pre class="PROGRAMLISTING">
2004/04/12 21:33:22| WARNING! Your cache is running out of file descriptors
   
</pre>
              </td>
            </tr>
          </table>

          <p>nel caso si dovesse presentare questo avviso di warning
          &egrave; necessario accrescere il limite dei <em>file
          descriptor</em>, la modalit&agrave; con cui &egrave; possibile
          variare il numero di file descriptor, come abbiamo visto
          precedentemente, &eacute; specifica per ogni Sistema
          Operativo.</p>

          <p>Il Cache Manager &egrave; un ottimo <a href=
          "#SEC-CACHE-MANAGER">strumento</a> per verificare
          l&#39;allocazione dei processi attivi per file descriptor</p>

          <table border="0" bgcolor="#E0E0E0" width="100%">
            <tr>
              <td>
                <pre class="PROGRAMLISTING">
Active file descriptors:
File Type   Tout Nread  * Nwrite * Remote Address        Description
---- ------ ---- -------- -------- --------------- ------------------------------
   3 Log       0       0        0                  /usr/local/squid/var/logs/cache.log
   4 Socket    0       0        0  .0              DNS Socket
   5 File      0       0     1177                  /usr/local/squid/var/logs/access.log
   6 Pipe      0       0        0                  unlinkd -&gt; squid
   7 File      0       0     1609                  /usr/local/squid/var/logs/store.log
   8 File      0       0        0                  /home/var/spool/squid/swap.state
   9 Pipe      0       0        0                  squid -&gt; unlinkd
  10 Socket 1440      70*       0  127.0.0.1.51740 cache_object://127.0.0.1/filedescriptors
  11 Socket    0       0*       0  .0              HTTP Socket
  12 Socket    0       0*       0  .0              ICP Socket
  13 Socket    0       0*       0  .0              HTCP Socket
  14 Socket    0       0*       0  .0              SNMP Port
   
</pre>
              </td>
            </tr>
          </table>
        </div>

        <div class="SECT2">
          <hr />

          <h3 class="SECT2"><a name="SUBSEC-FD-LINUX" id=
          "SUBSEC-FD-LINUX"></a>7.6.2. <em>File descriptor</em> con
          Linux</h3>

          <p>Il valore di default &egrave; <em>1024</em>, prima di
          configurare Squid &egrave; necessario digitare il comando
          <em>ulimit</em>(8), ulimit &egrave; un comando che fa parte della
          shell che stiamo utilizzando con il Sistema Operativo, il valore
          dei <em>file descriptor</em> deve essere inserito anche nello
          script che avvia Squid. Verifichiamo il numero di file descriptor
          disponibile sulla nostra piattaforma</p>

          <table border="0" bgcolor="#E0E0E0" width="100%">
            <tr>
              <td>
                <pre class="PROGRAMLISTING">
[root@klingon root]# ulimit -n
1024
   
</pre>
              </td>
            </tr>
          </table>

          <p>per modificare il valore dei file descriptor</p>

          <table border="0" bgcolor="#E0E0E0" width="100%">
            <tr>
              <td>
                <pre class="PROGRAMLISTING">
[root@klingon root]# ulimit -HSn <em>zzzz</em>
   
</pre>
              </td>
            </tr>
          </table>

          <p>oppure (Kernel 2.4)</p>

          <table border="0" bgcolor="#E0E0E0" width="100%">
            <tr>
              <td>
                <pre class="PROGRAMLISTING">
[root@portatilo root]# echo <em>zzzz</em> &gt; /proc/sys/fs/file-max
   
</pre>
              </td>
            </tr>
          </table>

          <p>dove <em>zzzz</em> &egrave; il numero di File Descriptors che
          si intendono utilizzare con Squid, assicurarsi di aver eseguito
          un &quot;make clean&quot; prima di compilare. Eseguire nuovamente
          il comando <em>configure</em>, dopo potremo compilare ed
          installare nuovamente Squid.</p>
        </div>

        <div class="SECT2">
          <hr />

          <h3 class="SECT2"><a name="SUBSEC-FD-SOLARIS" id=
          "SUBSEC-FD-SOLARIS"></a>7.6.3. <em>File descriptor</em> con
          Solaris</h3>

          <p>Il valore di default &egrave; <em>1024</em>, per impostare il
          numero di <em>File Descriptor</em> dovremo editare il file
          <em>/etc/system</em></p>

          <table border="0" bgcolor="#E0E0E0" width="100%">
            <tr>
              <td>
                <pre class="PROGRAMLISTING">
set rlim_fd_max = 4096
   
</pre>
              </td>
            </tr>
          </table>
        </div>

        <div class="SECT2">
          <hr />

          <h3 class="SECT2"><a name="SUBSEC-DF-FREEBSD" id=
          "SUBSEC-DF-FREEBSD"></a>7.6.4. <em>File descriptors</em> con
          FreeBSD</h3>

          <p>I nuovi Kernel di FreeBSD controllano dinamicamente il numero
          delle tabelle interne che vengono utilizzate dal sistema
          operativo, tale impostazione viene determinata prendendo come
          riferimento la quantit&agrave; di memoria fisicamente installata
          sul server. Il file di configurazione del Kernel di FreeBSD (e di
          molti sistemi BSD) si trova in
          <em>/usr/src/sys/i386/conf/GENERIC</em>, l&#39;impostazione che
          determina questo tipo di funzionamento &egrave;</p>

          <table border="0" bgcolor="#E0E0E0" width="100%">
            <tr>
              <td>
                <pre class="PROGRAMLISTING">
maxusers      0
   
</pre>
              </td>
            </tr>
          </table>

          <p>possiamo controllare il valore dei <em>file descriptor</em>
          attivi in un dato momento utilizzando il comand
          <em>sysctl</em>(8), le variabili del Kernel di un sistema FreeBSD
          possono essere visualizzate e modificiate utilizzando il comando
          <em>sysctl</em></p>

          <table border="0" bgcolor="#E0E0E0" width="100%">
            <tr>
              <td>
                <pre class="PROGRAMLISTING">
root@ns:/root&gt;# sysctl -a | grep kern.maxfiles
kern.maxfiles: 4040
kern.maxfilesperproc: 3636
   
</pre>
              </td>
            </tr>
          </table>

          <p>come nei sistemi GNU Linux possiamo utilizzare anche il
          comando <em>ulimit</em>(8)</p>

          <table border="0" bgcolor="#E0E0E0" width="100%">
            <tr>
              <td>
                <pre class="PROGRAMLISTING">
[root@klingon root]# ulimit -n
4040
   
</pre>
              </td>
            </tr>
          </table>

          <p>senza ricompilare il Kernel &egrave; dunque possibile
          impostare i valori corretti dei <em>file descriptor</em> al
          momento dell&#39;avviamento del sistema editando il file
          <em>/etc/sysctl.conf</em></p>

          <table border="0" bgcolor="#E0E0E0" width="100%">
            <tr>
              <td>
                <pre class="PROGRAMLISTING">
kern.maxfiles=4040
kern.maxfilesperproc=3636
   
</pre>
              </td>
            </tr>
          </table>

          <p>nei nuovi Kernel FreeBSD abbiamo visto che il numero di
          descrittori di file viene assegnato dinamicamente e non ha molto
          senso modificarlo manualmente.</p>
        </div>

        <div class="SECT2">
          <hr />

          <h3 class="SECT2"><a name="SUBSEC-FD-WINDOWS" id=
          "SUBSEC-FD-WINDOWS"></a>7.6.5. <em>File descriptors</em> con
          Windows</h3>

          <p>il numero massimo di file descriptor &egrave; 2048, questo
          valore &eacute; hard coded nella MSVCRT.DLL e non pu&ograve;
          essere modificato se non ricompilando la DLL stessa.</p>
        </div>

        <div class="SECT2">
          <hr />

          <h3 class="SECT2"><a name="SUBSEC-FILE-HANDLES-OS2" id=
          "SUBSEC-FILE-HANDLES-OS2"></a>7.6.6. <em>File handles</em> con
          OS/2</h3>

          <p>Se si utilizza il runtime EMX (The UN*X to OS/2-EMX Porting)
          &egrave; possibile definire il numero massimo di <em>file
          handles</em> modificando il file <em>config.sys</em></p>

          <table border="0" bgcolor="#E0E0E0" width="100%">
            <tr>
              <td>
                <pre class="PROGRAMLISTING">
SET EMXOPT=-h<em>#</em>
   
</pre>
              </td>
            </tr>
          </table>

          <p>questa impostazione fissa il limite massimo di <em>file
          handles</em> a <em>#</em>, il valore di <em>#</em> deve essere un
          numero compreso tra 10 e 65536, l&#39;ultima versione disponibile
          compilata con il runtime EMX supporta solo 256 <em>file
          handles</em>.</p>
        </div>
      </div>

      <div class="SECT1">
        <hr />

        <h2 class="SECT1"><a name="SEC-INSTALLARE-SQUID-SRC" id=
        "SEC-INSTALLARE-SQUID-SRC"></a>7.7. Installare Squid dai
        sorgenti</h2>

        <p>La lettura e la compresione di quanto scritto nei paragrafi
        precedenti &egrave; fondamentale per precedere con
        l&#39;installazione di Squid utilizzando il codice sorgente, di
        seguito spiegeremo in maniera dettagliata la procedura da
        seguire.</p>

        <div class="SECT2">
          <hr />

          <h3 class="SECT2"><a name="SUBSEC-PERCHE-INS-SQUID-SORGENTI" id=
          "SUBSEC-PERCHE-INS-SQUID-SORGENTI"></a>7.7.1. Perch&egrave;
          installare Squid dai sorgenti</h3>

          <p>Tra i principali vantaggi che possiamo ottenere installando
          Squid utilizzando la procedura di compilazione dei codici
          sorgenti citiamo</p>

          <ul>
            <li>
              <p>ottimizzare il codice binario di Squid per il processore
              specifico in uso nel nostro sistema</p>
            </li>

            <li>
              <p>modificare il limite massimo di <em>File Descriptors</em>
              utilizzabili</p>
            </li>

            <li>
              <p>ottimizzare le performance anche relativamente al tipo di
              Disk Storage utilizzato</p>
            </li>

            <li>
              <p>scegliere le opzioni di configurazione realmente
              necessarie alla nostre esigenze</p>

              <p>WCCP, i delay pools, il tipo di autenticazione, HTCP, il
              supporto ICMP ed il tipo di Disk Storage sono le opzioni di
              configurazione maggiormente utilizzate</p>
            </li>

            <li>
              <p>non tutti i package precompilati di Squid offrono le
              opzioni potenzialmente disponibili nella versione che viene
              compilata utilizzando i codici sorgenti</p>
            </li>
          </ul>

          <p>possiamo quindi affermare che &egrave; possibile realizzare
          delle appliance vere e proprie compilando prima il Kernel del
          Sistema Operativo e successivamente la nostra webcache Squid.
          Solo in questo modo potremo ottenere un sistema di webcache
          performante e leggero.</p>
        </div>

        <div class="SECT2">
          <hr />

          <h3 class="SECT2"><a name="SUBSEC-INSTALLA-COMANDI-IMPORTANTI"
          id="SUBSEC-INSTALLA-COMANDI-IMPORTANTI"></a>7.7.2. I comandi
          pi&ugrave; importanti</h3>

          <p>Dopo aver configurato nella maniera pi&ugrave; opportuna Squid
          con il comando <a href=
          "#SUBSEC-OPZIONI-DI-CONFIGURE">configure</a> potremmo finalmente
          compilare utilizzando il comando <em>make</em>(8)</p>

          <table border="0" bgcolor="#E0E0E0" width="100%">
            <tr>
              <td>
                <pre class="PROGRAMLISTING">
[root@portatilo squid-2.5.STABLE5]# make
   
</pre>
              </td>
            </tr>
          </table>

          <p>procediamo con l&#39;installazione utilizzando il comando
          <em>make install</em></p>

          <table border="0" bgcolor="#E0E0E0" width="100%">
            <tr>
              <td>
                <pre class="PROGRAMLISTING">
[root@portatilo squid-2.5.STABLE5]# make install
   
</pre>
              </td>
            </tr>
          </table>
        </div>

        <div class="SECT2">
          <hr />

          <h3 class="SECT2"><a name="SUBSEC-ALBERO-DIRECTORY-MAKEINSTALL"
          id="SUBSEC-ALBERO-DIRECTORY-MAKEINSTALL"></a>7.7.3. L&#39;albero
          delle directory</h3>

          <p>vediamo ora l&#39;albero delle directory per gli eseguibili ed
          i files di configurazione di Squid che sono stati generati dal
          comando <em>make install</em></p>

          <table border="0" bgcolor="#E0E0E0" width="100%">
            <tr>
              <td>
                <pre class="PROGRAMLISTING">
[root@portatilo root]# ls /usr/local/squid/
totale 28
drwxr-xr-x    2 root     root         4096 apr 10 12:26 bin
drwxr-xr-x    2 root     root         4096 apr 10 12:16 etc
drwxr-xr-x    2 root     root         4096 apr 10 12:26 libexec
drwxr-xr-x    3 root     root         4096 apr  3 12:40 man
drwxr-xr-x    2 root     root         4096 apr 10 12:26 sbin
drwxr-xr-x    4 root     root         4096 apr 10 12:16 share
drwxr-xr-x    5 root     root         4096 apr  3 13:01 var
   
</pre>
              </td>
            </tr>
          </table>
        </div>

        <div class="SECT2">
          <hr />

          <h3 class="SECT2"><a name="SUBSEC-PULIRE-GLI-ESEGUIBILI" id=
          "SUBSEC-PULIRE-GLI-ESEGUIBILI"></a>7.7.4. Pulire gli eseguibili
          dalle informazioni di debug</h3>

          <p>Il comando <em>make install</em> genera degli eseguibili
          mostruosamente grandi, se invece si desidera installare degli
          eseguibili puliti, senza alcuna informazione di debug, &eacute;
          possibile utilizzare il comando <em>make install-strip</em>.
          Ricordiamo agli utenti che questo comando pu&ograve; essere
          eseguito soltanto dall&#39;interno della directory contenete i
          sorgenti di Squid</p>

          <table border="0" bgcolor="#E0E0E0" width="100%">
            <tr>
              <td>
                <pre class="PROGRAMLISTING">
[root@portatilo squid-2.5.STABLE5]# make &amp;&amp; make install
[root@portatilo squid-2.5.STABLE5]# cd src/
[root@portatilo src ]# make install-strip
   
</pre>
              </td>
            </tr>
          </table>

          <p>per rimuovere le informazioni di debug dagli eseguibili
          potremmo anche utilizzare il comando <em>strip(8)</em>. Questo
          comando elimina le informazioni di debug dagli object files
          scartando automaticamente gli oggetti non riconosciuti come
          eseguibili</p>

          <table border="0" bgcolor="#E0E0E0" width="100%">
            <tr>
              <td>
                <pre class="PROGRAMLISTING">
[root@portatilo src]# strip -s /usr/local/squid/bin/* /usr/local/squid/sbin/* \
/usr/local/squid/libexec/*
strip: /usr/local/squid/bin/RunAccel: File format not recognized
strip: /usr/local/squid/bin/RunCache: File format not recognized
strip: /usr/local/squid/libexec/wbinfo_group.pl: File format not recognized
   
</pre>
              </td>
            </tr>
          </table>
        </div>

        <div class="SECT2">
          <hr />

          <h3 class="SECT2"><a name="SUBSEC-INFO-INSTALLARE-DA-SORGENTI"
          id="SUBSEC-INFO-INSTALLARE-DA-SORGENTI"></a>7.7.5. Altre
          informazioni per installare correttamente Squid dai sorgenti</h3>

          <p>nel caso in cui con le opzioni di configurazione sia stato
          attivato il supporto ICMP, &egrave; necessario installare anche
          l&#39;helper <em>pinger</em> con il comando</p>

          <table border="0" bgcolor="#E0E0E0" width="100%">
            <tr>
              <td>
                <pre class="PROGRAMLISTING">
[root@portatilo squid-2.5.STABLE5]# make install-pinger
   
</pre>
              </td>
            </tr>
          </table>

          <p>consigliamo sempre di generare una directory dedicata al file
          che identifica il numero di processo (<em>squid.pid</em>) e
          assegnare subito dopo i permessi per consentire l&#39;esecuzione
          dei processi disk I/O. Nell&#39;esempio seguente la UID nobody
          eseguir&agrave; il processo Squid</p>

          <table border="0" bgcolor="#E0E0E0" width="100%">
            <tr>
              <td>
                <pre class="PROGRAMLISTING">
[root@portatilo root]# mkdir /usr/local/squid/var/run
[root@portatilo root]# chown -R nobody:nobody /usr/local/squid/var/*
   
</pre>
              </td>
            </tr>
          </table>

          <p>&egrave; ora possibile editare e customizzare il file
          <em>squid.conf</em> che nell&#39;installazione di default viene
          memorizzato in</p>

          <table border="0" bgcolor="#E0E0E0" width="100%">
            <tr>
              <td>
                <pre class="PROGRAMLISTING">
/usr/local/squid/etc/squid.conf
   
</pre>
              </td>
            </tr>
          </table>

          <p>una guida di avviamento rapido viene sempre inclusa con la
          distribuzione dei sorgenti di Squid</p>
        </div>
      </div>

      <div class="SECT1">
        <hr />

        <h2 class="SECT1"><a name="SEC-PACCHETTI-PRECOMPILATI" id=
        "SEC-PACCHETTI-PRECOMPILATI"></a>7.8. Disponibilit&agrave; di
        pacchetti precompilati</h2>

        <p>Come abbiamo detto, sono molti gli amministratori di Sistema che
        <em>non</em> utilizzano le versioni di Squid precompilate, questi
        infatti ritengono che la compilazione del codice sorgente su una
        specifica piattaforma, consenta di ottenere particolari
        ottimizzazioni e performance superiori alle media. Per verificare
        l&#39;esistenza di package precompilati si faccia riferimento ai
        siti internet legati in qualche modo con le piattaforme
        specifiche.</p>

        <div class="SECT2">
          <hr />

          <h3 class="SECT2"><a name="SUBSEC-PACKAGE-AMBIENTI-UNIX" id=
          "SUBSEC-PACKAGE-AMBIENTI-UNIX"></a>7.8.1. Package per i vari
          ambienti UNIX&reg;</h3>

          <p>Vediamo ora alcune delle URLs dalle quali &egrave; possibile
          prelevare i package per le piattaforme SGI IRIX, FreeBSD, NetBSD,
          Sun Solaris e Linux</p>

          <ul>
            <li>
              <p>Il sito <a href="http://freeware.sgi.com/" target=
              "_top">Freeware della SGI</a> fornisce delle versioni
              precompilate di Squid per la piattaforma SGI IRIX</p>
            </li>

            <li>
              <p>I package di Squid sono disponibili per il Sistema
              Operativo <a href=
              "http://www.freebsd.org/cgi/ports.cgi?query=squid-2&amp;stype=all"
                 target="_top">FreeBSD</a> per le piattaforme Alpha, AMD64
                 ed IA32</p>

              <p>consigliamo comunque di compilare Squid sulla piattaforma
              specifica utilizzando l&#39;albero dei <em>ports</em> di
              FreeBSD, tale procedura implica la compilazione del codice
              sorgente incluse le eventuali patch relative alla
              piattaforma</p>
            </li>

            <li>
              <p>Sono disponibili i binari di Squid per qualsiasi
              piattaforma supportata dal sistema Operativo <a href=
              "ftp://ftp.netbsd.org/pub/NetBSD/packages/pkgsrc/www/squid/README.html"
                 target="_top">NetBSD</a></p>
            </li>

            <li>
              <p>Gurkan Sengun rende disponibili le versioni binarie di
              Squid per il Sistema Operativo <a href=
              "http://www.linuks.mine.nu/solaris/" target="_top">Sun
              Solaris</a> su piattaforma Sparc</p>
            </li>

            <li>
              <p>tutte le pi&ugrave; importanti distribuzioni di GNU Linux
              forniscono le versioni precompilate di Squid</p>

              <p>i package per le distribuzioni RedHat Linux a partire
              dalla versione 6.2 sino alla versione 7.3 (attualmente non
              pi&ugrave; supportate dalla RedHat) sono disponibili alla
              URLs: <a href=
              "http://www.swelltech.com/support/squidpackages.html" target=
              "_top">http://www.swelltech.com/support/squidpackages.html</a></p>
            </li>
          </ul>

          <p>In merito ai pacchetti precompilati per le altre distribuzioni
          GNU Linux, &egrave; necessario fare riferimento alla home page
          della distribuzione che state utilizzando.</p>
        </div>

        <div class="SECT2">
          <hr />

          <h3 class="SECT2"><a name="SUBSEC-PACKAGE-WIN32-OS2" id=
          "SUBSEC-PACKAGE-WIN32-OS2"></a>7.8.2. Package per Win32 ed
          OS/2</h3>

          <p>Di seguito si forniscono le URLs dalle quali &egrave;
          possibile prelevare i package per le piattaforme Windows ed
          OS/2</p>

          <ul>
            <li>
              <p>per la piattaforma Win32 riferirsi alla URLs: <a href=
              "http://www.acmeconsulting.it/SquidNT/" target=
              "_top">http://www.acmeconsulting.it/SquidNT/</a></p>
            </li>

            <li>
              <p>per la piattaforma OS/2 riferirsi alla URLs: <a href=
              "ftp://hobbes.nmsu.edu/pub/os2/apps/internet/www/server"
              target=
              "_top">ftp://hobbes.nmsu.edu/pub/os2/apps/internet/www/server</a></p>
            </li>

            <li>
              <p>per la piattaforma OS/2 e la versione nativa VACPP
              riferirsi alla URLs: <a href=
              "http://www.laser.ru/evgen/soft/Squid2/index_l.html" target=
              "_top">http://www.laser.ru/evgen/soft/Squid2/index_l.html</a></p>
            </li>
          </ul>
        </div>
      </div>
    </div>

    <div class="CHAPTER">
      <hr />

      <h1><a name="CHA-POSTINSTALLAZIONE" id=
      "CHA-POSTINSTALLAZIONE"></a>Capitolo 8. Postinstallazione</h1>

      <div class="SECT1">
        <h2 class="SECT1"><a name="SEC-POSTINSTALLAZIONE-PRELIMINARI" id=
        "SEC-POSTINSTALLAZIONE-PRELIMINARI"></a>8.1. Preliminari</h2>

        <p>Alcuni files ed alcune directory devono essere scrivibili da
        parte del processo Squid, per problemi legati alla sicurezza, Squid
        non pu&ograve; essere eseguito come <em>root</em>. Tra queste
        directory includiamo quella che contiene i files di log e la
        directory di cache, come valore di default queste directory
        sono</p>

        <table border="0" bgcolor="#E0E0E0" width="100%">
          <tr>
            <td>
              <pre class="PROGRAMLISTING">
/usr/local/squid/var/logs
/usr/local/squid/var/cache
  
</pre>
            </td>
          </tr>
        </table>

        <p>assumiamo che si utilizzi l&#39;utente <em>nobody</em> per
        eseguire Squid, dopo aver compilato ed installato Squid dovremmo
        utilizzare alcuni comandi UNIX&reg; per settare i permessi corretti
        per le directory che contengono i files di log e la cache</p>

        <table border="0" bgcolor="#E0E0E0" width="100%">
          <tr>
            <td>
              <pre class="PROGRAMLISTING">
[root@portatilo root]# chown -R nobody:nobody /usr/local/squid/var/logs
[root@portatilo root]# chown -R nobody:nobody /usr/local/squid/var/cache
  
</pre>
            </td>
          </tr>
        </table>

        <p>successivamente dovremmo editare e customizzare il file di
        configurazione di Squid, <em>squid.conf</em>. Come valore di
        default questo file viene ubicato in</p>

        <table border="0" bgcolor="#E0E0E0" width="100%">
          <tr>
            <td>
              <pre class="PROGRAMLISTING">
/usr/local/squid/etc/squid.conf
  
</pre>
            </td>
          </tr>
        </table>

        <p>ora possiamo procedere con l&#39;inizializzazione delle cache
        directory utilizzando il comando</p>

        <table border="0" bgcolor="#E0E0E0" width="100%">
          <tr>
            <td>
              <pre class="PROGRAMLISTING">
[root@portatilo root# /usr/local/squid/sbin/squid -z
  
</pre>
            </td>
          </tr>
        </table>

        <p>una guida di avviamento rapido viene sempre inclusa con la
        distribuzione dei sorgenti. A seguire tratteremo una lista di TAG
        che sono contenuti nel file <em>squid.conf</em> e che sono
        necessari per configurare correttamente Squid. Si consiglia agli
        utenti di effettuare <em>sempre</em> una copia di backup del file
        <em>squid.conf</em> prima di dare corso a qualsiasi tipo di
        modifica</p>

        <ul>
          <li>
            <p>il file da editare per una configurazione standard da noi
            compilata &egrave;</p>

            <table border="0" bgcolor="#E0E0E0" width="90%">
              <tr>
                <td>
                  <pre class="PROGRAMLISTING">
/usr/local/squid/etc/squid.conf
   
</pre>
                </td>
              </tr>
            </table>
          </li>

          <li>
            <p>il file da editare per la configurazione OS/2 &egrave;</p>

            <table border="0" bgcolor="#E0E0E0" width="90%">
              <tr>
                <td>
                  <pre class="PROGRAMLISTING">
c:\squid\etc\squid.conf
   
</pre>
                </td>
              </tr>
            </table>
          </li>

          <li>
            <p>il file da editare per la configurazione Red Hat Linux
            (unsupported) e Fedora Core &egrave;</p>

            <table border="0" bgcolor="#E0E0E0" width="90%">
              <tr>
                <td>
                  <pre class="PROGRAMLISTING">
/etc/squid/squid.conf<em> </em>
   
</pre>
                </td>
              </tr>
            </table>
          </li>

          <li>
            <p>il file da editare per la configurazione FreeBSD 4.9-STABLE
            &egrave;</p>

            <table border="0" bgcolor="#E0E0E0" width="90%">
              <tr>
                <td>
                  <pre class="PROGRAMLISTING">
/usr/local/etc/squid/squid.conf
   
</pre>
                </td>
              </tr>
            </table>
          </li>

          <li>
            <p>il file da editare per la configurazione Windows
            &egrave;</p>

            <table border="0" bgcolor="#E0E0E0" width="90%">
              <tr>
                <td>
                  <pre class="PROGRAMLISTING">
c:\squid\etc\squid.conf
   
</pre>
                </td>
              </tr>
            </table>
          </li>
        </ul>
      </div>

      <div class="SECT1">
        <hr />

        <h2 class="SECT1"><a name="SEC-OPZIONI-DI-RETE" id=
        "SEC-OPZIONI-DI-RETE"></a>8.2. Opzioni di rete</h2>

        <p>Squid &egrave; un server che per offrire il servizio deve
        rimanere in ascolto di eventuali richieste su una porta specifica,
        &egrave; dunque fondamentale definire le porte sulle quali
        rimarr&agrave; in ascolto il proxy server</p>

        <p>il TAG <em>http_port</em> per il protocollo HTTP</p>

        <table border="0" bgcolor="#E0E0E0" width="100%">
          <tr>
            <td>
              <pre class="PROGRAMLISTING">
http_port 3128
  
</pre>
            </td>
          </tr>
        </table>

        <p>il TAG <em>icp_port</em> per il protocollo ICP</p>

        <table border="0" bgcolor="#E0E0E0" width="100%">
          <tr>
            <td>
              <pre class="PROGRAMLISTING">
icp_port 3130 
  
</pre>
            </td>
          </tr>
        </table>

        <p>questi TAG definiscono i numeri di porta che verranno utilizzati
        da Squid per rimanere in ascolto delle eventuali richieste che
        verranno effettuate da parte dei client, sia per quanto riguarda il
        protocollo <em><a href=
        "#SEC-UNA-PICCOLA-PANORAMICA-SU-HTTP">HTTP</a></em> che il
        protocollo <em><a href="#SEC-INTERNET-CACHE-PROTOCOL">ICP</a></em>
        (Internet Cache Protocol).</p>

        <table border="0" bgcolor="#E0E0E0" width="100%">
          <tr>
            <td>
              <pre class="PROGRAMLISTING">
http_port 1.2.3.4:3128
http_port 1.2.3.5:8080
  
</pre>
            </td>
          </tr>
        </table>

        <p>nel caso si esegua Squid su un Sistema del tipo dual-homed che
        prevede una interfaccia di rete interna (inside) ed una interfaccia
        di rete esterna (outside), &egrave; raccomandabile specificare
        sempre l&#39;indirizzo IP assegnato all&#39;interfaccia di rete
        interna. Questo tipo di configurazione consente a Squid di essere
        raggiungibile unicamente dalle subnet presenti sulla rete
        interna.</p>

        <p>A partire dalla versione 2.3 di Squid, &egrave; possibile
        specificare diversi TAG <em>http_port</em>, definendo con
        un&#39;unico comando, diverse porte sulle quali Squid rimane in
        ascolto di eventuali richieste.</p>
      </div>

      <div class="SECT1">
        <hr />

        <h2 class="SECT1"><a name="SEC-OPZ-CHE-DEF-CACHE-GERAR" id=
        "SEC-OPZ-CHE-DEF-CACHE-GERAR"></a>8.3. Opzioni che definiscono una
        cache gerarchica</h2>

        <p>Possiamo utilizzare un&#39;altro proxy server come cache di
        appoggio ricorrendo al protocollo <em>Internet Cache Protocol</em>
        (<a href="#SEC-INTERNET-CACHE-PROTOCOL">ICP</a>) e al concetto
        delle cache gerarchiche</p>

        <p>il TAG <em>cache_peer</em></p>

        <table border="0" bgcolor="#E0E0E0" width="100%">
          <tr>
            <td>
              <pre class="PROGRAMLISTING">
cache_peer [proxy.domain.com] [type] [port] [port]
  
</pre>
            </td>
          </tr>
        </table>

        <p>pu&ograve; essere utilizzato nel caso si disponga di un proxy
        server esterno sul quale appoggiarsi come quello del Vostro
        Provider Internet. L&#39;istruzione <em>proxy.domain.com</em>
        identifica il nome di un host all&#39;interno di un dominio
        qualificato (fqdn) o l&#39;indirizzo internet del proxy genitore,
        l&#39;istruzione <em>type</em> invece definisce il grado di
        parentela che pu&ograve; essere uguale a <em>sibling</em> (fratello
        germano) o a <em>parent</em> (genitore). Per finire
        l&#39;istruzione <em>port</em> identifica il numero di porta sulla
        quale rimane in ascolto il proxy parente al quale desideriamo
        appoggiarci, la prima istruzione <em>port</em> identifica la porta
        sulla quale il proxy rimane in ascolto a riguardo del protocollo
        <em>TCP</em>, la seconda istruzione <em>port</em> &egrave; quella
        dedicata al protocollo <em>ICP</em>. Ecco un esempio completo</p>

        <table border="0" bgcolor="#E0E0E0" width="100%">
          <tr>
            <td>
              <pre class="PROGRAMLISTING">
cache_peer proxy.merlinobbs.net sibling 3128 0
  
</pre>
            </td>
          </tr>
        </table>
      </div>

      <div class="SECT1">
        <hr />

        <h2 class="SECT1"><a name="SEC-OPZIONI-FILES-LOG" id=
        "SEC-OPZIONI-FILES-LOG"></a>8.4. Files di log, memoria e cache</h2>

        <p>I log sono una fonte importante di informazioni relative alle
        attivit&agrave; svolte da Squid e consentono di misurare le
        prestazioni del nostro proxy server. I log di sistema registrano
        non soltanto le informazioni relative all&#39;accesso, ma anche gli
        eventuali errori di configurazione del sistema ed il consumo delle
        risorse, come la memoria e lo spazio su disco. Alcuni file di log
        devono essere attivati in maniera esplicit&agrave; durante la
        compilazione di Squid, atri possono essere disattivati durante
        l&#39;esecuzione del processo Squid, il linea di principio nessuno
        dei files di log deve essere cancellato quando il Squid &egrave; in
        esecuzione.</p>

        <div class="SECT2">
          <hr />

          <h3 class="SECT2"><a name="SUBSEC-FILES-DI-LOG-PRINCIPALI" id=
          "SUBSEC-FILES-DI-LOG-PRINCIPALI"></a>8.4.1. Files di log
          principali</h3>

          <p>vediamo ora come sia possibile gestire i files di log di
          Squid, i TAG pi&ugrave; importanti relativi all&#39;attivazione
          dei files di log all&#39;interno del file <em>squid.conf</em>
          sono</p>

          <p>il TAG <em>cache_access_log</em></p>

          <table border="0" bgcolor="#E0E0E0" width="100%">
            <tr>
              <td>
                <pre class="PROGRAMLISTING">
cache_access_log /usr/local/squid/var/logs/access.log
   
</pre>
              </td>
            </tr>
          </table>

          <p>nel file <em>access.log</em> vengono registrate tutte le
          transazioni effettuate dai client, vedremo in seguito ulteriori
          informazioni</p>

          <p>il TAG <em>cache_log</em></p>

          <table border="0" bgcolor="#E0E0E0" width="100%">
            <tr>
              <td>
                <pre class="PROGRAMLISTING">
cache_log /usr/local/squid/var/logs/cache.log
   
</pre>
              </td>
            </tr>
          </table>

          <p>nel file <em>cache.log</em> vengono registrate tutte le
          informazioni sullo stato della cache, vedremo in seguito
          ulteriori <a href="#SEC-IL-FILE-CACHE.LOG">informazioni</a></p>

          <p>il TAG <em>cache_store_log</em></p>

          <table border="0" bgcolor="#E0E0E0" width="100%">
            <tr>
              <td>
                <pre class="PROGRAMLISTING">
cache_store_log /usr/local/squid/var/logs/store.log 
   
</pre>
              </td>
            </tr>
          </table>

          <p>nel file <em>store.log</em> vengono registrate tutte le
          attivit&agrave; eseguite dallo storage manager di Squid, vedremo
          in seguito ulteriori informazioni</p>

          <p>il TAG <em>cache_swap_log</em></p>

          <table border="0" bgcolor="#E0E0E0" width="100%">
            <tr>
              <td>
                <pre class="PROGRAMLISTING">
cache_swap_log /usr/local/squid/var/cache/swap.state
   
</pre>
              </td>
            </tr>
          </table>

          <p>nel file <em>swap.state</em> viene memorizzato il file di log
          dello swap, si tratta di un file binario che include un checksum
          MD5 e che contiene i campi dello store entry. Non &egrave;
          necessario indicarlo in <em>squid.conf</em> in quanto
          verr&agrave; scritto automaticamente nella top level directory
          della <em>cache_dir</em></p>
        </div>

        <div class="SECT2">
          <hr />

          <h3 class="SECT2"><a name="SUBSEC-FILES-DI-LOG-ACCESSORI" id=
          "SUBSEC-FILES-DI-LOG-ACCESSORI"></a>8.4.2. Files di log
          accessori</h3>

          <p>vi sono anche alcune opzioni relative ad alcuni files di log
          che devono essere esplicitamente compilate per essere supportate
          attivamente da Squid proxy server</p>

          <p>il TAG <em>useragent_log</em></p>

          <table border="0" bgcolor="#E0E0E0" width="100%">
            <tr>
              <td>
                <pre class="PROGRAMLISTING">
useragent_log /usr/local/squid/var/logs/useragent.log
   
</pre>
              </td>
            </tr>
          </table>

          <p>nel file <em>useragent.log</em> viene registrato il campo
          <em>user-agent</em> per ogni richiesta HTTP. Questa opzione
          &egrave; disponibile solo se Squid viene compilato con
          l&#39;opzione di configure</p>

          <table border="0" bgcolor="#E0E0E0" width="100%">
            <tr>
              <td>
                <pre class="PROGRAMLISTING">
#./configure --enable-useragent-log
   
</pre>
              </td>
            </tr>
          </table>

          <p>questa opzione &egrave; utile per generare dei report sulle
          tipologie dei browser utilizzati dagli utenti e viene
          disabilitata di default</p>

          <p>il TAG <em>referer_log</em></p>

          <table border="0" bgcolor="#E0E0E0" width="100%">
            <tr>
              <td>
                <pre class="PROGRAMLISTING">
referer_log /usr/local/squid/var/logs/referer.log
   
</pre>
              </td>
            </tr>
          </table>

          <p>nel file <em>referer.log</em> viene registrato il campo
          <em>referer</em> per ogni richiesta HTTP. Questa opzione &egrave;
          disponibile solo se Squid viene compilato con l&#39;opzione di
          configure</p>

          <table border="0" bgcolor="#E0E0E0" width="100%">
            <tr>
              <td>
                <pre class="PROGRAMLISTING">
#./configure --enable-referer-log
   
</pre>
              </td>
            </tr>
          </table>

          <p>questa opzione &egrave; utile per generare dei report sui link
          esterni ed i vari motori di ricerca, viene disabiliata di
          default.</p>
        </div>

        <div class="SECT2">
          <hr />

          <h3 class="SECT2"><a name="SUBSEC-FORMATI-FILES-LOG" id=
          "SUBSEC-FORMATI-FILES-LOG"></a>8.4.3. Formati dei files di
          log</h3>

          <p>In fase di configurazione possiamo anche definire il formato
          dei files di logs, tale formato pu&ograve; essere suddiviso in
          file di log nativi ed in file di log che emulano lo schema
          transazionale di un server web, il TAG da utilizzare &egrave;
          <em>emulate_httpd_log [on|off]</em> il cui valore di default
          &egrave; <em>off</em></p>

          <table border="0" bgcolor="#E0E0E0" width="100%">
            <tr>
              <td>
                <pre class="PROGRAMLISTING">
emulate_httpd_log on 
   
</pre>
              </td>
            </tr>
          </table>

          <p>in questo esempio emuliamo il file di log di un server web,
          questa funzionalit&agrave; pu&ograve; essere utile nel caso in
          cui si decida di utilizzare il proxy server con
          funzionalit&agrave; di <a href="#CHA-REVERSE-PROXY">Reverse
          Proxy</a>.</p>
        </div>

        <div class="SECT2">
          <hr />

          <h3 class="SECT2"><a name="SUBSEC-RUOTARE-I-FILES-LOG" id=
          "SUBSEC-RUOTARE-I-FILES-LOG"></a>8.4.4. Ruotare i files di
          log</h3>

          <p>con il TAG <em>logfile_rotate</em> &egrave; possibile
          specificare il numero massimo di rotazione per un file di log</p>

          <table border="0" bgcolor="#E0E0E0" width="100%">
            <tr>
              <td>
                <pre class="PROGRAMLISTING">
logfile_rotate 10
   
</pre>
              </td>
            </tr>
          </table>

          <p>la rotazione dei file di log pu&ograve; essere effettuata con
          il comando</p>

          <table border="0" bgcolor="#E0E0E0" width="100%">
            <tr>
              <td>
                <pre class="PROGRAMLISTING">
# squid -k rotate
   
</pre>
              </td>
            </tr>
          </table>

          <p>i comando <em>squid -k rotate</em> invia un segnale
          <em>USR1</em> al processo Squid, viene utilizzato per ruotare dei
          file di log di dimensioni notevoli (Linux con ext2 non supporta
          files che superano 2 GB). Il processo di rotazione chiude un
          file, lo rinomina ed apre un nuovo file di log. E&#39; prassi
          inserire questo comando nella tabella di
          <em>crontab</em>(8)<a name="AEN1535" href="#FTN.AEN1535" id=
          "AEN1535">[15]</a> del sistema (file <em>/etc/crontab</em>) per
          ruotare automaticamente i log di Squid, nell&#39;esempio seguente
          prevediamo una rotazione ogni mese alle ore 01:01</p>

          <table border="0" bgcolor="#E0E0E0" width="100%">
            <tr>
              <td>
                <pre class="PROGRAMLISTING">
01 1 * 1 * /usr/local/squid/sbin/squid -k rotate
   
</pre>
              </td>
            </tr>
          </table>

          <p>il valore di default per il TAG <em>logfile_rotate</em>
          &egrave; 10, impostando questo valore i file di log verranno
          ruotati e gli verr&agrave; assegnata una estensione che va da 0 a
          9. Il file <em>cache.log</em> diverr&agrave;
          <em>cache.log.0</em>, ed ancora <em>cache.log.0</em>
          diverr&agrave; <em>cache.log.1</em>, successivamente
          <em>cache.log.1</em> diverr&agrave; <em>cache.log.2</em> e
          cos&igrave; via. La rotazione dei files di log riguarder&agrave;
          anche il file <em>swap.state</em></p>

          <table border="0" bgcolor="#E0E0E0" width="100%">
            <tr>
              <td>
                <pre class="PROGRAMLISTING">
logfile_rotate 0
   
</pre>
              </td>
            </tr>
          </table>

          <p>Impostando il TAG <em>logfile_rotate 0</em> verr&agrave;
          disabilitata la rotazione dei file di log.</p>
        </div>

        <div class="SECT2">
          <hr />

          <h3 class="SECT2"><a name="SUB-SEC-DISABILITARE-FILES-LOG" id=
          "SUB-SEC-DISABILITARE-FILES-LOG"></a>8.4.5. Disabilitare i files
          di log</h3>

          <p>se si persegue l&#39;obiettivo delle prestazioni &egrave;
          possibile disabilitare totalmente o parzialmente il sistema di
          logging ricorrendo ad alcuni TAG nel file <em>squid.conf</em></p>

          <p>ecco un esempio valido per squid-2.4</p>

          <table border="0" bgcolor="#E0E0E0" width="100%">
            <tr>
              <td>
                <pre class="PROGRAMLISTING">
cache_access_log /dev/null
cache_store_log none
cache_log /dev/null
   
</pre>
              </td>
            </tr>
          </table>

          <p>se invece utilizzate squid-2.5</p>

          <table border="0" bgcolor="#E0E0E0" width="100%">
            <tr>
              <td>
                <pre class="PROGRAMLISTING">
cache_access_log none
cache_store_log none
cache_log /dev/null
useragent_log none 
referer_log none 
   
</pre>
              </td>
            </tr>
          </table>

          <p>&egrave; decisamente una cattiva idea disabilitare il file
          <em>cache.log</em>, questo file contiene diversi messaggi sullo
          stato di funzionamento di Squid ed altri messaggi per il
          debugging. Se viene specificato il percorso <em>/dev/null</em>
          per disabilitare il logging di Squid, &egrave; necessario
          impostare il TAG <em>logfile_rotate 0</em>. Disabilitando il
          logging &egrave; anche possibile migliorare le performance del
          disk I/O, in seguito vedremo come sia possibile creare un proxy
          server <a href="#SEC-WEBCACHING-ANONIMO">anonimizzante</a>.</p>
        </div>

        <div class="SECT2">
          <hr />

          <h3 class="SECT2"><a name="SUBSEC-MIME-TIPE-E-PIDFILE" id=
          "SUBSEC-MIME-TIPE-E-PIDFILE"></a>8.4.6. Mime tipe e file di
          processo</h3>

          <p>&egrave; anche previsto un TAG che consente di definire un
          file che identifichi la tabella dei <em>mime type<a name=
          "AEN1570" href="#FTN.AEN1570" id="AEN1570">[16]</a></em></p>

          <p>il TAG <em>mime_table</em></p>

          <table border="0" bgcolor="#E0E0E0" width="100%">
            <tr>
              <td>
                <pre class="PROGRAMLISTING">
mime_table /usr/local/squid/etc/mime.conf 
   
</pre>
              </td>
            </tr>
          </table>

          <p>questa tabella contiene gli esempi standard di <em>mime
          type</em> nella loro formattazione pi&ugrave; comune</p>

          <p>il TAG <em>pid_filename</em></p>

          <table border="0" bgcolor="#E0E0E0" width="100%">
            <tr>
              <td>
                <pre class="PROGRAMLISTING">
pid_filename /usr/local/squid/var/run/squid.pid 
   
</pre>
              </td>
            </tr>
          </table>

          <p>questo TAG identifica il nome del file che contiene il numero
          di processo che viene attivato da Squid con il suo
          avviamento.</p>
        </div>

        <div class="SECT2">
          <hr />

          <h3 class="SECT2"><a name="SUBSEC-MEMORIA-E-CACHE-DIR" id=
          "SUBSEC-MEMORIA-E-CACHE-DIR"></a>8.4.7. Memoria e
          <em>cache_dir</em></h3>

          <p>il TAG <em>cache_mem</em> consente di impostare la
          quantit&agrave; di memoria RAM massima che potr&agrave; essere
          utilizzata dal processo Squid</p>

          <table border="0" bgcolor="#E0E0E0" width="100%">
            <tr>
              <td>
                <pre class="PROGRAMLISTING">
cache_mem 64 MB 
   
</pre>
              </td>
            </tr>
          </table>

          <p>questo TAG non dovrebbe mai superare 1/4 della memoria fisica
          installata sul sistema, vedremo i dettagli in <a href=
          "#CHA-IL-CACHE-STORE">seguito</a>. Non dimentichiamo che &egrave;
          possibile utilizzare anche il TAG <em>high_memory_warning</em>
          per tenere sotto controllo l&#39;utilizzo della memoria</p>

          <table border="0" bgcolor="#E0E0E0" width="100%">
            <tr>
              <td>
                <pre class="PROGRAMLISTING">
high_memory_warning 80 MB
   
</pre>
              </td>
            </tr>
          </table>

          <p>se l&#39;utilizzo della memoria supera i valori da noi
          impostati, Squid registra un WARNING nel file <em>cache.log</em>
          anche se il TAG <em>debug level</em> &egrave; impostato a
          <em>0</em>.</p>

          <p><em>ufs</em> &egrave; il tipo di Disk Storage che viene
          utilizzato storicamente da Squid, come vedremo <a href=
          "#CHA-IL-CACHE-STORE">successivamente</a> &egrave; proprio questo
          il sistema che si occupa di gestire il processo di disk-I/O. Il
          TAG <em>cache_dir</em> definisce il percorso su disco dove
          verr&agrave; ubicata la cache di Squid</p>

          <table border="0" bgcolor="#E0E0E0" width="100%">
            <tr>
              <td>
                <pre class="PROGRAMLISTING">
cache_dir ufs /squid/cache 100 16 256 
   
</pre>
              </td>
            </tr>
          </table>

          <p>la sintassi di questo TAG verr&agrave; approfondita nel
          capitolo <a href="#SEC-DISK-STORAGE">dedicato</a> al Disk
          Storage</p>
        </div>
      </div>

      <div class="SECT1">
        <hr />

        <h2 class="SECT1"><a name="SEC-PARAMETRI-AMMINISTRATIVI" id=
        "SEC-PARAMETRI-AMMINISTRATIVI"></a>8.5. Parametri
        amministrativi</h2>

        <p>E&#39; possibile impostare l&#39;indirizzo e-mail dello
        Squidmanager (amministratore della cache) nonch&egrave; il nome
        dell&#39;host</p>

        <p>utilizzeremo il TAG <em>cache_mgr</em></p>

        <table border="0" bgcolor="#E0E0E0" width="100%">
          <tr>
            <td>
              <pre class="PROGRAMLISTING">
cache_mgr netmaster@nomedominio.com 
  
</pre>
            </td>
          </tr>
        </table>

        <p>questo TAG identifica l&#39;indirizzo di posta elettronica
        dell&#39;amministratore del proxy dove nomedominio.com &egrave; il
        nome di dominio internet qualificato (<em>fqdn</em>)</p>

        <p>il TAG <em>visible_hostname</em></p>

        <table border="0" bgcolor="#E0E0E0" width="100%">
          <tr>
            <td>
              <pre class="PROGRAMLISTING">
visible_hostname proxy1.nomedominio.com 
  
</pre>
            </td>
          </tr>
        </table>

        <p>identifica il nome dell&#39;host visualizzato da Squid nel caso
        si incontri un messaggio di errore o di semplice messaggio
        amministrativo dove <em>proxy1.nomedominio.com</em> &egrave; il il
        nome dell&#39;host all&#39;interno di un dominio internet
        qualificato (<em>fqdn</em>), questo TAG serve inoltre anche per
        &quot;puntare&quot; gli oggetti interni di Squid come le icone, i
        messaggi di errore ed altro</p>

        <p>il TAG <em>unique_hostname</em></p>

        <table border="0" bgcolor="#E0E0E0" width="100%">
          <tr>
            <td>
              <pre class="PROGRAMLISTING">
unique_hostname proxy1.nomedominio.com
  
</pre>
            </td>
          </tr>
        </table>

        <p>&egrave; utile si si dispone di una macchina che &egrave; stata
        configurata per rispondere a pi&ugrave; nomi nell&#39;ambito di un
        dominio internet qualificato. Con questo sistema &egrave; possibile
        impostare un nome univoco per l&#39;host che esegue Squid</p>

        <p>il TAG <em>append_domain</em></p>

        <table border="0" bgcolor="#E0E0E0" width="100%">
          <tr>
            <td>
              <pre class="PROGRAMLISTING">
append_domain .nomedominio.com
  
</pre>
            </td>
          </tr>
        </table>

        <p>&egrave; stato incluso nelle versioni pi&ugrave; recenti di
        Squid, questo TAG aggiunge automaticamente il nome di dominio
        locale.</p>
      </div>

      <div class="SECT1">
        <hr />

        <h2 class="SECT1"><a name="SEC-UTENTE-E-GROUPID" id=
        "SEC-UTENTE-E-GROUPID"></a>8.6. Utente e Gruppo (<em>UID e
        GID</em>)</h2>

        <p>Il TAG <em>cache_effective_user</em> e il TAG
        <em>cache_effective_group</em> definiscono l&#39;utente ed il
        gruppo che nei sistemi di classe UNIX&reg; eseguono Squid Proxy
        Server</p>

        <table border="0" bgcolor="#E0E0E0" width="100%">
          <tr>
            <td>
              <pre class="PROGRAMLISTING">
cache_effective_user squid
cache_effective_group squid
  
</pre>
            </td>
          </tr>
        </table>

        <p>&egrave; molto importante definire un&#39;utente non
        privilegiato per eseguire il processo del proxy server,
        l&#39;utente deve essere configurato con una serie di permessi
        molto limitati. E&#39; necessario portare molta attenzione ai
        permessi di scrittura e di lettura nelle directory dove Squid
        esegue il Disk Storage e dove scrive i suoi log.</p>
      </div>

      <div class="SECT1">
        <hr />

        <h2 class="SECT1"><a name="SEC-REDIRECT" id="SEC-REDIRECT"></a>8.7.
        Redirect</h2>

        <p>Squid pu&ograve; riscrivere una URLs implementando un processo
        esterno che prende il nome di redirector. Squid pu&ograve; essere
        configurato per passare qualsiasi richiesta di URLs direttamente
        verso un processo esterno che rielabora la richiesta ricevuta e la
        sostituisce con un messaggio predefinito. Il redirector consente
        all&#39;amministratore della cache di controllare le locations
        sulle quali vorrebbero accedere gli utenti, il redirector stesso si
        fa carico di leggere la richiesta di URLs o l&#39;input di tipo
        standard che riceve traducendolo in una falsa URLs. Il redirector
        pu&ograve; anche fornire una linea bianca come output di uscita
        standard. In buona sostanza un redirector quindi ridirige una
        specifica URLs richiesta dai client verso un&#39;altra URLs
        falsa</p>

        <p>il TAG <em>redirect_program</em></p>

        <table border="0" bgcolor="#E0E0E0" width="100%">
          <tr>
            <td>
              <pre class="PROGRAMLISTING">
redirect_program /usr/local/bin/squid_redirect
  
</pre>
            </td>
          </tr>
        </table>

        <p>consente di specificare il percorso di un file eseguibile
        <em>esterno</em> a Squid al quale &egrave; possibile reindirizzare
        tutte le richieste <em>HTTP</em>, il programma esterno pu&ograve;
        funzionare anche da filtro facendo passare solo le richieste che
        soddisfino determinate regole. Tra i programmi redirector
        pi&ugrave; famosi e pi&ugrave; utilizzati citiamo <a href=
        "http://www.squidguard.org/" target="_top">squidGuard</a> e
        <a href="http://squirm.foote.com.au/" target="_top">SQUIRM</a>. Di
        seguito pubblichiamo un semplice esempio di URL redirector
        realizzato in <em>perl</em></p>

        <table border="0" bgcolor="#E0E0E0" width="100%">
          <tr>
            <td>
              <pre class="PROGRAMLISTING">
#!/usr/local/bin/perl
$|=1;
while (&lt;&gt;) {
s@http://www.pippo.it@http://www.pluto.it@;
print;
}
  
</pre>
            </td>
          </tr>
        </table>
      </div>

      <div class="SECT1">
        <hr />

        <h2 class="SECT1"><a name="SEC-CONFIGURAZIONE-STARTUP" id=
        "SEC-CONFIGURAZIONE-STARTUP"></a>8.8. La configurazione di startup
        (<em>squid.conf</em>)</h2>

        <p>Nel file <em>squid.conf</em> &egrave; contenuta la
        configurazione di Squid, in questo capitolo abbiamo affrontato gli
        aspetti essenziali relativi alla preparazione, alla configurazione
        e alla installazione di Squid. Abbiamo trattato di alcune
        impostazioni basilari e, alla luce di quanto sinora scritto, siamo
        finalmente in grado di mostrare un file di configurazione
        minimale</p>

        <table border="0" bgcolor="#E0E0E0" width="100%">
          <tr>
            <td>
              <pre class="PROGRAMLISTING">
http_port 3128
icp_port 3130
cache_mem 8 MB
cache_dir ufs /usr/local/squid/var/cache 100 16 256
cache_access_log /usr/local/squid/var/logs/access.log
cache_log /usr/local/squid/var/logs/cache.log
cache_store_log /usr/local/squid/var/logs/store.log
emulate_httpd_log on
mime_table /usr/local/squid/etc/mime.conf
pid_filename /usr/local/squid/var/run/squid.pid
cache_mgr squid@miodominio.net
cache_effective_user nobody
cache_effective_group nobody
visible_hostname proxy.nomedominio.net
append_domain .miodominio.net
  
</pre>
            </td>
          </tr>
        </table>

        <p>questa configurazione contiene le impostazioni che abbiamo
        trattato pi&ugrave; o meno dettagliatamente nei precedenti
        paragrafi, si tratta di una configurazione minimale non ancora
        sufficente per utilizzare al meglio Squid.</p>
      </div>
    </div>

    <div class="CHAPTER">
      <hr />

      <h1><a name="CHA-IL-CACHE-STORE" id="CHA-IL-CACHE-STORE"></a>Capitolo
      9. Il Cache Store di Squid</h1>

      <div class="SECT1">
        <h2 class="SECT1"><a name="SEC-PREAMBOLO-CACHE-STORE" id=
        "SEC-PREAMBOLO-CACHE-STORE"></a>9.1. Preambolo</h2>

        <p>Le prestazioni di una webcache come Squid possono dipendere da
        diversi fattori come il tipo di Sistema Operativo, il suo
        filesystem e dal modello di Cache Store che viene utilizzato da
        Squid. In questo capitolo considereremo valide le conclusioni di
        uno studio realizzato da Duane Wessels che &egrave; liberamente
        disponibile alla URLs <a href=
        "http://conferences.oreillynet.com/presentations/os2002/wessels_duane.ppt"
           target=
           "_top">http://conferences.oreillynet.com/presentations/os2002/wessels_duane.ppt</a>
           e che fa esplicito riferimento alle seguenti variabili</p>

        <ul>
          <li>
            <p><em>Sistemi Operativi</em>: Linux, NetBSD, OpenBSD, FreeBSD
            e Solaris</p>
          </li>

          <li>
            <p><em>Filesystem utilizzati</em>: UFS, ext2fs, ext3fs, xfs,
            raiserfs</p>
          </li>

          <li>
            <p><em>Opzioni dei Filesystem</em>: noatime, softupdates,
            async</p>
          </li>

          <li>
            <p><em>Schemi di Storage</em>: ufs, aufs, diskd</p>
          </li>

          <li>
            <p><em>Versione di Squid</em>: squid-2.4.STABLE5, cache_dir: 3
            x 7500 MB, sistema di logging disabilitato, cache_mem: 8 MB</p>
          </li>
        </ul>

        <p>le soluzioni prese in considerazione sono state paragonate
        utilizzando la medesima piattaforma Hardware</p>

        <ul>
          <li>
            <p>IBM Netfinity 4000R</p>
          </li>

          <li>
            <p>500 MHz Pentium III</p>
          </li>

          <li>
            <p>1GB RAM</p>
          </li>

          <li>
            <p>3 x 18GB dischi SCSI di cui uno esterno</p>
          </li>

          <li>
            <p>scheda di rete Integrata Intel 10/100)</p>
          </li>
        </ul>

        <p>lo studio definisce anche i livelli di performance migliori che
        vengono rappresentati dalle seguenti soluzioni</p>

        <ul>
          <li>
            <p>FreeBSD 4.5-STABLE</p>

            <p>tipo di filesystem utilizzato UFS con <em>softupdates</em>
            montato con l&#39;opzione <em>noatime</em>, <em>diskd</em> Disk
            Storage, parametri di ottimizzazione del Kernel (MAXFILES=8192,
            MNBCLUSTERS=32768)</p>
          </li>

          <li>
            <p>Linux Kernel 2.4.9-13 con la patch SGI XFS_1.0.2</p>

            <p>tipo di filesystem utilizzato ext2fs montato con
            l&#39;opzione <em>noatime</em>, <em>aufs</em> Disk Storage,
            parametri di ottimizzazione del Kernel (8192 file descriptors e
            l&#39;opzione di configurazione with-aio-threads=32), altre
            applicazione Xfsprogs 1.3.13 e reiserfsprogs 3.x.0j</p>
          </li>
        </ul>

        <p>A questo punto proviamo ad analizzare nel dettaglio alcune
        problematiche legate al tipo di file system utilizzato incluse le
        componenti di una Cache Store, solo in questo modo potremo
        configurare al meglio la nostra piattaforma scegliendo, tra molte
        soluzioni, il miglior livello di compromesso.</p>
      </div>

      <div class="SECT1">
        <hr />

        <h2 class="SECT1"><a name="SEC-PROBLEMATICHE-UFS" id=
        "SEC-PROBLEMATICHE-UFS"></a>9.2. Alcune problematiche legate al
        tipo di filesystem</h2>

        <p>Tra gli obiettivi da raggiungere da parte di
        un&#39;amministratore di un Sistema Squid troviamo quello di
        aumentare sensibilmente le prestazioni del sottosistema di I/O. In
        precedenza abbiamo trattato di altre questioni, anche piuttosto
        importanti, che sono legate alle prestazioni del sottosistema di
        disk I/O ed in particolare abbiamo affrontato il problema dei
        dischi e delle tecnologie utilizzate per il tipo di bus (SCSI, ATA)
        relativamente alla nostra configurazione.</p>

        <p>Squid utilizza uno schema di storage piuttosto semplice in
        quanto le attivit&agrave; di disk I/O vengono eseguite direttamente
        dal processo Squid. Utilizzando un file system UNIX&reg;
        tradizionale come UFS<a name="AEN1708" href="#FTN.AEN1708" id=
        "AEN1708">[17]</a> o ext2<a name="AEN1710" href="#FTN.AEN1710" id=
        "AEN1710">[18]</a> alcune operazioni di I/O possono bloccare alcuni
        processi, in quanto il Sistema Operativo deve allocare ed
        inizializzare alcune strutture di dati sul disco. Le chiamate di
        Sistema (System Call) molto spesso non ritornano al Sistema almeno
        sino a quando l&#39;operazione di I/O non sia stata ultimata
        definitivamente. Questo fatto pu&ograve; determinare un blocco del
        processo Squid per un periodo anche piuttosto lungo.</p>
      </div>

      <div class="SECT1">
        <hr />

        <h2 class="SECT1"><a name="SEC-OTTIMIZZAZIONE-FILESYSTEM" id=
        "SEC-OTTIMIZZAZIONE-FILESYSTEM"></a>9.3. Eseguire
        l&#39;ottimizzazione del file system</h2>

        <p>Vi sono alcune impostazioni di Sistema che possono migliorare
        decisamente le performance di un filesystem con Squid. Un
        filesystem pu&ograve; essere montato con l&#39;opzione
        <em>noatime</em>, questa funzionalit&agrave; non aggiorna il tempo
        di accesso sul file quando lo stesso viene letto e pu&ograve;
        essere utilizzata sui quei file system dove sono stati memorizzati
        moltissimi files. In questo caso le prestazioni sono pi&ugrave;
        importanti se paragonate con il tempo di accesso ai files, nessun
        file system di rete attualmente supporta questo tipo di opzione</p>

        <table border="0" bgcolor="#E0E0E0" width="100%">
          <tr>
            <td>
              <pre class="PROGRAMLISTING">
# Device    Mountpoint FStype Options                        Dump Pass#
/dev/da0s1g /cache     ufs    rw,nosuid,nodev,noexec,noatime 2    2
  
</pre>
            </td>
          </tr>
        </table>

        <p>per avere maggiori informazioni possiamo consultare la pagina
        man del comando <em>mount(8)</em>. Un&#39;altra opzione
        interessante &egrave; <em>async</em>, abilitando questa
        funzionalit&agrave; del file system potremo eseguire le operazioni
        di disk I/O in modalit&agrave; asincrona. Dobbiamo informare gli
        utenti che l&#39;utilizzo di questo tipo di flag viene considerato
        piuttosto pericoloso.</p>

        <p>A riguardo dei file system c&#39;&egrave; da dire che i sistemi
        *BSD dispongono di una features denominata <em>softupdates</em>, i
        <em>softupdates</em>, per le loro peculiarit&agrave;, possono
        essere paragonati ai file systems di tipo <em>journaled</em> che
        sono stati inseriti anche nei sistemi GNU Linux.</p>

        <p>Con i file system UFS ed ext2 gli aggiornamenti vengono scritti
        immediatamente, quando vengono inseriti nuovi dati le informazioni
        verranno scritte immediatamente sul disco. Un <em>journaling</em>
        filesystem scrive i metadati all&#39;interno di un file di log,
        questo file &egrave; un semplice file sequenziale nel quale vengono
        memorizzate tutte le informazioni prima che un qualsiasi comando
        venga eseguito dal Sistema, i metadati verranno successivamente
        trasferiti dal file di log alla loro reale destinazione. Se una
        unit&agrave; a disco va in errore, sar&agrave; proprio il file di
        log che consentir&agrave; di riportare i dati sul disco ad una
        condizione consistente.</p>

        <p>I <em>softupdates</em> dei sistemi *BSD al pari dei
        <em>journaled</em> file system, riordinano e raggruppano le diverse
        operazioni di modifica dei metadati. Questo modello elimina i
        problemi che potrebbero affliggere una macchina rimasta priva di
        alimentazione o una macchina andata in crash. Come abbiamo detto
        sono diversi i file system del tipo <em>journaled</em> che sono
        disponibili per i diversi Sistemi Operativi, su GNU <em>Linux</em>
        possiamo scegliere tra <em>ext3</em>, <em>reiserfs</em>,
        <em>XFS</em> e <em>JFS</em>, ext3 &egrave; un file system ext2 che
        prevede un file di log per le transazioni del tipo
        <em>jurnaled</em>.</p>
      </div>

      <div class="SECT1">
        <hr />

        <h2 class="SECT1"><a name="SEC-RISERVARE-SPAZIO-DISCO" id=
        "SEC-RISERVARE-SPAZIO-DISCO"></a>9.4. Riservare correttamente lo
        spazio al Cache Storage</h2>

        <p>Molto spesso viene dedicata una partizione del disco al Cache
        Storage di Squid. Diciamo subito che non &egrave; consigliabile
        utilizzare tutto lo spazio disponibile sul disco ma &egrave;
        necessario riservare una parte di spazio che sar&agrave; dedicata
        alle operazioni supplementari che vengono effettuate da parte del
        file system nonch&egrave; da parte del Sistema Operativo.
        Attualmente, Squid non &egrave; molto tollerante se il suo Disk
        Storage viene impostato per funzionare su tutto lo spazio del
        disco, la dimensione ottimale del disco dedicato al Disk Storage
        dovrebbe essere di circa 9GB e non tutti i fornitori di
        unit&agrave; a disco creano dei supporti che dispongono dello
        stesso spazio ed un disco da 9GB nella realt&agrave; dispone di
        circa circa 8.5GB di spazio effettivamente utilizzabile. La prima
        cosa da fare &egrave; quella di preparare un file system per
        l&#39;intera superfice del disco e montarlo per renderlo
        disponibile a Sistema Operativo.</p>

        <p>Solo a questo punto potremmo verificare lo spazio disponibile
        utilizzando il programma <em>df</em>(8) che, se utilizzato senza
        argomenti, visualizza la quantit&agrave; di spazio utilizzato e
        quello disponibile su tutti i filesystem attualmente montati.
        Notiamo che verr&agrave; perso un certo spazio di disco, tale
        spazio verr&agrave; dedicato agli overheads del file system quali i
        superblocks, gli inodes e gli indici. Inoltre ricordiamo che
        UNIX&reg; mantiene normalmente libero il 10% dello spazio disco per
        le sue operazioni.</p>

        <p>Tenendo conto di queste considerazioni, un disco di 9GB dopo la
        formattazione render&agrave; disponibile per l&#39;utilizzo poco
        pi&ugrave; di 8GB. Successivamente suggeriamo di togliere ulteriore
        spazio disponibile per un altro 10% che verr&agrave; dedicato agli
        overheads di Squid oltre che ad un buffer per la sicurezza. Inoltre
        notiamo ancora che Squid lavora molto meglio quando lo spazio
        libero sul disco &egrave; decisamente superiore. Se le prestazioni
        sono un fattore importante, lo spazio disponibile su disco deve
        essere ancora di pi&ugrave;. Su un disco da 9GB si suggerisce uno
        spazio dedicato alla <em>cache_dir</em> pari a 6000 - 7500
        megabyte</p>

        <table border="0" bgcolor="#E0E0E0" width="100%">
          <tr>
            <td>
              <pre class="PROGRAMLISTING">
cache_dir ufs /cache1 7000 16 256
  
</pre>
            </td>
          </tr>
        </table>

        <p>quando il disco si riempie &egrave; necessario verificare
        l&#39;utilizzo dello spazio su disco, se troviamo spazio
        inutilizzato in abbondanza, allora dovremmo aumentare le dimensioni
        della <em>cache_dir</em>.</p>
      </div>

      <div class="SECT1">
        <hr />

        <h2 class="SECT1"><a name="SEC-LE-COMP-DEL-CACHE-STORE" id=
        "SEC-LE-COMP-DEL-CACHE-STORE"></a>9.5. Le componenti del Cache
        Store</h2>

        <p>Il Cache Store di Squid &egrave; caratterizzato da tre
        componenti fondamentali che sono in stretta relazione tra di
        loro</p>

        <ul>
          <li>
            <p>Disk Storage</p>
          </li>

          <li>
            <p>Memory Storage</p>
          </li>

          <li>
            <p>Memory e Cache Replacement Policy</p>
          </li>
        </ul>

        <p>le performance di una webcache come Squid possono essere
        fortemente influenzate dalla configurazione del tipo di Cache Store
        che viene utilizzato. Nei paragrafi seguenti andremo ad analizzare
        nel dettaglio tutte le possibili opzioni di configurazione.</p>
      </div>

      <div class="SECT1">
        <hr />

        <h2 class="SECT1"><a name="SEC-DISK-STORAGE" id=
        "SEC-DISK-STORAGE"></a>9.6. Disk Storage</h2>

        <p>La direttiva <em>cache_dir</em> contenuta nel file di
        configurazione <em>squid.conf</em>, definisce una tipologia di Disk
        Storage che non ha nulla a che vedere con il tipo di file system
        fisicamente utilizzato dal Sistema Operativo. Il Disk Storage di
        Squid definisce unicamente il metodo di accesso e di
        implementazione utilizzati internamente dal processo Squid per la
        gestione del Disk I/O. Attualmente vengono implementati ben 5
        differenti sistemi di Disk Storage</p>

        <ul>
          <li>
            <p><em>ufs</em></p>
          </li>

          <li>
            <p><em>aufs</em> (<em>awin32</em> in Windows)</p>
          </li>

          <li>
            <p><em>diskd</em></p>
          </li>

          <li>
            <p><em>null</em></p>
          </li>

          <li>
            <p><em>coss</em></p>
          </li>
        </ul>

        <p>la scelta del tipo di Disk Storage da attivare, viene effettuata
        nel momento della configurazione dei parametri di compilazione di
        Squid</p>

        <table border="0" bgcolor="#E0E0E0" width="100%">
          <tr>
            <td>
              <pre class="PROGRAMLISTING">
./configure --enable-storeio=&quot;elenco disk storage&quot;
  
</pre>
            </td>
          </tr>
        </table>

        <p>dove l&#39;elenco dei Disk Storage da attivare contiene i nomi
        (case sensitive) delle cartelle che sono incluse nel source tree di
        Squid e che ne contengono i sorgenti. Il Disk Storage che viene
        compilato come default &eacute; <em>ufs</em></p>

        <table border="0" bgcolor="#E0E0E0" width="100%">
          <tr>
            <td>
              <pre class="PROGRAMLISTING">
./configure --enable-storeio=&quot;ufs aufs diskd null&quot;
  
</pre>
            </td>
          </tr>
        </table>

        <p>nell&#39;esempio precedente abbiamo selezionato i Disk Storage
        <em>ufs</em>, <em>aufs</em>, <em>diskd</em> e <em>null</em>.
        Selezionando uno qualunque di questi sistemi di Disk Storage, viene
        automaticamente impostato e compilato anche il Disk Storage
        <em>ufs</em> in quanto necessario al corretto funzionamento di
        tutti i tipi di Disk Storage selezionati. La selezione del Disk
        Storage da utilizzare avviene tramite il TAG <em>cache_dir</em> di
        <em>squid.conf</em>, la sintassi generica &egrave; la seguente</p>

        <table border="0" bgcolor="#E0E0E0" width="100%">
          <tr>
            <td>
              <pre class="PROGRAMLISTING">
cache_dir Type Directory-Name Fs-specific-data [options]
  
</pre>
            </td>
          </tr>
        </table>

        <p>I valori di default sono</p>

        <table border="0" bgcolor="#E0E0E0" width="100%">
          <tr>
            <td>
              <pre class="PROGRAMLISTING">
cache_dir ufs /usr/local/squid/var/cache 100 16 256
  
</pre>
            </td>
          </tr>
        </table>

        <p>le <em>options</em> sono comuni a tutti i tipi di Disk Storage e
        si suddividono in</p>

        <table border="0" bgcolor="#E0E0E0" width="100%">
          <tr>
            <td>
              <pre class="PROGRAMLISTING">
read-only
max-size=n
  
</pre>
            </td>
          </tr>
        </table>

        <p><em>read-only</em> indica che questa <em>cache_dir</em> &eacute;
        di sola lettura mentre <em>max_size</em> identifica la dimensione
        massima di oggetto che questa <em>cache_dir</em> pu&ograve;
        immagazzinare. &Eacute; possibile specificare in
        <em>squid.conf</em> pi&ugrave; di una definizione di
        <em>cache_dir</em>, anche se la stessa utilizza un differente tipo
        di Disk Storage, infatti a partire dalla versione 2 di Squid,
        &egrave; possibile aggiungere nuove <em>cache_dir</em> in qualsiasi
        momento e renderle attive senza ricavarne alcun effetto
        collaterale.</p>

        <div class="SECT2">
          <hr />

          <h3 class="SECT2"><a name="SUBSEC-UFS" id="SUBSEC-UFS"></a>9.6.1.
          <em>ufs</em> storage</h3>

          <p>&Egrave; il Disk Storage system originario e nativo di Squid,
          si basa su una struttura di directory a 2 livelli dove i valori
          di default prevedono ben 16 directory per il primo livello
          (<em>L1</em>) e 256 per il secondo (<em>L2</em>). Tutti gli
          oggetti presenti nella cache di Squid sono immagazzinati come
          file all&#39;interno del secondo livello, tutte le operazioni di
          I/O sono gestite in modalit&agrave; sincrona direttamente dal
          Sistema Operativo e possono bloccare il funzionamento del
          processo principale di Squid sino al loro completamento. La
          sintassi del TAG <em>cache_dir</em> per il Disk Storage
          <em>ufs</em> &eacute;</p>

          <table border="0" bgcolor="#E0E0E0" width="100%">
            <tr>
              <td>
                <pre class="PROGRAMLISTING">
cache_dir ufs Directory-Name MBytes L1 L2 [options]
   
</pre>
              </td>
            </tr>
          </table>

          <p>dove <em>Directory-Name</em> identifica la top-level directory
          nella quale i files saranno immagazzinati, <em>L1</em> &egrave;
          il numero di directory di primo livello, <em>L2</em> &egrave; il
          numero di directory di secondo livello ed il numero massimo di
          oggetti per directory, infine <em>MBytes</em> indica la
          dimensione massima in MBytes di questo Disk Storage, ecco un
          esempio</p>

          <table border="0" bgcolor="#E0E0E0" width="100%">
            <tr>
              <td>
                <pre class="PROGRAMLISTING">
cache_dir ufs /usr/local/squid/var/cache 4096 16 256
   
</pre>
              </td>
            </tr>
          </table>
        </div>

        <div class="SECT2">
          <hr />

          <h3 class="SECT2"><a name="SUBSEC-AUFS" id=
          "SUBSEC-AUFS"></a>9.6.2. <em>aufs</em> storage</h3>

          <p>Utilizza il medesimo formato di storage su disco di
          <em>ufs</em>, tutte le operazioni di I/O sono gestite in
          modalit&agrave; asincrona utilizzando il modello
          <em>POSIX-threads</em>, <em>aufs</em> utilizza quindi dei
          processi di tipo thread che gli consentono di eseguire le
          operazioni di disk I/O. Questo modello di storage consente di
          evitare il blocco del processo principale di Squid durante tutte
          le operazioni di disk I/O in quanto le stesse vengono inoltrate
          ad un processo thread differente. Questo tipo di Disk Storage
          viene spesso indicato anche come <em>async-io</em> e <em>non
          pu&ograve; essere utilizzato</em> efficacemente sui Sistemi che
          implementano il modello dello <em>User-threads</em> come FreeBSD,
          il codice <em>aufs</em> richiede la presenza della libreria
          <em>pthreads</em>. Questo tipo di Disk Storage non &eacute;
          disponibile sulle piattaforme Windows e funziona unicamente sulle
          piattaforme Linux e Solaris. La sintassi del TAG
          <em>cache_dir</em> per il Disk Storage <em>aufs</em> &eacute;</p>

          <table border="0" bgcolor="#E0E0E0" width="100%">
            <tr>
              <td>
                <pre class="PROGRAMLISTING">
cache_dir aufs Directory-Name MBytes L1 L2 [options]
   
</pre>
              </td>
            </tr>
          </table>

          <p>Dove <em>Directory-Name</em> identifica la top-level directory
          ove i files verranno immagazzinati, <em>L1</em> &egrave; il
          numero di directory di primo livello, <em>L2</em> &egrave; il
          numero di directory di secondo livello ed il numero massimo di
          oggetti per directory ed infine <em>MBytes</em> &egrave; la
          dimensione massima espressa in MBytes per questo Disk Storage.
          Ecco un esempio</p>

          <table border="0" bgcolor="#E0E0E0" width="100%">
            <tr>
              <td>
                <pre class="PROGRAMLISTING">
cache_dir aufs /usr/local/squid/var/cache 8192 16 256
   
</pre>
              </td>
            </tr>
          </table>

          <p>Il numero di thread in uso viene calcolato dinamicamente in
          funzione del numero delle <em>cache_dir</em> definite, la
          seguente tabella mostra il numero di thread predefiniti sino a 6
          <em>cache_dir</em></p>

          <div class="INFORMALTABLE">
            <a name="AEN1846" id="AEN1846"></a>

            <table border="1" class="CALSTABLE">
              <tbody>
                <tr>
                  <td width="50%" align="center" valign="top">
                    <p>cache_dir</p>
                  </td>

                  <td width="50%" align="center" valign="top">
                    <p>threads</p>
                  </td>
                </tr>

                <tr>
                  <td width="50%" align="center" valign="top">
                    <p>1</p>
                  </td>

                  <td width="50%" align="center" valign="top">
                    <p>16</p>
                  </td>
                </tr>

                <tr>
                  <td width="50%" align="center" valign="top">
                    <p>2</p>
                  </td>

                  <td width="50%" align="center" valign="top">
                    <p>26</p>
                  </td>
                </tr>

                <tr>
                  <td width="50%" align="center" valign="top">
                    <p>3</p>
                  </td>

                  <td width="50%" align="center" valign="top">
                    <p>32</p>
                  </td>
                </tr>

                <tr>
                  <td width="50%" align="center" valign="top">
                    <p>4</p>
                  </td>

                  <td width="50%" align="center" valign="top">
                    <p>36</p>
                  </td>
                </tr>

                <tr>
                  <td width="50%" align="center" valign="top">
                    <p>5</p>
                  </td>

                  <td width="50%" align="center" valign="top">
                    <p>40</p>
                  </td>
                </tr>

                <tr>
                  <td width="50%" align="center" valign="top">
                    <p>6</p>
                  </td>

                  <td width="50%" align="center" valign="top">
                    <p>44</p>
                  </td>
                </tr>
              </tbody>
            </table>
          </div>
          <br />
          <br />

          <p>in alternativa &egrave; possibile forzare il numero di thread
          al momento della compilazione di Squid ricorrendo all&#39;opzione
          <em>--with-aio-threads=N</em> di configure</p>

          <table border="0" bgcolor="#E0E0E0" width="100%">
            <tr>
              <td>
                <pre class="PROGRAMLISTING">
./configure --with-aio-threads=32
   
</pre>
              </td>
            </tr>
          </table>

          <p>utilizzando il cache manager &egrave; possibile visualizzare
          le statistiche relative a aufs</p>

          <table border="0" bgcolor="#E0E0E0" width="100%">
            <tr>
              <td>
                <pre class="PROGRAMLISTING">
[root@portatilo root]# squidclient mgr:squidaio_counts
HTTP/1.0 200 OK
Server: squid/2.5.STABLE5
Mime-Version: 1.0
Date: Tue, 06 Apr 2004 19:08:27 GMT
Content-Type: text/plain
Expires: Tue, 06 Apr 2004 19:08:27 GMT
Last-Modified: Tue, 06 Apr 2004 19:08:27 GMT
X-Cache: MISS from portatilo.miodominio.net
Proxy-Connection: close
ASYNC IO Counters:
Operation       # Requests
open    93
close   93
cancel  93
write   0
read    108
stat    0
unlink  5
check_callback  9312
queue   0
   
</pre>
              </td>
            </tr>
          </table>
        </div>

        <div class="SECT2">
          <hr />

          <h3 class="SECT2"><a name="SUBSEC-AWIN32" id=
          "SUBSEC-AWIN32"></a>9.6.3. <em>awin32</em> storage</h3>

          <p>Si tratta del port nativo di <em>aufs</em> per la piattaforma
          Windows. Anche in questo caso, tutte le operazioni di I/O sono
          gestite in modalit&agrave; asincrona utilizzando i <em>Win32
          native threads</em>, questo tipo di approccio serve per evitare
          il blocco del processo principale di Squid durante le operazioni
          di disk I/O. La sintassi del TAG <em>cache_dir</em> per il Disk
          Storage <em>awin32</em> &eacute;</p>

          <table border="0" bgcolor="#E0E0E0" width="100%">
            <tr>
              <td>
                <pre class="PROGRAMLISTING">
cache_dir awin32 Directory-Name MBytes L1 L2 [options]
   
</pre>
              </td>
            </tr>
          </table>

          <p>dove <em>Directory-Name</em> identifica la top-level directory
          dove i files saranno salvati, <em>L1</em> &egrave; il numero di
          directory di primo livello, <em>L2</em> &egrave; il numero di
          directory di secondo livello ed il numero massimo di oggetti per
          directory, infine <em>MBytes</em> indica la dimensione massima
          espressa in MBytes di questo Disk Storage. Di seguito ecco un
          esempio</p>

          <table border="0" bgcolor="#E0E0E0" width="100%">
            <tr>
              <td>
                <pre class="PROGRAMLISTING">
cache_dir awin32 c:/squid/var/cache 4096 16 256
   
</pre>
              </td>
            </tr>
          </table>
        </div>

        <div class="SECT2">
          <hr />

          <h3 class="SECT2"><a name="SUBSEC-DISKD" id=
          "SUBSEC-DISKD"></a>9.6.4. <em>diskd</em> storage</h3>

          <p><em>Diskd</em> &egrave; l&#39;acronimo di <em>disk
          daemons</em> ed utilizza il medesimo formato di storage di
          <em>ufs</em>, concettualmente &egrave; molto simile ad
          <em>aufs</em>, l&#39;unica differenza che distingue
          <em>diskd</em> da <em>aufs</em> risiede nel fatto che tutte le
          operazioni di I/O vengono gestite in modalit&agrave; asincrona
          ricorrendo ad un programma esterno per ogni <em>cache_dir</em>.
          Questo sistema consente di evitare il blocco del processo
          principale di Squid durante le operazioni di disk I/O,
          <em>diskd</em> dunque non utilizza i threads e le funzioni
          IPC<a name="AEN1918" href="#FTN.AEN1918" id="AEN1918">[19]</a>
          vengono implementate ricorrendo alla memoria condivisa (shared
          memory) e alla coda dei messaggi (message queue) del Sistema
          Operativo. La coda dei messaggi &egrave; implementata per la
          prima volta dalla AT&amp;T con il rilascio dello UNIX&reg; System
          V, Release 1. <em>Diskd</em> viene <em>particolarmente
          indicato</em> sui sistemi che implementano il modello dello
          <em>User-threads</em> come FreeBSD ed OpenBSD e funziona anche
          con Linux, Solaris e Digital Unix mentre non &egrave; disponibile
          sulle piattaforme Windows. La sintassi del TAG <em>cache_dir</em>
          per il Disk Storage <em>diskd</em> &eacute;</p>

          <table border="0" bgcolor="#E0E0E0" width="100%">
            <tr>
              <td>
                <pre class="PROGRAMLISTING">
cache_dir diskd Directory-Name MBytes L1 L2 [options] [Q1=n] [Q2=n]
   
</pre>
              </td>
            </tr>
          </table>

          <p>dove <em>Directory-Name</em> identifica la top-level directory
          in cui i file verranno immagazzinati, <em>L1</em> &egrave; il
          numero di directory di primo livello, <em>L2</em> &egrave; il
          numero di directory di secondo livello nonch&egrave; il numero
          massimo di oggetti per directory, infine <em>MBytes</em>
          rappresenta la dimensione massima espressa in MBytes per questo
          Disk Storage. I Parametri <em>Q1</em> e Q2 indicano
          rispettivamente la lunghezza massima della coda di I/O per il
          blocco dell&#39;apertura di nuovi files e la lunghezza massima
          della coda di I/O per l&#39;inizio del funzionamento in
          modalit&agrave; blocking. I valori predefiniti sono 72 e 64.
          &Egrave; inoltre necessario specificare il percorso
          dell&#39;eseguibile del programma <em>diskd</em>. Questa
          funzionalit&agrave; viene attivata solo se abbiamo compilato
          Squid con il supporto a <em>diskd</em>, il TAG da indicare nel
          file <em>squid.conf</em> &egrave;</p>

          <table border="0" bgcolor="#E0E0E0" width="100%">
            <tr>
              <td>
                <pre class="PROGRAMLISTING">
diskd_program diskd-path
   
</pre>
              </td>
            </tr>
          </table>

          <p>di seguito un esempio</p>

          <table border="0" bgcolor="#E0E0E0" width="100%">
            <tr>
              <td>
                <pre class="PROGRAMLISTING">
cache_dir diskd /usr/local/squid/var/cache 8192 16 256 Q1=72 Q2=64
diskd_program /usr/local/squid/libexec/diskd
   
</pre>
              </td>
            </tr>
          </table>

          <p>utilizzando il Cache Manager &egrave; possibile visualizzare
          le prestazioni del <em>diskd</em></p>

          <table border="0" bgcolor="#E0E0E0" width="100%">
            <tr>
              <td>
                <pre class="PROGRAMLISTING">
root@mandrake:/root&gt; squidclient mgr:diskd
HTTP/1.0 200 OK
Server: squid/2.5.STABLE5
Mime-Version: 1.0
Date: Tue, 06 Apr 2004 19:56:57 GMT
Content-Type: text/plain
Expires: Tue, 06 Apr 2004 19:56:57 GMT
Last-Modified: Tue, 06 Apr 2004 19:56:57 GMT
X-Cache: MISS from proxy.miodominio.net
Proxy-Connection: close
sent_count: 132233
recv_count: 132233
max_away: 26
max_shmuse: 25
open_fail_queue_len: 0
block_queue_len: 0
             OPS SUCCESS    FAIL
   open   21674   21663      11
 create    5478    5478       0
  close   27141   27141       0
 unlink   21294    5873   15421
   read   36111   36100       0
  write   20535   20535       0
   
</pre>
              </td>
            </tr>
          </table>

          <div class="SECT3">
            <hr />

            <h4 class="SECT3"><a name=
            "SUBSUBSEC-TUNING-DEI-PARAMETRI-Q1-Q2" id=
            "SUBSUBSEC-TUNING-DEI-PARAMETRI-Q1-Q2"></a>9.6.4.1. Tuning dei
            parametri Q1 e Q2</h4>

            <p>Abbiamo gi&agrave; parlato in precedenza dei valori
            <em>Q1</em> e <em>Q2</em>, nel codice sorgente di Squid vengono
            chiamati <em>magic1</em> e <em>magic2</em> e si riferiscono al
            numero di richieste di I/O che vengono contenute nella coda dei
            messaggi che rimangono in attesa di un <em>acknowledge</em> da
            parte di <em>diskd</em>. Questi valori vengono specificati nel
            TAG <em>cache_dir</em>, dopo aver impostato le directory di
            livello <em>L1</em> e <em>L2</em>, il formato del TAG
            &egrave;</p>

            <table border="0" bgcolor="#E0E0E0" width="100%">
              <tr>
                <td>
                  <pre class="PROGRAMLISTING">
cache_dir diskd Directory-Name MBytes L1 L2 [options] [Q1=n] [Q2=n]
    
</pre>
                </td>
              </tr>
            </table>

            <p>quando la lunghezza della coda dei messaggi raggiunge il
            valore <em>Q1</em>, Squid intenzionalmente fallisce
            l&#39;apertura dei files sul disco per quello che concerne le
            operazioni di lettura e scrittura. Si tratta di un efficente
            meccanismo di <em>load-shedding</em>, letteralmente tradotto
            come spargimento delle richieste. Se la cache &egrave;
            veramente occupata e non &egrave; possibile accedere al disco,
            Squid sorpassa il disco stesso prima che il numero delle
            richieste vada nuovamente gi&ugrave;. Se la lunghezza della
            coda raggiunge il valore <em>Q2</em>, allora il processo
            principale di Squid si pone in I/O blocking mode per piccole
            frazioni di tempo, sino a quando il processo di <em>diskd</em>
            riprende a fornire dei risultati. Se vogliamo che Squid si
            ponga in I/O blocking mode prima di iniziare la fase di rifiuto
            dell&#39;apertura dei files, il valore di <em>Q1</em> deve
            essere decisamente pi&ugrave; grande del valore <em>Q2</em>.
            Nel nostro esempio, nel file di configurazione di Squid abbiamo
            impostato dei valori che possono essere considerati come
            ragionevoli per <em>Q1</em> e <em>Q2</em>, tali valori saranno
            appunto rispettivamente come gi&agrave; consigliato 72 e 64</p>

            <table border="0" bgcolor="#E0E0E0" width="100%">
              <tr>
                <td>
                  <pre class="PROGRAMLISTING">
cache_dir diskd /usr/local/squid/cache 7500 16 256 Q1=72 Q2=64
    
</pre>
                </td>
              </tr>
            </table>
          </div>

          <div class="SECT3">
            <hr />

            <h4 class="SECT3"><a name=
            "SUBSUBSEC-CONFIGURARE-LA-CODA-MESSAGGI" id=
            "SUBSUBSEC-CONFIGURARE-LA-CODA-MESSAGGI"></a>9.6.4.2.
            Configurare la coda dei messaggi (<em>message queues</em>)</h4>

            <p>Molti sistemi operativi UNIX&reg; hanno il supporto per la
            gestione della coda dei messaggi abilitato come default. Una
            metodo per verificare questa impostazione &egrave; controllare
            se si dispone del comando <em>ipcs(1)</em>, <em>ipcs</em>
            &egrave; una facility del sistema operativo che esegue dei
            report sullo stato delle comunicazioni intraprocesso. &Egrave;
            comunque necessario aumentare la grandezza della coda dei
            messaggi per far lavorare correttamente Squid, le
            implementazioni della coda dei messaggi rispondono ai seguenti
            parametri</p>

            <ul>
              <li>
                <p><em>MSGMNB</em> - numero massimo di byte per message
                queue</p>
              </li>

              <li>
                <p><em>MSGMNI</em> - numero massimo di identificativi
                message queue (system wide)</p>
              </li>

              <li>
                <p><em>MSGSEG</em> - numero massimo di segmenti dei
                messaggi per la coda (queue)</p>
              </li>

              <li>
                <p><em>MSGSSZ</em> - grandezza del segmento dei
                messaggi</p>
              </li>

              <li>
                <p><em>MSGTQL</em> - numero massimo dei messaggi (system
                wide)</p>
              </li>

              <li>
                <p><em>MSGMAX</em> - grandezza massima di un whole message.
                In molti sistemi &egrave; necessario aumentare questo
                limite, in altri sistemi non &egrave; possibile modificare
                questo valore</p>
              </li>
            </ul>

            <p>i messaggi tra Squid e <em>diskd</em> sono di 32 bytes per
            le CPUs a 32-bit mentre sono di 40 bytes per le architetture
            che prevedono CPUs a 64-bit. Sulla base di queste informazioni,
            <em>MSGSSZ</em> deve avere un valore di 32 oppure essere
            pi&ugrave; grande, &egrave; indicato settare un valore
            pi&ugrave; grande per avere maggiore sicurezza. Ci sono due
            code per ogni <em>cache_dir</em>, una per ogni direzione,
            cos&igrave; il valore richiesto per <em>MSGMNI</em> deve essere
            almeno due volte il numero delle <em>cache_dir</em>. Sono stati
            rilevati in media 75 messaggi per coda ed &egrave; proprio
            questo il limite che consente di ottenere delle performance
            decenti con <em>diskd</em>. Se ogni messaggio <em>diskd</em>
            consiste di un segmento (questo dipende dal valore che abbiamo
            assegnato a <em>MSGSSZ</em>), allora <em>MSGSEG</em>
            dovr&agrave; essere pi&ugrave; grande di 75. <em>MSGMNB</em> e
            <em>MSGTQL</em> dipendono da quanti messaggi possono essere
            contenuti dalla coda nello stesso momento. I messaggi
            <em>diskd</em> non devono essere pi&ugrave; grandi di 40 bytes
            e si utilizzano 64 bytes per essere pi&ugrave; sicuri.
            <em>MSGMNB</em> dovr&agrave; essere almeno 64*75, si raccomanda
            di impostare un numero non lontano dal doppio di questo valore
            oppure un valore di 8192. <em>MSGTQL</em> deve essere almeno 75
            volte il numero dei TAG <em>cache_dir</em> che abbiamo
            configurato.</p>
          </div>

          <div class="SECT3">
            <hr />

            <h4 class="SECT3"><a name="SUBSUBSEC-CODA-DEI-MESSAGGI-BSD" id=
            "SUBSUBSEC-CODA-DEI-MESSAGGI-BSD"></a>9.6.4.3. Coda dei
            messaggi con BSD</h4>

            <p>Il Kernel deve prevedere le seguenti impostazioni</p>

            <table border="0" bgcolor="#E0E0E0" width="100%">
              <tr>
                <td>
                  <pre class="PROGRAMLISTING">
options         SYSVMSG
    
</pre>
                </td>
              </tr>
            </table>

            <p>altri parametri da impostare prima di ricompilare il Kernel
            vengono riportati da questo esempio, assicuriamoci di impostare
            i valori appropriati per il nostro sistema</p>

            <table border="0" bgcolor="#E0E0E0" width="100%">
              <tr>
                <td>
                  <pre class="PROGRAMLISTING">
options         MSGMNB=8192     # max # of bytes in a queue
options         MSGMNI=40       # number of message queue identifiers
options         MSGSEG=512      # number of message segments per queue
options         MSGSSZ=64       # size of a message segment
options         MSGTQL=2048     # max messages in system
    
</pre>
                </td>
              </tr>
            </table>
          </div>

          <div class="SECT3">
            <hr />

            <h4 class="SECT3"><a name="SUBSUBSEC-CODA-DEI-MESSAGGI-LINUX"
            id="SUBSUBSEC-CODA-DEI-MESSAGGI-LINUX"></a>9.6.4.4. Coda dei
            messaggi con Linux</h4>

            <p>Per configurare la coda dei messaggi con Linux &egrave;
            necessario editare il file <em>/etc/sysctl.conf</em></p>

            <table border="0" bgcolor="#E0E0E0" width="100%">
              <tr>
                <td>
                  <pre class="PROGRAMLISTING">
    kernel.msgmnb=8192
    kernel.msgmni=40
    kernel.msgmax=8192
    
</pre>
                </td>
              </tr>
            </table>
          </div>

          <div class="SECT3">
            <hr />

            <h4 class="SECT3"><a name="SUBSUBSEC-CODA-DEI-MESSAGGI-SOLARIS"
            id="SUBSUBSEC-CODA-DEI-MESSAGGI-SOLARIS"></a>9.6.4.5. Coda dei
            messaggi con Solaris</h4>

            <p>Aggiungere le seguenti linee nel file
            <em>/etc/system</em></p>

            <table border="0" bgcolor="#E0E0E0" width="100%">
              <tr>
                <td>
                  <pre class="PROGRAMLISTING">
set msgsys:msginfo_msgmax=2048
set msgsys:msginfo_msgmnb=8192
set msgsys:msginfo_msgmni=40
set msgsys:msginfo_msgssz=64
set msgsys:msginfo_msgtql=2048
    
</pre>
                </td>
              </tr>
            </table>

            <p>naturalmente &egrave; necessario eseguire un riavvio del
            Sistema dopo aver modificato il file <em>/etc/system</em></p>
          </div>

          <div class="SECT3">
            <hr />

            <h4 class="SECT3"><a name=
            "SUBSUBSEC-CONFIGURARE-LA-MEMORIA-SHARED" id=
            "SUBSUBSEC-CONFIGURARE-LA-MEMORIA-SHARED"></a>9.6.4.6.
            Configurare la memoria condivisa (<em>shared memory</em>)</h4>

            <p>La Shared Memory utilizza un insieme di parametri simili a
            quelli utilizzati per la gestione della coda dei messaggi
            (message queues). L&#39;implementazione del <em>diskd</em> di
            Squid utilizza un&#39;area di memoria condivisa per ogni
            <em>cache_dir</em>. Qualsiasi area di Shared Memory &egrave;
            almeno di 800 kilobytes per tipo, per un corretto funzionamento
            di Squid con <em>diskd</em> &egrave; quindi richiesto
            modificare i seguenti parametri della Shared Memory</p>

            <ul>
              <li>
                <p><em>SHMSEG</em> - numero massimo di segmenti di shared
                memory per processo</p>
              </li>

              <li>
                <p><em>SHMMNI</em> - numero massimo di segmenti di shared
                memory per il segments per l&#39;intero sistema</p>
              </li>

              <li>
                <p><em>SHMMAX</em> - segmento pi&ugrave; grande di shared
                memory segment autorizzato</p>
              </li>

              <li>
                <p><em>SHMALL</em> - ammontare totale della shared memory
                che pu&ograve; essere utilizzata</p>
              </li>
            </ul>

            <p>per Squid e <em>diskd</em>, <em>SHMMNI</em> e
            <em>SHMMNI</em> devono essere pi&ugrave; grandi o uguali al
            numero di <em>cache_dir</em> configurate sul sistema di
            webcache. <em>SHMMAX</em> deve essere almeno di 800 kilobytes,
            <em>SHMALL</em> deve essere almeno il valore di <em>SHMMAX</em>
            800 kilobytes moltiplicato per il numero delle
            <em>cache_dir</em>.</p>
          </div>

          <div class="SECT3">
            <hr />

            <h4 class="SECT3"><a name="SUBSUCSEC-MEMORIA-CONDIVISA-BSD" id=
            "SUBSUCSEC-MEMORIA-CONDIVISA-BSD"></a>9.6.4.7. Memoria
            condivisa con BSD</h4>

            <p>Il Kernel deve prevedere le seguenti impostazioni</p>

            <table border="0" bgcolor="#E0E0E0" width="100%">
              <tr>
                <td>
                  <pre class="PROGRAMLISTING">
options         SYSVSHM
    
</pre>
                </td>
              </tr>
            </table>

            <p>altri parametri da impostare prima di ricompilare il Kernel
            vengono riportati da questo esempio, assicuriamoci di impostare
            i valori appropriati per il nostro sistema</p>

            <table border="0" bgcolor="#E0E0E0" width="100%">
              <tr>
                <td>
                  <pre class="PROGRAMLISTING">
options         SHMSEG=16       # max shared mem id&#39;s per process
options         SHMMNI=32       # max shared mem id&#39;s per system
options         SHMMAX=2097152  # max shared memory segment size (bytes)
options         SHMALL=4096     # max amount of shared memory (pages)
    
</pre>
                </td>
              </tr>
            </table>
          </div>

          <div class="SECT3">
            <hr />

            <h4 class="SECT3"><a name="SUBSUBSEC-MEMORIA-CONDIVISA-LINUX"
            id="SUBSUBSEC-MEMORIA-CONDIVISA-LINUX"></a>9.6.4.8. Memoria
            condivisa con Linux</h4>

            <p>Per configurare la memoria condivisa con Linux &egrave;
            necessario editare il file <em>/etc/sysctl.conf</em></p>

            <table border="0" bgcolor="#E0E0E0" width="100%">
              <tr>
                <td>
                  <pre class="PROGRAMLISTING">
kernel.shmall=2097152
kernel.shmmni=32
kernel.shmmax=16777216
    
</pre>
                </td>
              </tr>
            </table>
          </div>

          <div class="SECT3">
            <hr />

            <h4 class="SECT3"><a name="SUBSUBSEC-MEMORIA-CONDIVISA-SOLARIS"
            id="SUBSUBSEC-MEMORIA-CONDIVISA-SOLARIS"></a>9.6.4.9. Memoria
            condivisa con Solaris</h4>

            <p>Aggiungere le seguenti linee nel file
            <em>/etc/system</em></p>

            <table border="0" bgcolor="#E0E0E0" width="100%">
              <tr>
                <td>
                  <pre class="PROGRAMLISTING">
set shmsys:shminfo_shmmax=2097152
set shmsys:shminfo_shmmni=32
set shmsys:shminfo_shmseg=16
    
</pre>
                </td>
              </tr>
            </table>

            <p>naturalmente &egrave; necessario eseguire un riavvio del
            Sistema dopo aver modificato il file <em>/etc/system</em></p>
          </div>
        </div>

        <div class="SECT2">
          <hr />

          <h3 class="SECT2"><a name="SUBSEC-NULL" id=
          "SUBSEC-NULL"></a>9.6.5. <em>null</em> storage</h3>

          <p><em>Null</em> &egrave; uno schema di Disk Storage fittizio,
          viene utilizzato nei casi in cui si desidera che Squid effettui
          il caching nella sola memoria, in questo caso non verr&agrave;
          salvata alcuna copia degli oggetti su disco. Viene anche
          utilizzato per eseguire dei test prestazionali, utilizzare uno
          schema di Disk Storage come <em>null</em> consente di aumentare
          le prestazioni in maniera drastica. La sintassi del TAG
          <em>cache_dir</em> per il Disk Storage <em>null</em> &eacute;</p>

          <table border="0" bgcolor="#E0E0E0" width="100%">
            <tr>
              <td>
                <pre class="PROGRAMLISTING">
cache_dir null Directory-Name [options]
   
</pre>
              </td>
            </tr>
          </table>

          <p>Dove <em>Directory-Name</em> identifica una top-level
          directory fittizia, ecco un esempio</p>

          <table border="0" bgcolor="#E0E0E0" width="100%">
            <tr>
              <td>
                <pre class="PROGRAMLISTING">
cache_dir null /tmp
   
</pre>
              </td>
            </tr>
          </table>
        </div>

        <div class="SECT2">
          <hr />

          <h3 class="SECT2"><a name="SUBSEC-COSS" id=
          "SUBSEC-COSS"></a>9.6.6. <em>coss</em> storage</h3>

          <p><em>Coss</em> &egrave; l&#39;acronimo di <em>Cyclic Object
          Storage System Scheme</em>, questo modello di Storage utilizza un
          singolo file per memorizzare tutti gli oggetti e quando il file
          raggiunge le sue dimensioni massime, Squid si occupa di ripartire
          dall&#39;inizio del file stesso riscivendo tutti i dati presenti
          nel file. Il file potrebbe anche essere rappresentato con un
          <em>raw disk device</em>. Sfortunatamente si tratta di uno schema
          di storage system ancora a livello sperimentale ed il suo
          sviluppo procede piuttosto lentamente. Tutte le operazioni di
          disk I/O vengono gestite in modalit&agrave; asincrona ricorrendo
          al modello POSIX AIO, in particolare utilizza le chiamate di
          sistema aio_read() e aio_write(). La gestione asincrona, come
          abbiamo visto, consente di evitare il blocco del processo
          principale di Squid durante le operazioni di disk I/O,
          <em>coss</em> &egrave; al momento disponibile per FreeBSD,
          Solaris e Linux e non &eacute; invece disponibile sulle
          piattaforme Windows. La sintassi del TAG <em>cache_dir</em> per
          il Disk Storage <em>coss</em> &eacute;</p>

          <table border="0" bgcolor="#E0E0E0" width="100%">
            <tr>
              <td>
                <pre class="PROGRAMLISTING">
cache_dir coss File-Name MBytes max-size=n [options] [block-size=b]
   
</pre>
              </td>
            </tr>
          </table>

          <p>dove <em>File-Name</em> identifica il file contenente il Disk
          Storage, l&#39;opzione comune <em>max-size</em> deve essere
          sempre specificata, <em>block-size</em> &eacute; la dimensione
          del blocco di allocazione utilizzato da <em>coss</em>, ed infine
          <em>MBytes</em> &egrave; la dimensione massima espressa in MBytes
          di questo Disk Storage. Ecco alcuni esempi</p>

          <table border="0" bgcolor="#E0E0E0" width="100%">
            <tr>
              <td>
                <pre class="PROGRAMLISTING">
cache_dir coss /usr/local/squid/var/cache/CossFile01 2048 max-size=65536 block-size=2048
cache_dir coss /usr/local/squid/var/cache/CossFile02 6744 max-side=1000000 block-size=2048
   
</pre>
              </td>
            </tr>
          </table>

          <p><em>coss</em> per il momento &egrave; in grado di supportare
          il solo algoritmo LRU a riguardo del Memory e Cache Replacement
          Policy</p>
        </div>

        <div class="SECT2">
          <hr />

          <h3 class="SECT2"><a name="SUBSEC-SCELTA-DEL-DISK" id=
          "SUBSEC-SCELTA-DEL-DISK"></a>9.6.7. Scelta del Disk storage
          pi&ugrave; adatto</h3>

          <p>Quale schema di Storage scegliere? il mio sistema supporta
          <em>aufs</em>? con il sistema Operativo che utilizzo
          <em>aufs</em> &egrave; pi&ugrave; veloce di <em>diskd</em> o
          viceversa? Gli interrogativi sono molti cos&igrave; come sono
          molti i fattori che concorrono a pieno titolo alla scelta del
          modello di Disk Storage pi&ugrave; adatto per il nostro Sistema,
          tra i vari fattori citiamo</p>

          <ul>
            <li>
              <p>Il tipo di Sistema Operativo</p>
            </li>

            <li>
              <p>il tipo di utilizzo che si intende fare di Squid</p>
            </li>

            <li>
              <p>il numero di transazioni previste</p>
            </li>
          </ul>

          <p>La seguente tabella riassume alcune linee guida da seguire per
          effettuare tale scelta</p>

          <div class="INFORMALTABLE">
            <a name="AEN2118" id="AEN2118"></a>

            <table border="1" class="CALSTABLE">
              <tbody>
                <tr>
                  <td width="25%" align="center" valign="top">
                    <p>I/O sincrono</p>
                  </td>

                  <td width="25%" align="center" valign="top">
                    <p>I/O asincrono</p>
                  </td>

                  <td width="25%" align="center" valign="top">
                    <p>I/O fittizio</p>
                  </td>

                  <td width="25%" align="center" valign="top"></td>
                </tr>

                <tr>
                  <td width="25%" align="center" valign="top">
                    <p>ufs</p>
                  </td>

                  <td width="25%" align="center" valign="top">
                    <p>-</p>
                  </td>

                  <td width="25%" align="center" valign="top">
                    <p>-</p>
                  </td>

                  <td width="25%" align="center" valign="top">
                    <ul>
                      <li>
                        <p>singola cache</p>
                      </li>

                      <li>
                        <p>poche transazioni/sec</p>
                      </li>
                    </ul>
                  </td>
                </tr>

                <tr>
                  <td width="25%" align="center" valign="top">
                    <p>-</p>
                  </td>

                  <td width="25%" align="center" valign="top">
                    <p>aufs</p>
                  </td>

                  <td width="25%" align="center" valign="top">
                    <p>-</p>
                  </td>

                  <td width="25%" align="center" valign="top">
                    <ul>
                      <li>
                        <p>cache multiple</p>
                      </li>

                      <li>
                        <p>molte transazioni/sec</p>
                      </li>

                      <li>
                        <p>sistema operativo con supporto
                        <em>POSIX-threads</em></p>
                      </li>
                    </ul>
                  </td>
                </tr>

                <tr>
                  <td width="25%" align="center" valign="top">
                    <p>-</p>
                  </td>

                  <td width="25%" align="center" valign="top">
                    <p>awin32</p>
                  </td>

                  <td width="25%" align="center" valign="top">
                    <p>-</p>
                  </td>

                  <td width="25%" align="center" valign="top">
                    <ul>
                      <li>
                        <p>cache multiple</p>
                      </li>

                      <li>
                        <p>molte transazioni/sec</p>
                      </li>

                      <li>
                        <p>sistema operativo Windows</p>
                      </li>
                    </ul>
                  </td>
                </tr>

                <tr>
                  <td width="25%" align="center" valign="top">
                    <p>-</p>
                  </td>

                  <td width="25%" align="center" valign="top">
                    <p>diskd</p>
                  </td>

                  <td width="25%" align="center" valign="top">
                    <p>-</p>
                  </td>

                  <td width="25%" align="center" valign="top">
                    <ul>
                      <li>
                        <p>cache multiple</p>
                      </li>

                      <li>
                        <p>molte transazioni/sec</p>
                      </li>

                      <li>
                        <p>sistema operativo con supporto
                        <em>USER-threads</em></p>
                      </li>
                    </ul>
                  </td>
                </tr>

                <tr>
                  <td width="25%" align="center" valign="top">
                    <p>-</p>
                  </td>

                  <td width="25%" align="center" valign="top">
                    <p>-</p>
                  </td>

                  <td width="25%" align="center" valign="top">
                    <p>null</p>
                  </td>

                  <td width="25%" align="center" valign="top">
                    <ul>
                      <li>
                        <p>modalit&agrave; solo proxy</p>
                      </li>

                      <li>
                        <p>reverse proxy</p>
                      </li>
                    </ul>
                  </td>
                </tr>
              </tbody>
            </table>
          </div>
          <br />
          <br />

          <p>Un altro fattore che pu&ograve; influire significativamente
          sul buon funzionamento del sistema di Disk Storage &eacute; il
          tipo di File System fisico sul quale viene ad appoggiarsi Squid.
          Uno spunto molto interessante a riguardo pu&ograve; essere
          fornito da uno studio di Duane Wessels che &egrave; liberamente
          disponibile in internet alla URLs <a href=
          "http://conferences.oreillynet.com/presentations/os2002/wessels_duane.ppt"
             target=
             "_top">http://conferences.oreillynet.com/presentations/os2002/wessels_duane.ppt</a>.</p>
        </div>

        <div class="SECT2">
          <hr />

          <h3 class="SECT2"><a name="SUBSEC-ESEMPI-DI-CONFIGURAZIONE-DISK"
          id="SUBSEC-ESEMPI-DI-CONFIGURAZIONE-DISK"></a>9.6.8. Esempi di
          configurazione</h3>

          <p>Vista la complessit&agrave; e l&#39;importanza
          dell&#39;argomento trattato, in questo paragrafo ci occuperemo di
          mostrare al lettore alcuni esempi di configurazione di un sistema
          di Disk Storage efficente con Squid, tratteremo anche le
          eventuali ottimizzazioni che sono relative al Sistema Operativo
          ospitante.</p>

          <div class="SECT3">
            <hr />

            <h4 class="SECT3"><a name="SUBSUBSEC-CONFIGURARE-DISKD-FREEBSD"
            id="SUBSUBSEC-CONFIGURARE-DISKD-FREEBSD"></a>9.6.8.1.
            Configurare <em>diskd</em> con FreeBSD</h4>

            <p>In questo caso di studio aumenteremo le performance della
            disk I/O configurando un sistema di webcache con 3*7500 MB di
            <em>cache_dir</em> (<em>L1</em>=16, <em>L2</em>=256)
            utilizzando il <em>diskd</em> come sistema di Disk Storage,
            questa configurazione per consentire di ottenere le performance
            sperate, richiede la compilazione del Kernel di FreeBSD, il
            file da editare che contiene tutte le direttive per compilare
            il Kernel &egrave;</p>

            <table border="0" bgcolor="#E0E0E0" width="100%">
              <tr>
                <td>
                  <pre class="PROGRAMLISTING">
/usr/src/sys/i386/conf/MIOKERNEL
    
</pre>
                </td>
              </tr>
            </table>

            <p>dove MIOKERNEL &egrave; il file che include tutte le
            impostazioni del Kernel, per compilare correttamente il Kernel
            di FreeBSD consultare sempre il <a href=
            "http://www.freebsd.org/doc/en_US.ISO8859-1/books/handbook/kernelconfig.html"
               target="_top">FreeBSD Handbook</a> oppure, le istruzioni in
               lingua italiana contenute nel mio libro <a href=
               "http://www.merlinobbs.net/FreeBSD/HTML/lavorare-con-il-kernel.html"
               target="_top">Note su FreeBSD</a>.</p>

            <p>Nel file di configurazione del Kernel, relativamente alla
            corretta configurazione della <em>Shared Memory</em>
            (<em>SYSVSHM</em>), devono essere contenute le seguenti linee
            (Squid FAQ alla URLs <a href=
            "http://www.squid-cache.org/Doc/FAQ/FAQ-22.html#ss22.7" target=
            "_top">http://www.squid-cache.org/Doc/FAQ/FAQ-22.html#ss22.7</a>)</p>

            <table border="0" bgcolor="#E0E0E0" width="100%">
              <tr>
                <td>
                  <pre class="PROGRAMLISTING">
options SYSVSHM           # SYSV-style shared memory
                          # Squid Shared Memory DiskD Tuning
options SHMSEG=16         # max shared mem id&#39;s per process
options SHMMNI=32         # max shared mem id&#39;s per system
options SHMMAX=2097152    # max shared memory segment size (bytes)
options SHMALL=4096       # max amount of shared memory (pages)
    
</pre>
                </td>
              </tr>
            </table>

            <p>nel file di configurazione del Kernel, relativamente alla
            configurazione della <em>Message Queues</em>
            (<em>SYSVMSG</em>), devono essere contenute le seguenti linee
            (Cfr. Squid FAQ alla URLs <a href=
            "http://www.squid-cache.org/Doc/FAQ/FAQ-22.html#ss22.6" target=
            "_top">http://www.squid-cache.org/Doc/FAQ/FAQ-22.html#ss22.6</a>)</p>

            <table border="0" bgcolor="#E0E0E0" width="100%">
              <tr>
                <td>
                  <pre class="PROGRAMLISTING">
options SYSVMSG           # SYSV-style message queues
                          # Squid Message Queues DiskD Tuning
options MSGMNB=8192       # max of bytes in a queue
options MSGMNI=40         # number of message queue identifiers
options MSGSEG=512        # number of message segments per queue
options MSGSSZ=64         # size of a message segment
options MSGTQL=2048       # max messages in system
    
</pre>
                </td>
              </tr>
            </table>

            <p>nel file di configurazione del Kernel possiamo anche
            definire un&#39;altra opzione che ci consentir&agrave;
            senzadubbio di migliorare ulteriormente le performance del
            Sistema (l&#39;indicazione deve essere inserita a seguire alla
            sezione parallelport)</p>

            <table border="0" bgcolor="#E0E0E0" width="100%">
              <tr>
                <td>
                  <pre class="PROGRAMLISTING">
# Note that you will probably want to bump up NMBCLUSTERS a lot to use
# NMBCLUSTERS and MAXUSERS (and NMBUFS) from your kernel config
options NMBCLUSTERS=32768
# the number of NMBCLUSTERS, depending on other constraints)
    
</pre>
                </td>
              </tr>
            </table>

            <p>Il valore di 32768 &egrave; riferito ad un Sistema con 1 Gb
            di RAM fisica, il valore di default per NMBCLUSTERS &egrave;
            16384. Dopo aver inserito queste entry nel file di
            configurazione del Kernel di FreeBSD, si proceder&agrave; con
            la compilazione vera e propria del nuovo Kernel a questo punto
            ottimizzato per eseguire Squid</p>

            <table border="0" bgcolor="#E0E0E0" width="100%">
              <tr>
                <td>
                  <pre class="PROGRAMLISTING">
# cd /usr/src
# make buildkernel KERNCONF=MIOKERNEL
# make installkernel KERNCONF=MIOKERNEL
# reboot
    
</pre>
                </td>
              </tr>
            </table>

            <p>al successivo avviamento la nostra macchina FreeBSD
            sar&agrave; finalmente pronta per la compilazione e
            l&#39;installazione di Squid Proxy Server. Ritornando
            nuovamente alla configurazione di Squid, per utilizzare
            <em>diskd</em> come sistema Disk Storage &egrave; necessario
            compilare Squid utilizzando le seguenti opzioni di
            configure</p>

            <table border="0" bgcolor="#E0E0E0" width="100%">
              <tr>
                <td>
                  <pre class="PROGRAMLISTING">
# ./configure --enable-storeio=diskd,ufs 
    
</pre>
                </td>
              </tr>
            </table>

            <p>Il port di FreeBSD prevede l&#39;abilitazione di questo tipo
            di opzione come default e comunque, se si vuole selezionare
            alcune delle opzioni <a href="#SEC-FREEBSD">esotiche</a> di
            configure, &egrave; necessario digitare i seguenti comandi</p>

            <table border="0" bgcolor="#E0E0E0" width="100%">
              <tr>
                <td>
                  <pre class="PROGRAMLISTING">
# cd /usr/ports/www/squid
# make config
# make 
# make install clean
    
</pre>
                </td>
              </tr>
            </table>
          </div>

          <div class="SECT3">
            <hr />

            <h4 class="SECT3"><a name="SUBSUBSEC-CONFIGURARE-UFS" id=
            "SUBSUBSEC-CONFIGURARE-UFS"></a>9.6.8.2. Configurare
            <em>ufs</em> (multipiattaforma)</h4>

            <p>A riguardo la configurazione &egrave; piuttosto semplice in
            quanto si limita alla sola modifica del file
            <em>squid.conf</em></p>

            <table border="0" bgcolor="#E0E0E0" width="100%">
              <tr>
                <td>
                  <pre class="PROGRAMLISTING">
cache_dir ufs /usr/local/squid/var/cache 6744 16 256
    
</pre>
                </td>
              </tr>
            </table>

            <p>si tratta dello schema di storage di default di Squid e
            pu&ograve; essere utilizzato per qualsiasi tipo di
            configurazione</p>
          </div>

          <div class="SECT3">
            <hr />

            <h4 class="SECT3"><a name="SUBSUBSEC-CONFIGURARE-AUFS-LINUX"
            id="SUBSUBSEC-CONFIGURARE-AUFS-LINUX"></a>9.6.8.3. Configurare
            <em>aufs</em> con Linux</h4>

            <p>A riguardo la configurazione &egrave; piuttosto semplice in
            quanto si limita alla sola modifica del file
            <em>squid.conf</em></p>

            <table border="0" bgcolor="#E0E0E0" width="100%">
              <tr>
                <td>
                  <pre class="PROGRAMLISTING">
cache_dir aufs /usr/local/squid/var/cache 6744 16 256
    
</pre>
                </td>
              </tr>
            </table>

            <p>trattandosi dello stesso schema di storage di <em>ufs</em>
            sar&agrave; sufficente rileggere la configurazione di Squid
            (<em>squid -k reconfigure</em>)</p>
          </div>

          <div class="SECT3">
            <hr />

            <h4 class="SECT3"><a name=
            "SUBSUBSEC-CONFIGURARE-AWIN32-WINDOWS" id=
            "SUBSUBSEC-CONFIGURARE-AWIN32-WINDOWS"></a>9.6.8.4. Configurare
            <em>awin32</em> con Windows</h4>

            <p>A riguardo la configurazione &egrave; piuttosto semplice in
            quanto si limita alla sola modifica del file
            <em>squid.conf</em></p>

            <table border="0" bgcolor="#E0E0E0" width="100%">
              <tr>
                <td>
                  <pre class="PROGRAMLISTING">
cache_dir awin32 c:/squid/var/cache 6744 16 256
    
</pre>
                </td>
              </tr>
            </table>

            <p>trattandosi dello stesso schema di storage di <em>ufs</em>
            sar&agrave; sufficente rileggere la configurazione di Squid
            (<em>squid -k reconfigure</em>)</p>
          </div>
        </div>
      </div>

      <div class="SECT1">
        <hr />

        <h2 class="SECT1"><a name="SEC-MEMORY-STORAGE" id=
        "SEC-MEMORY-STORAGE"></a>9.7. Memory storage</h2>

        <p>Abbiamo detto anche in <a href=
        "#SUBSEC-NOTE-SULLA-RAM">precedenza</a> che Squid utilizza
        un&#39;elevata quantit&agrave; di memoria RAM per garantire le
        massime prestazioni. In Squid 2.5, per ogni oggetto presente su
        disco viene mantenuta in memoria una <em>StoreEntry</em> di 72 byte
        (104 byte nei sistemi a 64 bit). Un apposita area di memoria
        definita con il TAG <em>cache_mem</em> di <em>squid.conf</em> viene
        riservata per contenere i seguenti tipi di oggetto</p>

        <ul>
          <li>
            <p><em>In-Transit objects</em></p>
          </li>

          <li>
            <p><em>Hot objects</em></p>
          </li>

          <li>
            <p><em>Negative-Cached objects</em></p>
          </li>
        </ul>

        <p>Gli oggetti di tipo <em>In-Transit</em> hanno sempre
        priorit&agrave; sugli altri. Quando &egrave; necessario dello
        spazio addizionale per i dati in arrivo, gli oggetti di tipo
        <em>Negative-Cached</em> e <em>Hot</em> vengono rilasciati.
        Possiamo anche dire che gli oggetti di tipo
        <em>Negative-Cached</em> e <em>Hot</em> possono occupare solamente
        lo spazio inutilizzato che quindi non &egrave; necessario agli
        oggetti del tipo <em>In-Transit</em>.</p>

        <div class="SECT2">
          <hr />

          <h3 class="SECT2"><a name=
          "SUBSEC-PARAMETRI-DI-CONFIGURAZIONE-MEM" id=
          "SUBSEC-PARAMETRI-DI-CONFIGURAZIONE-MEM"></a>9.7.1. Parametri di
          configurazione</h3>

          <p>La configurazione del Memory Storage &eacute; controllabile
          tramite alcuni parametri di configurazione inclusi nel file
          <em>squid.conf</em></p>

          <table border="0" bgcolor="#E0E0E0" width="100%">
            <tr>
              <td>
                <pre class="PROGRAMLISTING">
cache_mem bytes 
high_memory_warning bytes
maximum_object_size bytes
minimum_object_size bytes
maximum_object_size_in_memory bytes
   
</pre>
              </td>
            </tr>
          </table>

          <p>il TAG <em>cache_mem</em></p>

          <p>specifica la quantit&agrave; massima di memoria utilizzabile
          da Squid per contenere gli oggetti di tipo <em>In-Transit</em>,
          <em>Hot</em> e <em>Negative-Cached</em>, l&#39;allocazione di
          memoria avviene a blocchi di 4 KByte. In caso di
          necessit&agrave;, il limite specificato pu&ograve; essere
          momentaneamente superato, il valore predefinito &eacute; 8 MByte,
          ad esempio</p>

          <table border="0" bgcolor="#E0E0E0" width="100%">
            <tr>
              <td>
                <pre class="PROGRAMLISTING">
cache_mem 64 MB
   
</pre>
              </td>
            </tr>
          </table>

          <p>il TAG <em>cache_mem</em> non determina l&#39;occupazione
          massima di memoria che viene effettuata da Squid. Squid infatti
          utilizza altra memoria per eseguire le altre operazioni e diversi
          I/O buffer (scrittura dei file su disco o una richiesta HTTP),
          per eventuali ed ulteriori dettagli riferisi alla relativa
          sezione nelle <a href=
          "http://www1.it.squid-cache.org/Doc/FAQ/FAQ-8.html#ss8.4" target=
          "_top">FAQ di Squid</a>.</p>

          <p>il TAG <em>high_memory_warning</em></p>

          <p>viene utilizzato per tenere sotto controllo l&#39;utilizzo
          della memoria</p>

          <table border="0" bgcolor="#E0E0E0" width="100%">
            <tr>
              <td>
                <pre class="PROGRAMLISTING">
high_memory_warning 80 MB
   
</pre>
              </td>
            </tr>
          </table>

          <p>se l&#39;utilizzo della memoria supera i valori da noi
          impostati, Squid registra un WARNING nel file <em>cache.log</em>
          anche se il <em>debug level</em> &egrave; impostato a 0.</p>

          <p>il TAG <em>maximum_object_size</em></p>

          <p>specifica la dimensione massima degli oggetti memorizzabili
          nel Disk Storage, un valore elevato per questo parametro fornisce
          un alto rapporto di BYTE hits, i valori bassi forniscono una
          maggiore responsivit&aacute; della webcache a discapito di un
          maggiore consumo di banda Internet. Il valore predefinito
          &eacute; 4096 KByte, ad esempio</p>

          <table border="0" bgcolor="#E0E0E0" width="100%">
            <tr>
              <td>
                <pre class="PROGRAMLISTING">
maximum_object_size 8192 Kb
   
</pre>
              </td>
            </tr>
          </table>

          <p>il TAG <em>mimum_object_size</em></p>

          <p>specifica la dimensione minima degli oggetti memorizzabili nel
          Disk Storage, il valore predefinito &eacute; 0 KByte, ad
          esempio</p>

          <table border="0" bgcolor="#E0E0E0" width="100%">
            <tr>
              <td>
                <pre class="PROGRAMLISTING">
mimum_object_size 1 Kb
   
</pre>
              </td>
            </tr>
          </table>

          <p>il TAG <em>maximum_object_size_in_memory</em></p>

          <p>specifica la dimensione massima degli oggetti conservabili nel
          Memory Storage. &Egrave; raccomandabile impostare questo
          parametro con un valore che consenta la memorizzazione degli
          oggetti con un elevato hit rate, senza per&ograve; sovraccaricare
          il Memory Storage con oggetti di dimensioni elevate. Il valore
          predefinito &eacute; 8 KByte, ad esempio</p>

          <table border="0" bgcolor="#E0E0E0" width="100%">
            <tr>
              <td>
                <pre class="PROGRAMLISTING">
maximum_object_size_in_memory 64 Kb
   
</pre>
              </td>
            </tr>
          </table>
        </div>
      </div>

      <div class="SECT1">
        <hr />

        <h2 class="SECT1"><a name="SEC-CACHE-REPLACEMENT-POLICY" id=
        "SEC-CACHE-REPLACEMENT-POLICY"></a>9.8. Memory e Cache Replacement
        Policy</h2>

        <p>La memory e la cache replacement policy determina quali oggetti
        devono essere eliminati e/o sostituiti quando &egrave; necessario
        del nuovo spazio nel Memory Storage o nel Disk Storage. Attualmente
        vengono implementate 4 differenti cache replacement policy</p>

        <ul>
          <li>
            <p><em>LRU</em> - Policy originaria di Squid basata su liste
            LRU</p>
          </li>

          <li>
            <p><em>heap LRU</em> - LRU implementata usando un heap</p>

            <p><em>LRU</em> e <em>heap LRU</em> conservano gli oggetti
            referenziati pi&ugrave; recentemente</p>
          </li>

          <li>
            <p><em>heap GDSF</em> - Greedy-Dual Size Frequency</p>

            <p><em>Heap GDSF</em> ottimizza l&#39;hit rate conservando in
            cache gli oggetti piccoli e pi&ugrave; frequenti in modo da
            avere maggiori probabilit&agrave; di hit. Fornisce dei minori
            byte hit rate rispetto a <em>heap LFUDA</em> in quanto scarta
            gli oggetti di maggiori dimensioni.</p>
          </li>

          <li>
            <p><em>heap LFUDA</em> - Least Frequently Used con aging
            dinamico</p>

            <p><em>Heap LFUDA</em> mantiene gli oggetti pi&ugrave;
            frequenti in cache a prescindere dalle dimensioni, ottimizzando
            il byte hit rate a discapito dell&#39;hit rate, impedendo a
            molti oggetti piccoli meno frequenti di essere cached.</p>
          </li>
        </ul>

        <p>Utilizzando <em>heap LFUDA</em>, il parametro
        <em>maximum_object_size</em> di <em>squid.conf</em> deve essere
        aumentato oltre il suo default di 4096 KB in modo da massimizzarne
        i potenziali miglioramenti al byte hit rate. Per maggiori
        informazioni su GDSF e LFUDA consultare le seguenti URLs: <a href=
        "http://www.hpl.hp.com/techreports/1999/HPL-1999-69.html" target=
        "_top">http://www.hpl.hp.com/techreports/1999/HPL-1999-69.html</a>
        e <a href=
        "http://fog.hpl.external.hp.com/techreports/98/HPL-98-173.html"
        target=
        "_top">http://fog.hpl.external.hp.com/techreports/98/HPL-98-173.html</a>.
        La scelta dei tipi di Replacement Policy da attivare, viene
        effettuata al momento della configurazione dei parametri di
        compilazione di Squid</p>

        <table border="0" bgcolor="#E0E0E0" width="100%">
          <tr>
            <td>
              <pre class="PROGRAMLISTING">
./configure  --enable-removal-policies=&quot;elenco policy&quot;
  
</pre>
            </td>
          </tr>
        </table>

        <p>dove l&#39;elenco delle Policy da attivare contiene i nomi (case
        sensitive) dalle cartelle presenti nel source tree di Squid che ne
        contengono appunto i sorgenti. La Replacement Policy compilata di
        default &eacute; <em>lru</em>.</p>

        <table border="0" bgcolor="#E0E0E0" width="100%">
          <tr>
            <td>
              <pre class="PROGRAMLISTING">
./configure --enable-removal-policies=&quot;lru heap&quot;
  
</pre>
            </td>
          </tr>
        </table>

        <p>nell&#39;esempio precedente abbiamo selezionato le Replacement
        Policy <em>lru</em> e <em>heap</em></p>

        <div class="SECT2">
          <hr />

          <h3 class="SECT2"><a name="SUBSEC-CACHE-REPLACEMENT-POLICY-REPL"
          id="SUBSEC-CACHE-REPLACEMENT-POLICY-REPL"></a>9.8.1. Parametri di
          configurazione</h3>

          <p>La configurazione delle Replacement policy in Squid avviene
          tramite i seguenti parametri</p>

          <table border="0" bgcolor="#E0E0E0" width="100%">
            <tr>
              <td>
                <pre class="PROGRAMLISTING">
cache_replacement_policy policy
memory_replacement_policy policy
cache_swap_low  low-water-mark
cache_swap_high high-water-mark
   
</pre>
              </td>
            </tr>
          </table>

          <p>il TAG <em>cache_replacement_policy</em></p>

          <p>specifica la replacement policy da utilizzare per determinare
          quali oggetti devono essere eliminati e/o sostituiti quando
          &egrave; necessario del nuovo spazio nel <em>Disk Storage</em>.
          Il valore predefinito &eacute; <em>lru</em>, i valori possibili
          sono</p>

          <table border="0" bgcolor="#E0E0E0" width="100%">
            <tr>
              <td>
                <pre class="PROGRAMLISTING">
lru
heap GDSF
heap LFUDA
heap LRU
   
</pre>
              </td>
            </tr>
          </table>

          <p>ad esempio</p>

          <table border="0" bgcolor="#E0E0E0" width="100%">
            <tr>
              <td>
                <pre class="PROGRAMLISTING">
cache_replacement_policy heap LFUDA
   
</pre>
              </td>
            </tr>
          </table>

          <p>il TAG <em>memory_replacement_policy</em></p>

          <p>specifica la replacement policy da utilizzare per determinare
          quali oggetti devono essere eliminati e/o sostituiti quando
          &egrave; necessario del nuovo spazio nel <em>Memory Storage</em>.
          Il valore predefinito &eacute; <em>lru</em>, i valori possibili
          sono</p>

          <table border="0" bgcolor="#E0E0E0" width="100%">
            <tr>
              <td>
                <pre class="PROGRAMLISTING">
lru
heap GDSF
heap LFUDA
heap LRU
   
</pre>
              </td>
            </tr>
          </table>

          <p>ad esempio</p>

          <table border="0" bgcolor="#E0E0E0" width="100%">
            <tr>
              <td>
                <pre class="PROGRAMLISTING">
memory_replacement_policy heap GDSF
   
</pre>
              </td>
            </tr>
          </table>

          <p>il TAG <em>cache_swap_low</em></p>

          <p>specifica il valore ottimale di percentuale di utilizzo del
          Disk Storage desiderato, quando tale soglia viene superata, le
          Policy di Replacement vengono attivate. Il valore predefinito
          &eacute; 90%, ad esempio</p>

          <table border="0" bgcolor="#E0E0E0" width="100%">
            <tr>
              <td>
                <pre class="PROGRAMLISTING">
cache_swap_low 85
   
</pre>
              </td>
            </tr>
          </table>

          <p>il TAG <em>cache_swap_high</em></p>

          <p>specifica il valore massimo di percentuale di utilizzo del
          Disk Storage desiderato, quando tale soglia viene avvicinata, le
          Policy di Replacement vengono applicate in modo maggiormente
          aggressivo. Il valore predefinito &eacute; 95%, ad esempio</p>

          <table border="0" bgcolor="#E0E0E0" width="100%">
            <tr>
              <td>
                <pre class="PROGRAMLISTING">
cache_swap_high 90
   
</pre>
              </td>
            </tr>
          </table>
        </div>
      </div>

      <div class="SECT1">
        <hr />

        <h2 class="SECT1"><a name="SEC-REGOLE-DI-DIMENSIONAMENTO-STORE" id=
        "SEC-REGOLE-DI-DIMENSIONAMENTO-STORE"></a>9.9. Indicazione
        dimensionamento del cache store</h2>

        <p>Per dimensionare correttamente il Cache Store di una webcache
        &egrave; necessario tener conto di vari aspetti. Il parametro di
        configurazione <em>cache_mem</em> specifica la quantit&agrave;
        massima di memoria utilizzabile da Squid per contenere gli oggetti
        di tipo <em>In-Transit</em>, <em>Hot</em> e
        <em>Negative-Cached</em>. Per identificare al meglio il fabbisogno
        di memoria fare riferimento al paragrafo <a href=
        "#SUBSEC-NOTE-SULLA-RAM">note sull&#39;utilizzo</a> della memoria
        RAM. Non dimentichiamo mai che il valore espresso in MByte
        assegnato al Memory Storage di Squid non dovrebbe mai superare 1/4
        della memoria RAM totale installata sul sistema. Se una macchina
        dispone di 196 Megabytes di RAM fisica &egrave; consigliabile
        impostare un TAG <em>cache_mem</em> pari a 49 MByte</p>

        <table border="0" bgcolor="#E0E0E0" width="100%">
          <tr>
            <td>
              <pre class="PROGRAMLISTING">
cache_mem 49 MB 
  
</pre>
            </td>
          </tr>
        </table>

        <p>un&#39;altra variabile da tenere in considerazione al fine di
        ottenere delle ottime performance, &egrave; quella di definire
        approssimativamente il numero degli utenti che dovranno utilizzare
        Squid. La letteratura disponibile in materia, consiglia una
        assegnazione di circa 20 MByte di spazio <em>cache_dir</em> per
        ogni utente che accede al proxy server Squid. Dunque 20 utenti
        contemporanei dovrebbero rappresentare 400 MByte di
        <em>cache_dir</em> storage</p>

        <table border="0" bgcolor="#E0E0E0" width="100%">
          <tr>
            <td>
              <pre class="PROGRAMLISTING">
cache_dir ufs /usr/local/squid/cache 400 16 256 
  
</pre>
            </td>
          </tr>
        </table>

        <p>un&#39;altra soluzione empirica &egrave; quella di definire 10
        MByte di RAM per ogni GByte di <em>cache_dir</em>, per le
        piattaforme a 64 bit come Alpha ed Opteron, il valore deve essere
        di 14 MByte per ogni GByte, pi&ugrave; ulteriori 10 - 20 MByte (15
        - 30 nei sistemi a 64 bit). La memoria fisica presente nel sistema
        dovrebbe essere pari ad almeno il doppio del risultato del
        precedente calcolo. Tenendo conto delle indicazioni sinora esposte
        si presenta uno schema di cache implementato con successo in
        un&#39;ambiente di livello enterprise.</p>

        <p><img src="images/dimensioni-cache.png" alt="" /></p>Le appliance
        di periferia sono collegate tramite linee dedicate e ridondano la
        relazione di parent tra le due cache principali, tra loro collegate
        in modalit&agrave; sibling (Cfr. capitolo sulle <a href=
        "#CHA-COMUNICARE-CON-ALTRI-PROXY-SERVER">gerarchie di cache</a>).
        Lo script di bilanciamento del carico &egrave; installato presso
        due server WPAD che sono configurati in modalit&agrave; round robin
        (Cfr. capitolo sul <a href=
        "#SEC-FAIL-OVER-E-LOAD-BALANCER">fail-over</a>).
        <br />
        <br />

        <p>Squid utilizza la memoria del Sistema Operativo per eseguire
        diverse operazioni</p>

        <ul>
          <li>
            <p>lettura o scrittura dei buffers su disco</p>
          </li>

          <li>
            <p>lettura o scrittura del network I/O buffer</p>
          </li>

          <li>
            <p>gestione dei contenuti della cache IP</p>
          </li>

          <li>
            <p>gestione dei contenuti della cache di FQDN (Fully Qualify
            Domain Name)</p>
          </li>

          <li>
            <p>misurazione del database NetDB ICMP</p>
          </li>

          <li>
            <p>informazioni sulle richieste</p>
          </li>

          <li>
            <p>collezioni delle statistiche</p>
          </li>
        </ul>

        <p>si raccomanda inoltre una ulteriore quantit&agrave; di memoria
        RAM che verr&agrave; utilizzata da parte del sistema operativo per
        aumentare le prestazioni dell&#39;I/O, nonch&egrave; per tutte le
        altre applicazioni che possono essere eseguite da un Sistema
        Operativo che esegue, oltre a Squid, anche altri servizi di rete.
        Un ulteriore livello minimo di memoria RAM &egrave; richiesto per
        il management dei processi, per il logging ed altre routines che
        vengono sempre eseguite dal Sistema Operativo.</p>
      </div>
    </div>

    <div class="CHAPTER">
      <hr />

      <h1><a name="CHA-CONTROLLI-DI-ACCESSO" id=
      "CHA-CONTROLLI-DI-ACCESSO"></a>Capitolo 10. Controlli di accesso</h1>

      <div class="SECT1">
        <h2 class="SECT1"><a name="SEC-PREAMBOLO-CONTR-ACC" id=
        "SEC-PREAMBOLO-CONTR-ACC"></a>10.1. Preambolo</h2>

        <p>Tra le funzioni primarie svolte da Squid citiamo quella di
        inteconnettere una rete privata ad Internet, &egrave; possibile
        implementare diverse politiche di utilizzo per definire le
        modalit&agrave; con cui tale accesso debba effettivamente avvenire.
        Definendo delle liste di controllo di accesso, acronimo di Access
        Control List o ACL con diverse regole associate, &eacute; possibile
        impedire o consentire agli utenti di accedere a determinati siti o
        a determinati contenuti ed ancora, &egrave; possibile limitare
        l&#39;accesso nell&#39;utilizzo di particolari protocolli di
        rete.</p>

        <p>Quando Squid elabora una richiesta in uscita, verifica nelle ACL
        se l&#39;accesso debba essere consentito o negato. &Eacute;
        estremamente importante pianificare a priori una strategia completa
        di accesso prima di iniziare a creare le ACL, solo in questo modo
        potremmo avere la certezza che le regole che si andranno ad
        implementare soddisfino le reali necessit&agrave;.</p>
      </div>

      <div class="SECT1">
        <hr />

        <h2 class="SECT1"><a name="SEC-ELEMENTI-DELLE-ACL" id=
        "SEC-ELEMENTI-DELLE-ACL"></a>10.2. Elementi che compongono le
        <em>ACL</em></h2>

        <p>Vediamo ora alcune informazioni sulla tipologia delle ACL che
        possono essere utilizzate da Squid, le tipologie sono aggiornate
        alla versione 2.5.STABLE5. Squid &egrave; oggi in grado di
        riconoscere i seguenti tipi di ACL</p>

        <ul>
          <li>
            <p><em>src</em></p>

            <p>indirizzo IP del sorgente (client)</p>
          </li>

          <li>
            <p><em>dst</em></p>

            <p>indirizzo IP di destinazione (server) o indirizzo IP del
            server di destinazione</p>
          </li>

          <li>
            <p><em>myip</em></p>

            <p>l&#39;indirizzo IP locale di una macchina che esegue una
            connessione client</p>
          </li>

          <li>
            <p><em>srcdomain</em></p>

            <p>il nome di dominio sorgente (client)</p>
          </li>

          <li>
            <p><em>dstdomain</em></p>

            <p>il nome di dominio di destinatizione (server)</p>
          </li>

          <li>
            <p><em>srcdom_regex</em></p>

            <p>espressione regolare che identifica un pattern contenuto in
            un indirizzo sorgente (client)</p>
          </li>

          <li>
            <p><em>dstdom_regex</em></p>

            <p>espressione regolare che identifica un pattern contenuto in
            un indirizzo di destinazione (server)</p>
          </li>

          <li>
            <p><em>time</em></p>

            <p>orario per giorno o giorno della settimana</p>
          </li>

          <li>
            <p><em>url_regex</em></p>

            <p>espressione regolare che identifica una URL</p>
          </li>

          <li>
            <p><em>urlpath_regex</em></p>

            <p>espressione regolare che identifica una URL-path, non viene
            specificato il protocollo e l&#39;eventuale hostname</p>
          </li>

          <li>
            <p><em>port</em></p>

            <p>seleziona e specifica il numero di porta per il server di
            destinazione (server)</p>
          </li>

          <li>
            <p><em>myport</em></p>

            <p>seleziona e specifica il numero di porta che il client
            utilizza per connettersi a</p>
          </li>

          <li>
            <p><em>proto</em></p>

            <p>protocollo di trasferimento (http, ftp, ecc.)</p>
          </li>

          <li>
            <p><em>method</em></p>

            <p>metodo di richiesta HTTP (get, post, ecc.)</p>
          </li>

          <li>
            <p><em>browser</em></p>

            <p>espressione regolare che identifica una richiesta che viene
            effettuata da un browser web specifico</p>
          </li>

          <li>
            <p><em>ident</em></p>

            <p>stringa che si combina con un nome utente</p>
          </li>

          <li>
            <p><em>ident_regex</em></p>

            <p>espressione regolare che identifica uno user name
            specifico</p>
          </li>

          <li>
            <p><em>src_as</em></p>

            <p>numero di un Sistema Autonomo sorgente (client)</p>
          </li>

          <li>
            <p><em>dst_as</em></p>

            <p>numero di un Sistema Autonomo di destinazione (server)</p>
          </li>

          <li>
            <p><em>proxy_auth</em></p>

            <p>autenticazione degli utenti attraverso un processo
            esterno</p>
          </li>

          <li>
            <p><em>proxy_auth_regex</em></p>

            <p>autenticazione degli utenti attraverso un processo
            esterno</p>
          </li>

          <li>
            <p><em>snmp_community</em></p>

            <p>definizione di una SNMP community string</p>
          </li>

          <li>
            <p><em>maxconn</em></p>

            <p>un limite al numero massimo di connessioni che arrivano da
            un singono indirizzo IP</p>
          </li>

          <li>
            <p><em>req_mime_type</em></p>

            <p>espressione regolare che identifica un header del tipo
            content-type incluso in una richiesta</p>
          </li>

          <li>
            <p><em>arp</em></p>

            <p>comparazione con un Ethernet (MAC) addres</p>
          </li>

          <li>
            <p><em>rep_mime_type</em></p>

            <p>espressione regolare che identifica un pattern che viene
            inviato come risposta (downloaded content) all&#39;intestazione
            del tipo content-type. Questo tipo di ACL pu&ograve; essere
            utilizzato unicamente nelle direttive http_reply_access ma non
            nelle direttive http_access</p>
          </li>

          <li>
            <p><em>external</em></p>

            <p>esegue il lookup ricorrendo a degli acl helper esterni che
            sono stati definiti da delle ACL del tipo external_acl_type</p>
          </li>
        </ul>
      </div>

      <div class="SECT1">
        <hr />

        <h2 class="SECT1"><a name="SEC-LISTE-DI-CONTROLLO-ACL" id=
        "SEC-LISTE-DI-CONTROLLO-ACL"></a>10.3. Capire il funzionamento
        delle <em>ACL</em></h2>

        <p>Nel paragrafo precedente abbiamo potuto visualizzare pi&ugrave;
        di 20 diversi tipo di ACL, questi possono riferirsi ad alcuni
        aspetti di una richiesta o anche di una risposta HTTP, tali aspetti
        possono variare dall&#39;indirizzo IP del client (<em>src</em>) al
        nome di origine del server di destinazione (<em>dstdomain</em>) per
        finire al metodo di richiesta HTTP (method). Abbiamo anche detto
        che le <em>Access Control List</em> vengono utilizzate per
        impostare svariati livelli di controllo per l&#39;accesso al proxy
        server Squid. E&#39; possibile impostare diversi tipi di ACL, il
        formato utilizzato da Squid nella realizzazione delle ACL &egrave;
        il seguente</p>

        <table border="0" bgcolor="#E0E0E0" width="100%">
          <tr>
            <td>
              <pre class="PROGRAMLISTING">
acl nomeacl tipoacl valore 
acl nomeacl tipoacl &quot;file&quot;
  
</pre>
            </td>
          </tr>
        </table>

        <p>quando al posto di un <em>valore</em> viene utilizzato un
        <em>file</em>, ogni ACL deve contenere un solo <em>file</em> per
        essere realizzata correttamente, tutte le espressioni utilizzate
        nelle ACL sono <em>case sensitive</em> e quindi sono importanti sia
        i caratteri <em>minuscoli</em> che i caratteri <em>maiuscoli</em>.
        Possiamo affermare che una ACL quindi si compone di tre
        componenti</p>

        <ol type="1">
          <li>
            <p>nome ACL</p>
          </li>

          <li>
            <p>tipo ACL</p>
          </li>

          <li>
            <p>valore per il tipo</p>
          </li>
        </ol>

        <p>vediamo alcuni esempi di ACL</p>

        <table border="0" bgcolor="#E0E0E0" width="100%">
          <tr>
            <td>
              <pre class="PROGRAMLISTING">
acl paperino src 10.10.10.1/32
acl pippo dstdomain www.sun.com
acl topolino method GET
  
</pre>
            </td>
          </tr>
        </table>

        <p>l&#39;elemento ACL dal nome <em>paperino</em> confronta una
        richiesta che proviene dall&#39;indirizzo IP <em>10.10.10.1</em>,
        l&#39;elemento ACL dal nome <em>pippo</em> contronta con la URL
        www.sun.com e l&#39;elemento ACL <em>topolino</em> confronta
        l&#39;esistenza di una richiesta HTTP del tipo GET. Possiamo
        impostare autorizzazioni e negazioni, per molti tipi di ACL
        &egrave; anche possibile esprimere un valore che contiene delle
        espressioni multiple</p>

        <table border="0" bgcolor="#E0E0E0" width="100%">
          <tr>
            <td>
              <pre class="PROGRAMLISTING">
acl gandalf src 10.10.10.4/32 10.10.10.24/32 10.10.10.84/32
acl legolas dstdomain www.sun.com www.linux.com www.cisco.com
acl aragorn method PUT POST
  
</pre>
            </td>
          </tr>
        </table>

        <p>l&#39;espressione multipla esegue una comparazione con una
        richiesta per ogni valore inserito nell&#39;espressione stessa. La
        ACL <em>gandalf</em> esegue una comparazione tra una richiesta
        proveniente dagli indirizzi IP <em>10.10.10.4</em>,
        <em>10.10.10.24</em> e <em>10.10.10.84</em>. La ACL
        <em>legolas</em> verifica la rispondenza con i siti di sun, linux e
        cisco, mentre la ACL <em>aragorn</em> esegue una comparazione sul
        tipo di richiesta HTTP ed in particolare che la stessa sia conforme
        ai metodi PUT o POST.</p>

        <p>Ora che abbiamo mostrato al lettore alcuni tipi di ACL,
        assicuriamoci di applicare queste ACL in maniera graduale e
        corretta. Abbiamo detto che una richiesta pu&ograve; essere
        <em>permessa</em> o <em>negata</em>, nell&#39;esempio seguente
        mostreremo una lista di regole che si riferiscono ad elementi di
        tipo ACL, facendo riferimento al nome assegnato alle ACL,
        concederemo o negheremo l&#39;accesso, in questo contesto &egrave;
        bene sottolineare che il nome della ACL diviene una parola
        chiave</p>

        <table border="0" bgcolor="#E0E0E0" width="100%">
          <tr>
            <td>
              <pre class="PROGRAMLISTING">
acl paperino src 10.10.10.1/32
acl pippo dstdomain www.sun.com
acl topolino method GET
http_access allow paperino
http_access deny pippo
http_access allow topolino
  
</pre>
            </td>
          </tr>
        </table>

        <p>le regole della ACL vengono rigorosamente applicate
        nell&#39;ordine nel quale sono state scritte, la decisione viene
        presa sempre quando la relativa ACL viene confrontata, ritornando
        sull&#39;esempio precedente analizzeremo alcune situazioni che
        possono venire a delinearsi.</p>

        <ul>
          <li>
            <p>Cosa accade quando un utente proveniente dall&#39;indirizzo
            IP <em>10.10.10.1</em> esegue il confronto con la ACL che
            specifica l&#39;indirizzo di destinazione
            <em>www.sun.com</em>?</p>

            <p>Squid incontra la ACL <em>paperino</em> e ne autorizza
            l&#39;accesso. La nostra richiesta viene confrontata con la ACL
            <em>paperino</em> che ne verifica l&#39;indirizzo IP di
            provenienza (<em>10.10.10.1</em>), in questo caso le regole
            successive non verranno verificate.</p>
          </li>

          <li>
            <p>Cosa accade invece se arriva una richiesta per il sito
            <em>www.sun.com</em> proveniente dall&#39;indirizzo IP
            <em>10.10.10.5</em>?</p>

            <p>la richiesta non confronta con la prima regola ACL ma
            collima con la seconda ACL <em>pippo</em>, la richiesta
            verr&agrave; dunque negata. In questo caso l&#39;utente
            ricever&agrave; un messaggio di richiesta negata da parte di
            Squid.</p>
          </li>

          <li>
            <p>Cosa accade se arriva una richiesta per il sito
            <em>www.linux.com</em> proveniente dall&#39;indirizzo IP
            <em>10.10.10.5</em>?</p>

            <p>La richiesta non confronta la prima ACL <em>paperino</em>,
            non si abbina nemmeno con la seconda ACL <em>pippo</em>
            perch&egrave; <em>www.linux.com</em> &egrave; differente da
            <em>www.sun.com</em> per&ograve; si confronta con la terza
            regola ACL <em>topolino</em> perch&egrave; il metodo di
            richiesta HTTP utilizzato &egrave; GET.</p>
          </li>
        </ul>

        <p>Le regole che abbiamo visto sino a questo momento sono state
        impostate con delle ACL semplici, non dimentichiamo per&ograve; che
        Squid &egrave; in grado di combinare in maniera molto interessante
        anche elementi multipli per singole ACL, possiamo ora mostrare un
        semplice esempio</p>

        <table border="0" bgcolor="#E0E0E0" width="100%">
          <tr>
            <td>
              <pre class="PROGRAMLISTING">
acl paperino src 10.10.10.1/32
acl pippo dstdomain www.sun.com
acl topolino method GET
http_access allow paperino pippo
http_access deny topolino
  
</pre>
            </td>
          </tr>
        </table>

        <p>tutte le richieste provenienti dall&#39;indirizzo IP
        <em>10.10.10.1</em> che contengono come URL di destinazione
        <em>www.sun.com</em> vengono autorizzate, il metodo di richiesta
        HTTP &egrave; del tipo GET e viene vietato nel momento in cui si
        esegue la verifica della prima ACL, poi tutto &egrave; poi
        consentito. Se la prima regola ACL non viene confrontata, il metodo
        di richiesta HTTP del tipo GET verr&agrave; bloccato e Squid
        avviser&agrave; gli utenti con un messaggio di richiesta
        negata.</p>

        <p>Ecco di seguito un esempio di regole ACL piuttosto frequente</p>

        <table border="0" bgcolor="#E0E0E0" width="100%">
          <tr>
            <td>
              <pre class="PROGRAMLISTING">
acl all src 0/0
acl servers 192.168.1.4/32 192.168.1.10/32 192.168.1.14/32
icp_access allow servers
icp_access deny all
  
</pre>
            </td>
          </tr>
        </table>

        <p>qui vediamo una relazione di parentela tra cache adiacenti che
        ricorrono al protocollo ICP, dove tutte le richieste provenienti
        dagli indirizzi IP 192.168.1.4, 192.168.1.10 e 192.168.1.14
        verranno soddisfatte, mentre quelle provenienti da altri indizzi
        verranno negate.</p>

        <p>Ecco di seguito un esempio che contiene una regola pi&ugrave;
        complessa</p>

        <table border="0" bgcolor="#E0E0E0" width="100%">
          <tr>
            <td>
              <pre class="PROGRAMLISTING">
acl gandalf src 10.10.10.4/32 10.10.10.24/32 10.10.10.84/32
acl legolas dstdomain www.sun.com www.linux.com www.cisco.com
acl aragorn method PUT POST
http_access deny gandalf legolas aragorn
http_access allow gandalf legolas
http_access deny aragorn
  
</pre>
            </td>
          </tr>
        </table>

        <p>queste tre linee autorizzando i client della ACL
        <em>gandalf</em> (<em>10.10.10.4</em>, <em>10.10.10.24</em> e
        <em>10.10.10.84</em>) ad accedere ai server specificati nella ACL
        <em>legolas</em> (www.sun.com, www.linux.com, and www.cisco.com) ma
        negano l&#39;utilizzo dei metodi HTTP del tipo PUT o POST. I client
        provenienti dalla ACL <em>gandalf</em> non sono autorizzati ad
        accedere agli altri server.</p>

        <p>Le ACL possono divenire lunghe e complicate, una buona regola da
        seguire per l&#39;inserimento delle ACL &egrave; quella di editare
        prima le regole specifiche e dopo quelle meno specifiche. Non
        dimentichiamo mai che, come gi&agrave; detto in precedenza, le
        regole ACL vengono sempre applicate in ordine. E&#39; buona norma
        negare una richiesta definendo una ACL specifica per poi concedere
        autorizzazione a tutte le altre ACL</p>

        <table border="0" bgcolor="#E0E0E0" width="100%">
          <tr>
            <td>
              <pre class="PROGRAMLISTING">
acl vietato www.nonautorizzato.it 
acl all src 0/0
http_access deny vietato
http_access allow all
  
</pre>
            </td>
          </tr>
        </table>

        <p>in questo esempio a tutti gli utenti non &egrave; consentito
        accedere al sito <em>www.nonautorizzato.it</em>, vogliamo ora
        creare una eccezione per un indirizzo IP dal quale dovr&agrave;
        essere consentito visitare quel sito, la nuova ACL sar&agrave;</p>

        <table border="0" bgcolor="#E0E0E0" width="100%">
          <tr>
            <td>
              <pre class="PROGRAMLISTING">
acl user_ok src 10.10.10.254/32
  
</pre>
            </td>
          </tr>
        </table>

        <p>e la nuova regola dovr&agrave; dunque essere</p>

        <table border="0" bgcolor="#E0E0E0" width="100%">
          <tr>
            <td>
              <pre class="PROGRAMLISTING">
http_access allow user_ok vietato
  
</pre>
            </td>
          </tr>
        </table>

        <p>nel contesto generale delle regole che stiamo applicando, la
        nuova ACL dovr&agrave; essere inserita seguendo questo schema</p>

        <table border="0" bgcolor="#E0E0E0" width="100%">
          <tr>
            <td>
              <pre class="PROGRAMLISTING">
http_access allow user_ok vietato
http_access deny vietato
http_access allow all
  
</pre>
            </td>
          </tr>
        </table>

        <p>entriamo nello specifico visualizzando alcune delle impostazioni
        standard di Squid</p>

        <table border="0" bgcolor="#E0E0E0" width="100%">
          <tr>
            <td>
              <pre class="PROGRAMLISTING">
acl all src 0.0.0.0/0.0.0.0
acl manager proto cache_object
acl localhost src 127.0.0.1/255.255.255.255
acl locallans src 192.168.0.0/255.255.255.0
acl to_localhost dst 127.0.0.0/8
acl SSL_ports port 443 563
acl Safe_ports port 80          # http
acl Safe_ports port 21          # ftp
acl Safe_ports port 443 563     # https, snews
acl Safe_ports port 70          # gopher
acl Safe_ports port 210         # wais
acl Safe_ports port 1025-65535  # unregistered ports
acl Safe_ports port 280         # http-mgmt
acl Safe_ports port 488         # gss-http
acl Safe_ports port 591         # filemaker
acl Safe_ports port 777         # multiling http
acl CONNECT method CONNECT
http_access allow manager localhost
http_access deny manager
http_access deny !Safe_ports
http_access deny CONNECT !SSL_ports
http_access allow locallan
http_access deny all
  
</pre>
            </td>
          </tr>
        </table>

        <p>con il TAG <em>acl src</em> vengono definite diverse liste di
        accesso basate sull&#39;indirizzo IP, incluse quelle per gli host
        autorizzati dall&#39;amministratore del sistema ad accedere al
        proxy server. Il TAG <em>http_access allow</em> consente a tutta la
        subnet <em>192.168.0.0</em> incluso l&#39;host locale
        (<em>127.0.0.1</em>) di accedere al proxy, il TAG
        <em>http_access</em> deny impone una negazione di accesso.</p>

        <p>I protocolli SMTP e HTTP sono delle implementazioni piuttosto
        simili, questo fatto pu&ograve; autorizzare qualche male
        intenzionato ad utilizzare il nostro proxy server come relay SMTP
        per inviare dei messaggi di posta non autorizzati. Per prevenire
        questo tipo di inconveniente dovremmo accertarci che Squid blocchi
        le richieste dirette verso la porta 25 che viene appunto utilizzata
        dal protocollo SMTP. Squid viene configurato in questo modo come
        default, nel file <em>squid.conf</em> vengono elencate una lista di
        porte fidate, a tale riguardo controllare la <em>acl
        Safe_ports</em>. Nel vostro file di configurazione dovreste avere
        un TAG <em>http_access</em> impostato in questo modo</p>

        <table border="0" bgcolor="#E0E0E0" width="100%">
          <tr>
            <td>
              <pre class="PROGRAMLISTING">
acl Safe_ports port 80          # http
acl Safe_ports port 21          # ftp
http_access deny !Safe_ports
  
</pre>
            </td>
          </tr>
        </table>

        <p>con questo TAG <em>http_access deny</em> bloccheremo tutto il
        traffico diverso (<em>!</em>) da quello dichiarato nella <em>acl
        Safe_ports</em>. Naturalmente per impedire il relay non autorizzato
        di posta elettronica, la porta 25 non deve elencata nella <em>acl
        Safe_ports</em>. Possiamo utilizzare una ACL per impostare gli
        orari di accesso a Squid</p>

        <table border="0" bgcolor="#E0E0E0" width="100%">
          <tr>
            <td>
              <pre class="PROGRAMLISTING">
acl work_time time MTWHF 08:00-17:30 
http_access allow work_time
  
</pre>
            </td>
          </tr>
        </table>

        <p>con il TAG <em>acl work_time</em> viene impostato un orario per
        l&#39;accesso al proxy server e il TAG <em>http_access allow</em>
        consente solo quell&#39;orario. In questo esempio autorizziamo
        l&#39;accesso al proxy server nei soli giorni festivi e nelle sole
        ore lavorative.</p>

        <p>Possiamo impostare delle ACL anche per il protocollo ICP ed
        determinare delle relazioni di trusted tra macchine diverse
        nell&#39;ambito di un cache peering</p>

        <table border="0" bgcolor="#E0E0E0" width="100%">
          <tr>
            <td>
              <pre class="PROGRAMLISTING">
acl all src 0.0.0.0/0.0.0.0
acl locallans src 192.168.0.0/255.255.255.0
icp_access allow locallans 
icp_access deny all 
  
</pre>
            </td>
          </tr>
        </table>

        <p>con il TAG <em>icp_access</em> vengono processate le ACL che
        autorizzano o negano accesso per le richieste ICP che vengono
        effettuate da altri proxy server.</p>

        <p>Cos&igrave; abbiamo visto che &egrave; possibile impostare
        diversi tipi di ACL, i nomi delle ACL di tipo <em>src</em> non
        devono assolutamente contenere il simbolo &quot;<em>-</em>&quot;,
        questo carattere infatti potrebbe essere interpretatato da Squid
        come una indicazione di intervallo (<em>range</em>). Ecco un
        esempio di una serie di ACL del tipo <em>src</em> impostata
        correttamente</p>

        <table border="0" bgcolor="#E0E0E0" width="100%">
          <tr>
            <td>
              <pre class="PROGRAMLISTING">
acl locallan101 src 192.168.100.0/255.255.255.224   
acl locallan102 src 192.168.100.32/255.255.255.224  
acl locallan103 src 192.168.100.64/255.255.255.192  
acl locallan104 src 192.168.100.128/255.255.255.192 
acl locallan105 src 192.168.100.192/255.255.255.248 
acl locallan106 src 192.168.100.200/255.255.255.248 
acl locallan107 src 192.168.100.208/255.255.255.240 
acl locallan108 src 192.168.100.224/255.255.255.248 
acl locallan109 src 192.168.100.232/255.255.255.248 
acl locallan110 src 192.168.100.240/255.255.255.240
  
</pre>
            </td>
          </tr>
        </table>

        <p>di seguito riportiamo una ACL del tipo <em>src</em> impostata in
        maniera errata</p>

        <table border="0" bgcolor="#E0E0E0" width="100%">
          <tr>
            <td>
              <pre class="PROGRAMLISTING">
acl locallan-1-01 src 192.168.100.0/255.255.255.224
  
</pre>
            </td>
          </tr>
        </table>

        <p>In linea di massima, questo tipo di indicazioni dovranno essere
        sempre rispettate, in particolare &egrave; proprio questa la
        sintassi consigliata per creare le ACL, si tratta infatti di una
        serie di regole fondamentale nel caso in cui si gestiscano dei
        Sistemi che prevedono un controllo molto granulare degli accessi al
        proxy server, Sistemi che concedono e negano accesso a diverse
        subnet che possono anche trovarsi sullo stesso segmento rete.</p>
      </div>

      <div class="SECT1">
        <hr />

        <h2 class="SECT1"><a name="SEC-ACL-AUTENTICAZIONE-UTENTI" id=
        "SEC-ACL-AUTENTICAZIONE-UTENTI"></a>10.4. Utilizzare le
        <em>ACL</em> per autenticare degli utenti</h2>

        <p>Un&#39;altra interessante opzione offerta da Squid &egrave;
        rappresentata dalla possibilit&agrave; di limitare l&#39;accesso al
        proxy tramite eventuale autorizzazione, autenticazione ed
        accounting. In una rete geografica di grandi dimensioni
        l&#39;utilizzo di Squid pu&ograve; rilevarsi utile per il controllo
        degli accessi.</p>

        <p>Non dimentichiamo che un proxy &egrave; un gateway a livello
        applicativo (<em>Layer 7 della pila OSI</em>) e pu&ograve; essere
        utilizzato anche come firewall tra due reti, va sottolineato, per i
        puristi del TCP/IP, che il termine firewall in questo caso non
        &egrave; corretto in quanto Squid non esegue alcun filtraggio di
        pacchetti.</p>

        <p>Squid pu&ograve; essere utilizzato come applicazione per il
        controllo e la verifica, grazie alle sue funzionalit&agrave; si
        riveler&agrave; molto utile nell&#39;implementazione di una
        politica di sicurezza. Per attivare il controllo di accesso a
        livello utente &eacute; necessario attivare almeno uno <a href=
        "#SEC-SCHEMI-DI-AUTENTICAZIONE">schema di autenticazione</a> ed
        aggiungere nelle ACL i seguenti TAG</p>

        <table border="0" bgcolor="#E0E0E0" width="100%">
          <tr>
            <td>
              <pre class="PROGRAMLISTING">
acl password proxy_auth REQUIRED
http_access allow password
  
</pre>
            </td>
          </tr>
        </table>

        <p>quando viene impostata un qualsiasi tipo di ACL del tipo
        <em>proxy_auth</em> tramite le regole <em>http_access</em>, tutte
        le ACL successive alla regola <em>proxy_auth</em> non verranno
        pi&ugrave; considerate da Squid in quanto o l&#39;accesso
        sar&agrave; stato consentito oppure verr&agrave; generato un errore
        di acceso negato alla cache. Se si deve configurare un proxy in
        maniera granulare &egrave; quindi necessario portare molta
        attenzione nell&#39;applicazione delle regole <em>http_access.</em>
        In buona sostanza, una volta che ci si &egrave; autenticati su un
        sistema Squid &egrave; tutto permesso tranne quello che &egrave;
        stato esplicitamente negato nelle regole <em>http_access</em>
        precedenti alla regola <em>http_access proxy_auth</em></p>

        <table border="0" bgcolor="#E0E0E0" width="100%">
          <tr>
            <td>
              <pre class="PROGRAMLISTING">
http_access allow localhost
http_access deny manager
http_access deny !Safe_ports
http_access deny CONNECT !SSL_ports
http_access deny locallan102
http_access deny porn
http_access deny badlang
http_access deny entertain
http_access deny games
http_access deny mp3
http_access deny pirate
http_access deny pron
http_access deny ftpblock
http_access allow sitiok
http_access allow password
  
</pre>
            </td>
          </tr>
        </table>

        <p>come abbiamo visto sopra, &egrave; possibile l&#39;accesso
        all&#39;host locale, successivamente procediamo con la definizione
        di una serie di blocchi che riguardano le reti non autorizzate, i
        vari siti non consoni all&#39;utilizzo del proxy, autorizziamo i
        siti censiti come visitabili e successivamente procediamo con la
        richiesta di autenticazione del tipo basic. L&#39;utente, dopo aver
        proceduto ad autenticarsi, sar&agrave; autorizzato a fare tutto
        quello che non gli sia gi&agrave; stato esplicitamente negato.</p>
      </div>

      <div class="SECT1">
        <hr />

        <h2 class="SECT1"><a name="SEC-EXTERNAL-ACL" id=
        "SEC-EXTERNAL-ACL"></a>10.5. External <em>ACL</em></h2>

        <p>Squid 2.5 introduce la possibilit&agrave; di estendere gli
        elementi che compongono le ACL con una nuova classe di ACL
        denominata <em>external</em>, tale classe si basa sul risultato di
        un helper esterno che agisce in modo similare al sistema di
        autenticazione.</p>

        <p>Questa nuova funzionalit&agrave; rende agevole, ad esempio,
        l&#39;implemetazione di meccanismi di controllo relativo alla
        appartenenza di un utente a determinati gruppi, oppure esegue dei
        controlli pi&ugrave; complessi tra i quali citiamo la
        corrispondenza tra un utente ed un indirizzo IP prefissato.</p>

        <p>Al momento gli helper disponibili sono ancora pochi e sono
        esclusivamente dedicati al controllo di accesso a livello utente.
        La scelta degli helper da attivare viene effettuata al momento
        della configurazione dei parametri di compilazione di Squid, il
        nome dell&#39;helper da specificare &egrave; il nome (case
        sensitive) dalla cartella presente nel source tree di Squid che
        contiene i sorgenti dell&#39;applicazione</p>

        <table border="0" bgcolor="#E0E0E0" width="100%">
          <tr>
            <td>
              <pre class="PROGRAMLISTING">
./configure --enable-external-acl-helpers=&quot;winbind_group ip_user&quot;
  
</pre>
            </td>
          </tr>
        </table>

        <p>l&#39;esempio di cui sopra rappresenta le instruzioni necessarie
        alla compilazione di due helpers esterni quali
        <em>winbind_group</em> e <em>ip_user</em>.</p>

        <div class="SECT2">
          <hr />

          <h3 class="SECT2"><a name="SUBSEC-WB-GROUP" id=
          "SUBSEC-WB-GROUP"></a>10.5.1. wb_group</h3>

          <p>Questo helper permette la verifica di appartenza di un utente
          ad un gruppo globale di un Dominio Windows NT 4 o Active
          Directory. Deve essere utilizzato in concomitanza agli helper di
          autenticazione Basic <a href="#SUBSEC-WINBIND">Winbindd</a> e
          <a href="#SUBSEC-CONF-NTLM-AUTHENTICATION">NTLM</a>.</p>

          <p>Per il suo corretto funzionamento necessita che Samba 2.2.4
          (<a href="http://www.samba.org/" target=
          "_top">http://www.samba.org/</a>) o seguenti siano installati sul
          nostro sistema. Per i dettagli relativi alla configurazione di
          Samba, riferirisi alle susseguenti sezioni relative
          all&#39;<a href=
          "#SEC-AUTENTICAZIONE-CON-SAMBA-2.2.X">Autenticazione con Samba
          2.2.x</a> e alla configurazione di <a href=
          "#SEC-WINBIND">Winbindd</a>.</p>

          <p>L&#39;utilizzo di questo helper pu&ograve; semplificare in
          maniera notevole la gestione della configurazione di Squid e
          migliorarne le prestazioni globali. Per spiegarci meglio,
          definiremo un caso di studio: supponiamo di aver 500 utenti
          censiti in un dominio NT e che li si voglia suddividere in gruppi
          di restrizione relativamente all&#39;accesso alla webcache.
          Utilizzando gli <em>helper</em> di autenticazione &egrave;
          possibile agire in due modi:</p>

          <ul>
            <li>
              <p>creare una ACL per ogni utente</p>
            </li>

            <li>
              <p>creare una ACL basata su un regex<a name="AEN2723" href=
              "#FTN.AEN2723" id="AEN2723">[20]</a> che legge la lista degli
              utenti da un file</p>
            </li>
          </ul>

          <p>In entrambi i casi appare chiaro che incontreremmo un notevole
          impatto sulle prestazioni della nostra cache, in quanto ad ogni
          <em>auth-challenge</em>, Squid dovr&agrave; verificare
          l&#39;elenco delle access list, oppure confrontare tutta la lista
          degli utenti. Proprio per far fronte a questa problematica ci
          viene in contro l&#39;external helper <em>wb_group</em> che deve
          essere usato congiuntamente a <em><a href=
          "#SEC-WINBIND">wb_ntlmauth</a>.</em> Ora creeremo dei gruppi
          d&#39;utilizzo all&#39;interno del dominio NT, per capirci
          meglio</p>

          <ul>
            <li>
              <p><em>InternetFull</em>, nessuna limitazione</p>
            </li>

            <li>
              <p><em>InternetNormal</em>, Gli utenti possono solo navigare
              su determinati siti e non scaricare</p>
            </li>

            <li>
              <p><em>InternetToDow</em>, i membri possono navigare in
              maniera filtrata e scaricaricare liberamente.</p>
            </li>

            <li>
              <p><em>InternetToNav</em>, Gli utenti possono navigare senza
              limitazione ma non scaricare</p>
            </li>
          </ul>

          <p>A questo punto, sempre all&#39;interno del dominio Windows NT,
          assegneremo gli utenti ai rispettivi gruppi. L&#39;utilizzo del
          dominio NT &egrave; ora piuttosto trasparente a Squid, infatti
          nel file di configurazione <em>squid.conf</em> &egrave; possibile
          utilizzare un autenticatore qualsiasi, la scelta dello stesso non
          &egrave; pi&ugrave; importante.</p>

          <p>Definire il TAG <em>external_acl</em></p>

          <table border="0" bgcolor="#E0E0E0" width="100%">
            <tr>
              <td>
                <pre class="PROGRAMLISTING">
external_acl_type wb_group concurrency=5 ttl=900 %LOGIN \
/usr/squid/libexec/wb_group 
   
</pre>
              </td>
            </tr>
          </table>

          <p>Creeremo all&#39;interno della directory <em>$PREFIX/etc/</em>
          dei file, ciascuno di questi file deve contenere i nomi dei
          gruppi da agganciare all&#39;ACL. Per consentire una maggiore
          comprensione, si specifica anche che i files appena creati
          dovranno contenere al loro interno il solo nome del gruppo.
          <em>Esempio</em>: Gruppo InternetFull - nel file
          <em>/usr/squid/etc/internetfull</em> ci deve essere scritto
          unicamente <em>&quot;InternetFull</em>&quot;</p>

          <p>Inseriremo ora, le ACL come segue:</p>

          <table border="0" bgcolor="#E0E0E0" width="100%">
            <tr>
              <td>
                <pre class="PROGRAMLISTING">
acl password proxy_auth REQUIRED
acl internetfull external wb_group -i &quot;/usr/squid/etc/internetfull&quot; 
acl internetnormal external wb_group -i &quot;/usr/squid/etc/internetnormal&quot; 
acl internettodow external wb_group -i &quot;/usr/squid/etc/internettodow&quot; 
acl internettonav external wb_group -i &quot;/usr/squid/etc/internettonav&quot;
acl time_acl time M T W H F 8:30-19:00
acl nointernet src &quot;/usr/squid/etc/nointernet&quot;
acl goodurl url_regex -i &quot;/usr/squid/etc/goodurl&quot; 
acl badurl url_regex -i &quot;/usr/squid/etc/badurl&quot; 
acl badmime url_regex -i &quot;/usr/squid/etc/badmime&quot;
http_access allow password internetfull 
http_access allow password internetnormal time_acl !badurl !badmime 
http_access allow password internettonav time_acl !badmime 
http_access allow password internettodow time_acl !badurl 
http_access deny all 
   
</pre>
              </td>
            </tr>
          </table>

          <p>Appare chiara la facilit&agrave; con la quale si pu&ograve;
          ora amministrare grandi numeri di utenti compiendo pochi passi
          per eseguire la configurazione. Per la configurazione di Samba e
          <em>wb_ntlmauth</em>, consultare il <a href=
          "#SEC-WINBIND">paragrafo relativo</a>.</p>

          <p>A partire dalla versione 1.20 dell&#39;helper
          <em>wb_group</em>, sono disponibili le seguenti opzioni:</p>

          <table border="0" bgcolor="#E0E0E0" width="100%">
            <tr>
              <td>
                <pre class="PROGRAMLISTING">
-c use case insensitive compare
-d enable debugging
-h this message
   
</pre>
              </td>
            </tr>
          </table>

          <p>La modalit&agrave; predefinita prevede che la comparazione sia
          <em>case sensitive</em> sui nomi dei gruppi, e quindi questi
          devono essere specificati <em>esattamente</em> come nel dominio
          NT/2000. L&#39;opzione <em>-c</em> attiva la modalit&agrave; di
          comparazione <em>case insensitive</em>, ma, utilizzando
          impostazioni locali di lingua differenti dall&#39;inglese, il
          risultato potrebbe essere diverso dal previsto. Per dettagli
          vedere le man pages di <em>toupper</em>, sezione BUGS.</p>

          <p>L&#39;opzione <em>-d</em> consente una diagnostica abbastanza
          chiara e precisa dei problemi. Al fine di controllare il corretto
          funzionamento dell&#39;helper <em>wb_group</em>, si consideri un
          utente di prova ed un gruppo di prova avviando l&#39;helper
          <em>wb_group</em> come segue:</p>

          <table border="0" bgcolor="#E0E0E0" width="100%">
            <tr>
              <td>
                <pre class="PROGRAMLISTING">
# /usr/squid/libexec/wb_group -d
/wb_group[14984](wb_check_group.c:267):
External ACL winbindd group helper build Jan 15 2003, 13:29:15 starting up...
DOMINIO\\Utente Gruppo &lt;--- inserire cos&igrave; (con il doppio &quot;\&quot;)
/wb_group[14984](wb_check_group.c:286): Got &#39;DOMINIO\\Utente Gruppo&#39; from Squid (length: 35).
/wb_group[14984](wb_check_group.c:188): SID: S-1-5-21-1836190980-1428173729-311576647-1168
/wb_group[14984](wb_check_group.c:154): Windows group: Gruppo1, Squid group: Gruppo
/wb_group[14984](wb_check_group.c:188): SID: S-1-5-21-1836190980-1428173729-311576647-512
/wb_group[14984](wb_check_group.c:154): Windows group: Domain Admins, Squid group: Gruppo
/wb_group[14984](wb_check_group.c:188): SID: S-1-5-21-1836190980-1428173729-311576647-1510
/wb_group[14984](wb_check_group.c:154): Windows group: Gruppo, Squid group: Gruppo OK
   
</pre>
              </td>
            </tr>
          </table>
        </div>

        <div class="SECT2">
          <hr />

          <h3 class="SECT2"><a name="SUBSEC-WBINFO-GROUP-SAMBA3" id=
          "SUBSEC-WBINFO-GROUP-SAMBA3"></a>10.5.2. Utilizzo di wbinfo_group
          con Samba 3</h3>

          <p>L&#39;helper <em>wbinfo_group,</em> cos&iacute; come
          <em>wb_group</em>, consente il controllo delle autorizzazioni di
          accesso in base all&#39;appartenzenza a gruppi di dominio Windows
          NT/2000, ma &eacute; basato su di uno script perl che interagisce
          con l&#39;utility Samba <em>wbinfo</em>, ci&oacute; fa s&iacute;
          che esso sia &quot;neutro&quot; rispetto alla versione di Samba
          installata sul sistema.</p>

          <p><em>wbinfo_group</em> necessita di Samba e di una versione
          recente di perl che includa il modulo di libreria
          <em>shellwords.pl</em>. In mancanza di quest&#39;ultimo, &eacute;
          possibile tentare di copiarlo da un altro sistema. Il suo
          utilizzo e le procedure di verifica di funzionamento sono
          strettamete equivalenti a quelle di <em>wb_group</em>.</p>

          <p>Quindi l&#39;<em>external_acl</em> definita in precedenza per
          <em>wb_group</em> diventer&agrave;</p>

          <table border="0" bgcolor="#E0E0E0" width="100%">
            <tr>
              <td>
                <pre class="PROGRAMLISTING">
external_acl_type wb_group concurrency=5 ttl=900 %LOGIN /usr/squid/libexec/wbinfo_group
   
</pre>
              </td>
            </tr>
          </table>
        </div>

        <div class="SECT2">
          <hr />

          <h3 class="SECT2"><a name="SUBSEC-WIN32-CHECK-GROUP" id=
          "SUBSEC-WIN32-CHECK-GROUP"></a>10.5.3. win32_check_group</h3>

          <p>L&#39;helper <em>win32_check_group,</em> cos&iacute; come
          <em>wb_group</em>, consente il controllo delle autorizzazioni di
          accesso in base all&#39;appartenzenza a gruppi di dominio Windows
          NT/2000, ma riguarda esclusivamente la piattaforma Win32. Non
          necessita di alcuna componente esterna in quanto si appoggia
          sulle API native del sistema operativo.
          <em>win32_check_group</em> pu&ograve; operare su gruppi globali
          di dominio o gruppi locali di macchina. Il suo utilizzo e le
          procedure di verifica di funzionamento sono strettamete
          equivalenti a quelle di <em>wb_group</em>:</p>

          <table border="0" bgcolor="#E0E0E0" width="100%">
            <tr>
              <td>
                <pre class="PROGRAMLISTING">
external_acl_type NT_global_group %LOGIN c:/squid/libexec/win32_check_group.exe -G
external_acl_type NT_local_group %LOGIN c:/squid/libexec/win32_check_group.exe
acl GProxyUsers external NT_global_group GProxyUsers
acl LProxyUsers external NT_local_group LProxyUsers
acl password proxy_auth REQUIRED
http_access allow password GProxyUsers
http_access allow password LProxyUsers
http_access deny all
   
</pre>
              </td>
            </tr>
          </table>

          <p>Nell&#39;esempio precedente, tutti gli utenti NT validati
          appartenenti al gruppo globale di dominio GProxyUsers o al gruppo
          locale di macchina LProxyUsers sono autorizzati ad utilizzare la
          cache. L&#39;helper <em>win32_check_group</em> &eacute;
          utilizzabile solamente in ambiente Windows nativo o Cygwin ed
          &eacute; disponibile nei relativi package Squid. Per questo
          helper sono disponibili le seguenti opzioni:</p>

          <table border="0" bgcolor="#E0E0E0" width="100%">
            <tr>
              <td>
                <pre class="PROGRAMLISTING">
-G start helper in Global Group mode
-c use case insensitive compare
-d enable debugging
-h this message
   
</pre>
              </td>
            </tr>
          </table>

          <p>La modalit&agrave; predefinita prevede che la comparazione sia
          <em>case sensitive</em> sui nomi dei gruppi, e quindi questi
          devono essere specificati <em>esattamente</em> come nel dominio
          NT/2000. L&#39;opzione <em>-c</em> attiva la modalit&agrave; di
          comparazione <em>case insensitive</em>, ma, utilizzando
          impostazioni locali di lingua differenti dall&#39;inglese, il
          risultato potrebbe essere diverso dal previsto. Per dettagli
          vedere le man pages di <em>toupper</em>, sezione BUGS.</p>

          <p>L&#39;opzione <em>-d</em> consente una diagnostica abbastanza
          chiara e precisa di eventuali problemi.</p>
        </div>

        <div class="SECT2">
          <hr />

          <h3 class="SECT2"><a name="SUBSEC-SQUID-LDAP-GROUP" id=
          "SUBSEC-SQUID-LDAP-GROUP"></a>10.5.4. squid_ldap_group</h3>

          <p>Questo helper permette la verifica di appartenza di un utente
          ad un gruppo di una directory LDAP. Il programma opera eseguendo
          delle ricerche tramite un search filter basato sul username
          dell&#39;utente ed il gruppo richiesto, se viene trovato un
          match, l&#39;utente appartiene al gruppo cercato.</p>

          <p>Nel seguito di questo paragrafo verranno trattati alcuni
          argomenti la cui comprensione &eacute; strettamente dipendente da
          una buona conoscenza del protocollo LDAP, per maggiori dettagli
          al riguardo, riferirsi al sito del <a href=
          "http://www.openldap.org" target="_top">Progetto
          OpenLDAP</a>.</p>

          <p>Questo autenticatore consente l&#39;interfacciamento con tutti
          i maggiori Directory Service attualmente disponibili</p>

          <ul>
            <li>
              <p>Microsoft Active Directory</p>
            </li>

            <li>
              <p>Novell NDS</p>
            </li>

            <li>
              <p>Lotus Notes Directory</p>
            </li>

            <li>
              <p>Sun Java System Directory</p>
            </li>
          </ul>

          <p>esempio di configurazione</p>

          <table border="0" bgcolor="#E0E0E0" width="100%">
            <tr>
              <td>
                <pre class="PROGRAMLISTING">
external_acl_type ldap_group %LOGIN /usr/local/squid/libexec/squid_ldap_group ...
acl gruppo1 external ldap_group Gruppo1
acl gruppo2 external ldap_group Gruppo2
acl password proxy_auth REQUIRED
http_access allow password Gruppo1
http_access allow password Gruppo2
http_access deny all
   
</pre>
              </td>
            </tr>
          </table>

          <p>in questo caso <em>squid_ldap_group</em> si trova in
          <em>/usr/local/squid/libexec</em>, e sono definite due acl
          relative ai gruppi LDAP <em>Gruppo1</em> e <em>Gruppo2</em>.
          L&#39;helper <em>squid_ldap_group</em> &eacute; utilizzabile
          solamente sulle piattaforme supportate da Squid sui cui sono
          disponibili le librerie OpenLDAP od un un altra C-API LDAP
          compatibile.</p>

          <p>Sono disponibili le seguenti opzioni:</p>

          <table border="0" bgcolor="#E0E0E0" width="100%">
            <tr>
              <td>
                <pre class="PROGRAMLISTING">
squid_ldap_group -b &quot;base DN&quot; -f &quot;LDAP search filter&quot; 
                 [options] [ldap_server_name[:port]...|URI] 
   
</pre>
              </td>
            </tr>
          </table>

          <p>Le opzioni -b e -f devono essere sempre specificate. Per
          dettagli sulle opzioni si raccomanda di visionare la man page
          relativa a <em>squid_ldap_group</em> fornita con Squid.</p>

          <p>Attenzione: sono supportate al massimo 16 occorrenze di %s
          negli argomenti dell&#39;opzione -u</p>
        </div>

        <div class="SECT2">
          <hr />

          <h3 class="SECT2"><a name="SUBSEC-SQUID-UNIX-GROUP" id=
          "SUBSEC-SQUID-UNIX-GROUP"></a>10.5.5. squid_unix_group</h3>

          <p>Questo helper permette la verifica di appartenza di un utente
          ad un gruppo standard UNIX&reg;/Linux. Il programma opera
          eseguendo delle ricerche nel file <em>/etc/group</em> basate
          sullo username dell&#39;utente ed il gruppo richiesto, un esempio
          di configurazione</p>

          <table border="0" bgcolor="#E0E0E0" width="100%">
            <tr>
              <td>
                <pre class="PROGRAMLISTING">
external_acl_type Linux_group %LOGIN /usr/local/squid/libexec/squid_unix_group
acl gruppo1 external Linux_group Gruppo1
acl gruppo2 external Linux_group Gruppo2
acl password proxy_auth REQUIRED
http_access allow password Gruppo1
http_access allow password Gruppo2
http_access deny all
   
</pre>
              </td>
            </tr>
          </table>

          <p>in questo caso <em>squid_unix_group</em> si trova in
          <em>/usr/local/squid/libexec</em>, e sono definite due ACL
          relative ai gruppi Linux <em>Gruppo1</em> e <em>Gruppo2</em>.
          L&#39;helper <em>squid_unix_group</em> &eacute; utilizzabile
          solamente sulle piattaforme supportate da Squid sui cui
          l&#39;appartenza a gruppi degli utenti &eacute; gestita tramite
          il file <em>/etc/group</em>. Sono disponibili le seguenti
          opzioni:</p>

          <table border="0" bgcolor="#E0E0E0" width="100%">
            <tr>
              <td>
                <pre class="PROGRAMLISTING">
squid_unix_group [-g group1 -g group2 -g group3 ...] [-p] 
   
</pre>
              </td>
            </tr>
          </table>

          <p>L&#39;opzione -g permette di indicare i gruppi da verificare
          sulla command line dell&#39;helper, ma il suo utilizzo &eacute;
          sconsigliabile, in quanto la definizione del gruppo da verificare
          direttamente tramite External ACL come in esempio &eacute;
          maggiormente flessibile. L&#39;opzione -p attiva il lookup anche
          nei riguardi del gruppo primario indicato in
          <em>/etc/passwd</em>. Per maggiori dettagli si raccomanda di
          visionare la man page relativa a <em>squid_unix_group</em>
          fornita con Squid.</p>

          <p>Attenzione: sono supportati al massimo 10 gruppi. Per
          aumentare tale valore &eacute; necessario modificare il define
          MAX_GROUP nel codice sorgente e ricompilare l&#39;helper.</p>
        </div>

        <div class="SECT2">
          <hr />

          <h3 class="SECT2"><a name="SUBSEC-IP-GROUP-CHECK" id=
          "SUBSEC-IP-GROUP-CHECK"></a>10.5.6. ip_group_check</h3>

          <p>Questo helper permette di verificare la corrispondenza tra
          l&#39;indirizzo IP del client su cui viene eseguito il Browser
          Internet e l&#39;utente utilizzato per l&#39;autenticazione. Il
          programma pu&ograve; operare su singoli indirizzi IP o su intere
          subnet, &eacute; inoltre possibile utilizzare come riferimento
          per la verifica dell&#39;utente, gruppi standard UNIX&reg;/Linux,
          in questo caso il programma esegue delle ricerche nel file
          <em>/etc/group</em> basate sullo username dell&#39;utente. Le
          impostazioni dell&#39;helper devono essere inserite
          all&#39;interno di un apposito file di configurazione, vediamo un
          esempio di utilizzo:</p>

          <table border="0" bgcolor="#E0E0E0" width="100%">
            <tr>
              <td>
                <pre class="PROGRAMLISTING">
external_acl_type IP_Check %SRC %LOGIN /usr/local/squid/libexec/ip_user_check -f /usr/local/squid/etc/ip_user_check.conf
acl resticted external IP_Check
acl password proxy_auth REQUIRED
http_access allow password restricted
http_access deny all
   
</pre>
              </td>
            </tr>
          </table>

          <p>in questo caso <em>ip_user_check</em> si trova in
          <em>/usr/local/squid/libexec</em>, il suo file di configurazione
          &eacute; <em>/usr/local/squid/etc/ip_user_check.conf</em> ed
          &eacute; definita una ACL per eseguire la verifica di
          corrispondenza. L&#39;helper <em>ip_user_check</em> &eacute;
          utilizzabile solamente sulle piattaforme supportate da Squid sui
          cui l&#39;appartenza a gruppi degli utenti &eacute; gestita
          tramite il file <em>/etc/group</em>. Sono disponibili le seguenti
          opzioni:</p>

          <table border="0" bgcolor="#E0E0E0" width="100%">
            <tr>
              <td>
                <pre class="PROGRAMLISTING">
ip_user_check -f &lt;configuration_file&gt; 
   
</pre>
              </td>
            </tr>
          </table>

          <p>L&#39;opzione -f &eacute; obbligatoria e specifica il percorso
          del file di configurazione.</p>

          <p>Il formato del file di configurazione &eacute; il
          seguente:</p>

          <ul>
            <li>
              <p>Le linee che iniziano con il carattere # sono ignorate
              (commenti)</p>
            </li>

            <li>
              <p>Singolo utente:</p>
            </li>
          </ul>

          <table border="0" bgcolor="#E0E0E0" width="100%">
            <tr>
              <td>
                <pre class="PROGRAMLISTING">
ip[/mask]             utente
   
</pre>
              </td>
            </tr>
          </table>

          <ul>
            <li>
              <p>Utenti appartenenti ad un gruppo definito in
              /etc/group</p>
            </li>
          </ul>

          <table border="0" bgcolor="#E0E0E0" width="100%">
            <tr>
              <td>
                <pre class="PROGRAMLISTING">
ip[/mask]             @gruppo
   
</pre>
              </td>
            </tr>
          </table>

          <ul>
            <li>
              <p>Range IP vietato (nessun utente pu&ograve; usare la
              cache)</p>
            </li>
          </ul>

          <table border="0" bgcolor="#E0E0E0" width="100%">
            <tr>
              <td>
                <pre class="PROGRAMLISTING">
ip[/mask]             NONE
   
</pre>
              </td>
            </tr>
          </table>

          <ul>
            <li>
              <p>Range IP libero (qualunque utente pu&ograve; usare la
              cache)</p>
            </li>
          </ul>

          <table border="0" bgcolor="#E0E0E0" width="100%">
            <tr>
              <td>
                <pre class="PROGRAMLISTING">
ip[/mask]             ALL
   
</pre>
              </td>
            </tr>
          </table>

          <ul>
            <li>
              <p>Indirizzo IP e maschera devono essere specificati nel
              formato X.Y.Z.W</p>
            </li>
          </ul>

          <p>Il risultato della verifica si basa sulla logica di first
          match, &eacute; quindi necessario fare molta attenzione
          all&#39;oridine in cui vengono inserite le direttive.
          Esempio:</p>

          <table border="0" bgcolor="#E0E0E0" width="100%">
            <tr>
              <td>
                <pre class="PROGRAMLISTING">
# Tutti gli utenti della rete 192.168.1.0/24 sono autorizzati
192.168.1.0/255.255.255.0     ALL
#
# Gli utenti della rete 192.168.2.0/24 non sono autorizzati
# tranne l&#39;utente `boss&acute; che pu&ograve; autenticarsi ovunque
0.0.0.0/0.0.0.0       boss
192.168.2.0/255.255.255.0     NONE
#
# L&#39;utente `gianni&acute; pu&ograve; autenticarsi solo dall&#39;indirizzo IP delle propria stazione
192.168.3.45  jayk
#
# Gli utenti appartenenti al gruppo `cad&acute; possono autenticarsi solo dalla propria VLAN
10.0.0.0/255.255.0.0  @cad
   
</pre>
              </td>
            </tr>
          </table>
        </div>
      </div>

      <div class="SECT1">
        <hr />

        <h2 class="SECT1"><a name="SEC-CONTROLLO-ACCESSO-SUI-SITI-WEB" id=
        "SEC-CONTROLLO-ACCESSO-SUI-SITI-WEB"></a>10.6. Controllo
        d&#39;accesso sui siti web</h2>

        <p>La politica di sicurezza pu&ograve; naturalmente prevedere delle
        limitazioni di accesso su taluni siti web: siti a sfondo sessuale o
        ludico possono essere vietati. Squid pu&ograve; essere utilizzato
        anche come potente strumento di content management. &Eacute;
        possibile limitare i contenuti a parte della rete aziendale: la
        rete degli utenti pu&ograve; essere monitorata e filtrata
        utilizzando il sistema di autenticazione e la procedura di content
        managment.</p>

        <div class="SECT2">
          <hr />

          <h3 class="SECT2"><a name="SUBSEC-CONTROLLI-DI-ACCESSO-SITI-WEB"
          id="SUBSEC-CONTROLLI-DI-ACCESSO-SITI-WEB"></a>10.6.1. Controlli
          di accesso e URL filtering</h3>

          <p>Con le ACL del tipo <em>url_regex</em> &egrave; possibile
          inserire un percorso per i files che contengono la lista delle
          parole chiave selezionate che consentono di individuare il sito
          Web vietato che &egrave; stato richiesto dal client HTTP
          (netscape, mozilla, internet explorer....).</p>

          <table border="0" bgcolor="#E0E0E0" width="100%">
            <tr>
              <td>
                <pre class="PROGRAMLISTING">
acl porn url_regex &quot;/squid/etc/blocked/porn.block.txt&quot; 
acl notporn url_regex &quot;/squid/etc/blocked/porn.unblock.txt&quot; 
acl badlang url_regex &quot;/squid/etc/blocked/badlang.block.txt&quot; 
acl entertain url_regex &quot;/squid/etc/blocked/entertain.block.txt&quot; 
acl games url_regex &quot;/squid/etc/blocked/games.block.txt&quot; 
acl pirate url_regex &quot;/squid/etc/blocked/pirate.block.txt&quot; 
   
</pre>
              </td>
            </tr>
          </table>

          <p>ecco il TAG <em>http_access</em>, facciamo attenzione
          all&#39;ordine dei dinieghi di accesso via http</p>

          <table border="0" bgcolor="#E0E0E0" width="100%">
            <tr>
              <td>
                <pre class="PROGRAMLISTING">
http_access deny porn 
http_access deny badlang 
http_access deny entertain 
http_access deny games 
http_access deny pirate 
   
</pre>
              </td>
            </tr>
          </table>

          <p>Inseriti i blocchi ora &egrave; possibile definire le ACL
          relative agli host autorizzati. Per scaricare una lista
          aggiornata degli host &egrave; necessario raggiungere la seguente
          URLs: <a href="http://www.squidblock.com/" target=
          "_top">http://www.squidblock.com/</a>. Di seguito esaminiamo
          anche il formato dei files che possono contenere la lista delle
          parole chiave che consentono di individuare i siti web</p>

          <table border="0" bgcolor="#E0E0E0" width="100%">
            <tr>
              <td>
                <pre class="PROGRAMLISTING">
.sex.de
.playboy.com.br
.clubhardcore.com
www-cache.fh-bingen.de
.monkeylove.com
.amateur-pages.com
.hitboss.com
.peep.com
.erotism.com
.sinfulmail.com
.nookie.com
.snapshots.com
.onlyteens.com
heavyhangers
.dailydirt.com
hustler
.brunclik.cz
.desibaba.com
.picturepost.com
.haloo.fi
.smut.com
   
</pre>
              </td>
            </tr>
          </table>

          <p>Altre liste di siti precompilate possono essere reperite
          qui</p>

          <p><a href="http://web.onda.com.br/orso/" target="_top">Squid and
          Web Utilities</a> di Pedro Lineu Orso</p>

          <p><a href="http://members.lycos.co.uk/njadmin/" target=
          "_top">Squid Blocking Files</a> di Jasons Staudenmayer</p>
        </div>

        <div class="SECT2">
          <hr />

          <h3 class="SECT2"><a name="SUBSEC-DEFINIRE-LISTA-SITI" id=
          "SUBSEC-DEFINIRE-LISTA-SITI"></a>10.6.2. Definire una lista di
          siti visitabili</h3>

          <p>In questo paragrafo tratteremo un modello di configurazione
          molto interessante ed anche molto semplice, &egrave; un dato di
          fatto pi&ugrave; dell&#39;80% delle consultazioni sui siti web
          effettuate da parte degli utenti aziendali non riguardano
          assolutamente nessuno degli argomenti connessi con gli scopi che
          si &egrave; prefissa l&#39;organizzazione per la quale lavorano.
          Nell&#39;esempio riportato con questo tipo di configurazione
          restringeremo al massimo il campo di consultazione ai soli
          web-site che sono stati definiti come &quot;interessanti&quot; ed
          &quot;utili&quot;, gli esempi riportati possono essere validi in
          un&#39;ambiente dove i bambini hanno libero accesso alle risorse
          web</p>

          <table border="0" bgcolor="#E0E0E0" width="100%">
            <tr>
              <td>
                <pre class="PROGRAMLISTING">
acl allowed_hosts src 192.168.0.0/255.255.255.128
acl allowed_hosts1 src 192.168.0.128/255.255.255.128
acl allowed_hosts2 src 192.168.1.0/255.255.255.0
acl porn url_regex &quot;/etc/squid/block/porn.block.txt&quot;
acl consentiti url_regex &quot;/etc/squid/block/consentiti.txt&quot;
acl nonconsentiti url_regex &quot;/etc/squid/block/nonconsentiti.txt&quot;
acl snmpManager src 192.168.0.4/255.255.255.255
acl snmppublic snmp_community public
   
</pre>
              </td>
            </tr>
          </table>

          <p>abbiamo definito delle ACL che in prima istanza frazionano la
          rete in due subnet distinte e poi definiscono delle liste in
          formato <em>regexp</em>, il file <em>regexp</em> &egrave; un file
          di testo nel quale vengono dichiarate un&#39;insieme di
          espressioni regolari. Di seguito vengono applicate le ACL per
          definire questa specifica configurazione di Squid</p>

          <table border="0" bgcolor="#E0E0E0" width="100%">
            <tr>
              <td>
                <pre class="PROGRAMLISTING">
http_access allow localhost
http_access allow allowed_hosts
http_access allow consentiti
http_access deny nonconsentiti
http_access allow allowed_hosts1
http_access deny manager all
http_access deny all
http_access deny !Safe_ports
http_access deny CONNECT !SSL_ports
   
</pre>
              </td>
            </tr>
          </table>

          <p>si evince che alla subnet dichiarata dalla ACL
          &quot;allowed_hosts&quot; (192.168.0.0/255.255.255.128) &egrave;
          consentito l&#39;accesso a tutti i siti web, mentre la subnet
          dichiarata dalla ACL &quot;allowed_hosts1&quot;
          (192.168.0.128/255.255.255.128) &egrave; consentito accedere alle
          URL contenute nella lista di <em>regexp</em> che viene dichiarata
          dalla ACL &quot;consentiti&quot;. Successivamente verranno
          bloccate tutte le URL contenute nella lista di <em>regexp</em>
          definita con la ACL &quot;nonconsentiti&quot;. Di seguito la
          lista <em>/etc/squid/block/consentiti.txt</em></p>

          <table border="0" bgcolor="#E0E0E0" width="100%">
            <tr>
              <td>
                <pre class="PROGRAMLISTING">
www.totallyspies.com
www.it.barbie.com
www.myscene.com
www.witchmagazine.it
www.streghe.net
go.to/streghe
www.antoniogenna.net
disney
www.diddl.com
www.pollypocket.com
www.cartoonnetwork.it
www.repubblica.it
merlinobbs.net
www.foxkids
www.melevisione.rai.it
www.xmen
www.batman
powerrangers
   
</pre>
              </td>
            </tr>
          </table>

          <p>ancora di seguito la lista
          <em>/etc/squid/block/nonconsentiti.txt</em></p>

          <table border="0" bgcolor="#E0E0E0" width="100%">
            <tr>
              <td>
                <pre class="PROGRAMLISTING">
[root@klingon block]# more nonconsentiti.txt
.
   
</pre>
              </td>
            </tr>
          </table>

          <p>la lista di <em>regexp</em> &quot;nonconsentiti.txt&quot; con
          l&#39;esperessione &quot;.&quot; blocca tutto il resto.</p>
        </div>

        <div class="SECT2">
          <hr />

          <h3 class="SECT2"><a name="SEC-RAGG-DIRETTAMENTE-SITI" id=
          "SEC-RAGG-DIRETTAMENTE-SITI"></a>10.6.3. Raggiungere direttamente
          domini o siti predefiniti</h3>

          <p>E&#39; possibile utilizzare le <em>ACL</em> per consentire
          agli utenti di raggiungere direttamente alcuni siti internet. Ad
          esempio, se vogliamo che Squid consenta la connessione diretta
          con servers appartenenti al dominio <em>cisco.com</em> possiamo
          definire il seguente TAG all&#39;interno del file
          <em>squid.conf</em></p>

          <table border="0" bgcolor="#E0E0E0" width="100%">
            <tr>
              <td>
                <pre class="PROGRAMLISTING">
acl cisco dstdomain .cisco.com
always_direct allow cisco
   
</pre>
              </td>
            </tr>
          </table>
        </div>

        <div class="SECT2">
          <hr />

          <h3 class="SECT2"><a name="SEC-NO-CACHE" id=
          "SEC-NO-CACHE"></a>10.6.4. No cache</h3>

          <p>E&#39; possibile utilizzare Squid senza memorizzare le pagine
          visitate nella cache, il TAG <em>no_cache</em> infatti
          consentir&agrave; di eliminare il caching degli oggetti</p>

          <table border="0" bgcolor="#E0E0E0" width="100%">
            <tr>
              <td>
                <pre class="PROGRAMLISTING">
acl all src 0/0
no_cache deny all
   
</pre>
              </td>
            </tr>
          </table>
        </div>
      </div>

      <div class="SECT1">
        <hr />

        <h2 class="SECT1"><a name="SEC-ACL-BASATE-MACADDRESS" id=
        "SEC-ACL-BASATE-MACADDRESS"></a>10.7. <em>ACL</em> basate sul MAC
        address</h2>

        <p>E&#39; possibile impostare delle ACL basate sul MAC address,
        questo tipo di configurazione pu&ograve; essere utilizzato
        addizionamente o in sostituzione delle ACL &quot;canoniche&quot;
        che sono basate sugli indirizzi IP. E&#39; opportuno dire che
        questo tipo di ACL non funziona con tutti i sistemi operativi
        supportati da Squid. Attualmente le ``ARP ACLs&#39;&#39; sono
        pienamente supportate sui seguenti sistemi operativi:</p>

        <ul>
          <li>
            <p>Linux</p>
          </li>

          <li>
            <p>Solaris</p>
          </li>

          <li>
            <p>FreeBSD 4.9-STABLE</p>
          </li>

          <li>
            <p>con molta probabilit&agrave; sono supportare anche da
            FreeBSD 5.2.1-RELEASE nonch&egrave; le altre varianti dei
            sistemi BSD</p>
          </li>
        </ul>

        <p>E&#39; opportuno dire che Squid &egrave; in grado di determinare
        il MAC address dei client che si trovano all&#39;interno della
        stessa subnet, ne consegue che se il client si trova su una subnet
        differente, Squid non sar&agrave; in grado di identificare
        l&#39;indirizzo di MAC address. Per utilizzare i controlli ARP
        (MAC) access &egrave; necessario compilare il codice opzionalmente
        fornito con i sorgenti, per procedere con questa operazione
        &egrave; necessario compilare Squid con la direttiva
        <em>--enable-arp-acl</em> come opzione di configurazione</p>

        <table border="0" bgcolor="#E0E0E0" width="100%">
          <tr>
            <td>
              <pre class="PROGRAMLISTING">
% ./configure --enable-arp-acl ...
  
</pre>
            </td>
          </tr>
        </table>

        <p>se <em>src/acl.c</em> non compila o va in errore &egrave;
        ipotizzabile supporre che le ARP ACLs non sono supportate dal
        sistema operativo che state utilizzando, se contrariamente tutto
        compila correttamente &egrave; possibile inserire le linee relative
        alle ARP ACL direttamente nel file di configurazione di Squid
        <em>squid.conf</em></p>

        <table border="0" bgcolor="#E0E0E0" width="100%">
          <tr>
            <td>
              <pre class="PROGRAMLISTING">
acl M1 arp 01:02:03:04:05:06
acl M2 arp 11:12:13:14:15:16
http_access allow M1
http_access allow M2
http_access deny all
  
</pre>
            </td>
          </tr>
        </table>
      </div>
    </div>

    <div class="CHAPTER">
      <hr />

      <h1><a name="CHA-AUTENTICAZIONE-UTENTI" id=
      "CHA-AUTENTICAZIONE-UTENTI"></a>Capitolo 11. Autenticazione degli
      utenti</h1>

      <div class="SECT1">
        <h2 class="SECT1"><a name="SEC-PREAMBOLO-AUTENTICAZIONE" id=
        "SEC-PREAMBOLO-AUTENTICAZIONE"></a>11.1. Preambolo</h2>

        <p>Il principio che risiede alla base della autenticazione &egrave;
        molto semplice, il client invia il proprio nome utente e la propria
        password, Squid verifica le credenziali dell&#39;utente consultando
        o il file dove vengono memorizzati gli utenti di sistema e le loro
        password oppure interroga un servizio di directory esterno. Di
        seguito elenchiamo nel dettaglio gli schemi di autenticazione
        implementati da Squid proxy server. In particolare tratteremo le
        specifiche relative agli schemi proposti da Squid ed entreremo nel
        merito di alcune implementazioni del sistema di autenticazione
        utilizzato da Squid nei diversi contesti operativi.</p>
      </div>

      <div class="SECT1">
        <hr />

        <h2 class="SECT1"><a name="SEC-SCHEMI-DI-AUTENTICAZIONE" id=
        "SEC-SCHEMI-DI-AUTENTICAZIONE"></a>11.2. Schemi di
        autenticazione</h2>

        <p>In precedenza abbiamo gi&agrave; fornito alcune nozioni di base
        per quello che concerne gli schemi di autenticazione. Per
        &quot;<em>schema di autenticazione</em>&quot; si intende definire
        il tipo di protocollo che viene utilizzato per la validazione delle
        credenziali utente tra Browser web ed il Server, dove
        quest&#39;ultimo pu&ograve; essere un Proxy Server o un Web Server.
        Ad oggi Squid supporta tre schemi di autenticazione</p>

        <ul>
          <li>
            <p>Basic</p>
          </li>

          <li>
            <p>NTLM</p>
          </li>

          <li>
            <p>Digest</p>
          </li>
        </ul>

        <p>A partire da Squid-2.5-STABLE1, tutta la parte relativa alla
        autenticazione &egrave; stata totalmente modularizzata, permettendo
        l&#39;utilizzo contemporaneo di un maggior numero di schemi di
        autenticazione. La scelta dei moduli da attivare viene effettuata
        al momento della configurazione dei parametri di compilazione di
        Squid</p>

        <table border="0" bgcolor="#E0E0E0" width="100%">
          <tr>
            <td>
              <pre class="PROGRAMLISTING">
./configure --enable-auth=&quot;elenco schemi&quot;<em> </em>
  
</pre>
            </td>
          </tr>
        </table>

        <p>nell&#39;esempio di cui sopra, il valore &quot;<em>elenco
        schemi</em>&quot; pu&ograve; assumere i valori <em>ntlm</em>,
        <em>basic</em> e <em>digest</em>.</p>

        <p>Nelle versioni precedenti, in particolare le releases 2.3 e la
        2.4, era disponibile il solo schema di autenticazione
        <em>basic</em>.</p>

        <p>Nel caso in cui siano attivi pi&ugrave; schemi di
        autenticazione, il Browser web seleziona automaticamente quello da
        lui supportato scegliendo quindi il livello di sicurezza dichiarato
        come pi&ugrave; alto, l&#39;ordine di priorit&agrave; &egrave; il
        seguente</p>

        <ul>
          <li>
            <p><em>Digest</em></p>
          </li>

          <li>
            <p><em>NTLM</em></p>
          </li>

          <li>
            <p><em>Basic</em></p>
          </li>
        </ul>

        <div class="SECT2">
          <hr />

          <h3 class="SECT2"><a name="SUBSEC-BASIC-AUTHENTICATION" id=
          "SUBSEC-BASIC-AUTHENTICATION"></a>11.2.1. Basic
          authentication</h3>

          <p>&Egrave; lo schema di autenticazione standard supportato da
          tutti i Browser web come Netscape, Mozilla, Opera, Internet
          Explorer, Konqueror, etc. Viene spesso indicato come &quot;Clear
          Text Authentication&quot; perch&egrave; prevede lo scambio di
          username e password tra Browser e server, con una semplice
          codifica a base64, ovvero in chiaro, naturalmente questo tipo di
          autenticazione risulta essere estremamente insicuro perch&egrave;
          le password vengono trasmesse attraverso la rete continuamente e
          un maleintenzionato potrebbe osservare il traffico dei dati per
          ottenere la password che successivamente potrebbe utilizzare per
          vestire i panni dell&#39;utente leggittimo. Con questo tipo di
          autenticazione, l&#39;utente deve esplicitamente inserire i dati
          di autenticazione all&#39;inizio di ogni nuova sessione.</p>
        </div>

        <div class="SECT2">
          <hr />

          <h3 class="SECT2"><a name="SUBSEC-NTLM-AUTHENTICATION" id=
          "SUBSEC-NTLM-AUTHENTICATION"></a>11.2.2. NTLM authentication</h3>

          <p>&Egrave; uno schema di autenticazione proprietario tipico dei
          prodotti Microsoft, nella cui terminologia &egrave; comunemente
          indicato come <em>&quot;integrated authentication</em>&quot;. lo
          schema <em>NTLM</em> &egrave; supportato dai browser web
          Microsoft Internet Explorer (a partire dalla versione 3.02) e da
          Mozilla (a partire dalla versione 1.4) nonch&egrave; dai prodotti
          server Microsoft IIS (Internet Information Server), Proxy Server
          2.0 ed ISA Server. Per funzionare correttamente <em>NTLM</em>
          necessita di un Dominio Windows NT oppure delle Active Directory
          di Windows 2000/2003. In ambienti Windows 2000/2003 opera
          indifferentemente in modalit&agrave; mixed o nativa,
          purch&egrave; in fase di installazione dell&#39;Active Directory
          sia stata selezionata la compatibilit&agrave; con i sistemi pre
          Windows 2000. Per verificare se un Dominio Active Directory sia
          stato stato installato in modalit&agrave; compatibile pre Windows
          2000 &eacute; sufficiente eseguire <em>Active Directory Users and
          Computers</em> e controllare se nel gruppo &quot;Pre-Windows 2000
          Compatible Access&quot; situato nel container <em>built-in</em>
          sia presente l&#39;utente <em>Everyone</em>. Se non fosse
          presente, riferirsi all&#39;articolo Q303973 (<a href=
          "http://support.microsoft.com/default.aspx?scid=http://support.microsoft.com:80/support/kb/articles/q303/9/73.ASP&amp;NoWebContent=1"
             target="_top">http://support.microsoft.com/</a>) della
             Knowledge Base Microsoft.</p>

          <p>Lo schema di autenticazione <em>NTLM</em> &egrave; stato
          implementato anche con licenza GPL, queste versioni sono basate
          sul reverse engineering del protocolo, le pi&ugrave; note sono
          <em>Squid</em> 2.5 e <em>mod_ntlm</em> per <em>Apache Web
          Server</em>. Peculiarit&agrave; di <em>NTLM</em> &egrave;
          l&#39;esecuzione della procedura di autenticazione in maniera
          assolutamente trasparente all&#39;utente senza alcuna richiesta
          di username/password, sfruttando le credenziali fornite durante
          l&#39;autenticazione in un Dominio Windows NT o con le Active
          Directory di Windows 2000/3.</p>

          <p>Grosso svantaggio di <em>NTLM</em> &egrave; quello di essere
          <em>&quot;Connection Oriented</em>&quot;, ovvero <em>peer to
          peer</em>, ci&ograve; fa si che un server HTTP operante con
          l&#39;autenticazione NTLM non possa essere connesso tramite un
          Proxy Server, ma solamente in modalit&agrave;
          &quot;direct&quot;.</p>
        </div>

        <div class="SECT2">
          <hr />

          <h3 class="SECT2"><a name="SUBSEC-DIGEST-AUTHENTICATION" id=
          "SUBSEC-DIGEST-AUTHENTICATION"></a>11.2.3. Digest
          authentication</h3>

          <p>&Egrave; lo schema di autenticazione standard proposto come
          successore dello schema Basic, Digest authentication si propone
          di superare i problemi legati allo scambio in chiaro dello
          username e della password tra browser web e server HTTP. Digest
          utilizza un protocollo di tipo <em>challenge/handshake</em> per
          evitare la rivelazione della password quando la stessa viene
          immessa in rete. Attualmente lo schema di autenticazione Digest
          &egrave; largamente inutilizzato, bench&egrave; sia supportato
          dalle ultime versioni di Internet Explorer, Mozilla, Netscape ed
          Opera. Per maggiori dettagli sulla Digest authentication
          riferirsi alla RFC 2617 (<a href=
          "http://www.ietf.org/rfc/rfc2617.txt" target=
          "_top">http://www.ietf.org/rfc/rfc2617.txt</a>).</p>
        </div>
      </div>

      <div class="SECT1">
        <hr />

        <h2 class="SECT1"><a name="SEC-PARAMETRI-DI-CONFIGURAZIONE" id=
        "SEC-PARAMETRI-DI-CONFIGURAZIONE"></a>11.3. Parametri di
        Configurazione</h2>

        <p>Per il processo di autenticazione Squid utilizza dei programi
        esterni detti <em>helper</em> che si occupano della verifica delle
        credenziali utente. Tutti i parametri relativi alla configurazione
        dei tre schemi di autenticazione supportati sono specificati in
        <em>squid.conf</em> tramite la direttiva <em>auth_param</em>, il
        suo formato generico &egrave;</p>

        <table border="0" bgcolor="#E0E0E0" width="100%">
          <tr>
            <td>
              <pre class="PROGRAMLISTING">
auth_param schema parametro [valore]
  
</pre>
            </td>
          </tr>
        </table>

        <p>per attivare uno schema di autenticazione &eacute; sufficiente
        configurare l&#39;<em>helper</em> ad esso associato e riavviare
        Squid (<em>squid -k reconfigure</em>). L&#39;ordine con cui gli
        schemi di autenticazione vengono proposti al browser web segue
        l&#39;ordine con cui sono definiti nel file di configurazione
        <em>squid.conf</em>. Alcune versioni di Internet Explorer, a causa
        di un noto bug, non seguono fedelmente le specifiche RFC 2617
        (<a href="http://www.faqs.org/rfcs/rfc2617.html" target=
        "_top">http://www.faqs.org/rfcs/rfc2617.html</a>) e, anche in
        presenza di schemi pi&ugrave; sicuri, utilizzano erroneamente lo
        schema <em>Basic</em>, se questo viene proposto per primo al
        browser web. Per ovviare a questo problema, si raccomanda di
        definire gli schemi nel file di configurazione nell&#39;ordine
        <em>Digest</em>, <em>NTLM</em> e <em>Basic</em>.</p>

        <p>Una volta che uno schema di autenticazione &eacute; stato
        totalmente configurato, l&#39;unico modo per terminarne
        l&#39;esecuzione &eacute; riavviare Squid, modifiche alla
        configurazione possono essere eseguite &quot;al volo&quot; tramite
        il comando <em>squid -k reconfigure</em>. Per esempio, &eacute;
        possibile cambiare il tipo di l&#39;helper utilizzato, ma non
        &egrave; possibile disattivarne del tutto l&#39;utilizzo, in quanto
        lo stesso &egrave; legato ad uno schema di autenticazione attivo.
        Per utilizzare l&#39;autenticazione &egrave; necessario definire un
        TAG con una <em>acl</em> nella quale venga specificata almeno la
        seguente direttiva</p>

        <table border="0" bgcolor="#E0E0E0" width="100%">
          <tr>
            <td>
              <pre class="PROGRAMLISTING">
acl password proxy_auth REQUIRED
  
</pre>
            </td>
          </tr>
        </table>

        <p>tale direttiva definisce l&#39;elemento ACL <em>password</em>
        che potr&agrave; essere utilizzato in tutte le <a href=
        "#SEC-LISTE-DI-CONTROLLO-ACL">acl standard</a> di Squid. La scelta
        degli helper da attivare viene effettuata al momento della
        configurazione dei parametri di compilazione di Squid</p>

        <table border="0" bgcolor="#E0E0E0" width="100%">
          <tr>
            <td>
              <pre class="PROGRAMLISTING">
./configure --enable-schema-auth-helpers=&quot;elenco helper&quot;
  
</pre>
            </td>
          </tr>
        </table>

        <p>dove <em>schema</em> pu&ograve; assumere i valori <em>ntlm</em>,
        <em>basic</em> e <em>digest</em>, il nome dell&#39;helper da
        specificare &egrave; il nome (case sensitive) dalla cartella nel
        source tree di Squid che ne contiene i sorgenti</p>

        <table border="0" bgcolor="#E0E0E0" width="100%">
          <tr>
            <td>
              <pre class="PROGRAMLISTING">
./configure --enable-auth=&quot;ntlm basic&quot; \
--enable-ntlm-auth-helpers=&quot;fakeauth winbind SMB&quot; \
--enable-basic-auth-helpers=&quot;NCSA winbind MSNT&quot; 
  
</pre>
            </td>
          </tr>
        </table>

        <p>nell&#39;esempio precedente abbiamo selezionato gli schemi di
        autenticazione <em>Basic</em> e <em>NTLM,</em> contemporaneamente
        abbiamo anche definito gli helper <em>NCSA</em>, <em>winbind</em> e
        <em>MSNT</em> relativamente allo schema <em>Basic</em>. Abbiamo
        anche definito gli helpers <em>Fakeauth</em>, <em>winbind</em> ed
        <em>SMB</em> relativamente allo schema <em>NTLM</em>.</p>

        <p>Nota: In Squid 2.4, dove non esistono altri schemi di
        autenticazione oltre al <em>Basic</em>, la scelta degli helper da
        attivare pu&ograve; essere effettuata utilizzando la seguente
        opzione del comando configure</p>

        <table border="0" bgcolor="#E0E0E0" width="100%">
          <tr>
            <td>
              <pre class="PROGRAMLISTING">
./configure --enable-auth-modules=&quot;elenco helpers&quot;<em> </em>
  
</pre>
            </td>
          </tr>
        </table>

        <p>Il funzionamento globale del motore di autenticazione di Squid
        &eacute; controllato dalle seguenti direttive</p>

        <table border="0" bgcolor="#E0E0E0" width="100%">
          <tr>
            <td>
              <pre class="PROGRAMLISTING">
authenticate_cache_garbage_interval timespan
authenticate_ttl timetolive
authenticate_ip_ttl timetolive
  
</pre>
            </td>
          </tr>
        </table>

        <p>il TAG <em>authenticate_cache_garbage_interval timespan</em></p>

        <p>Definisce l&#39;intervallo con cui vengono effettuati i cicli di
        garbage collection sul contenuto della username cache. Il valore
        predefinito &eacute; 1 ora, e rappresenta un compromesso tra
        l&#39;utilizzo di memoria (intervalli lunghi, per esempio 2 giorni)
        e di CPU (intervalli brevi, per esempio 1 minuto). Si raccomanda di
        non variare questa impostaziona senza una valida motivazione</p>

        <table border="0" bgcolor="#E0E0E0" width="100%">
          <tr>
            <td>
              <pre class="PROGRAMLISTING">
authenticate_cache_garbage_interval 1 hour
  
</pre>
            </td>
          </tr>
        </table>

        <p>il TAG <em>authenticate_ttl timetolive</em></p>

        <p>Indica la durata del periodo per cui vengono mantenute in cache
        le credenziali relative ad un utente a partire dalla sua ultima
        richiesta. Quando viene iniziato un ciclo di garbage, tutte le
        credenziali utente il cui TTL &eacute; spirato vengono eliminate
        dalla memoria. Il valore predefinito &eacute; 1 ora.</p>

        <table border="0" bgcolor="#E0E0E0" width="100%">
          <tr>
            <td>
              <pre class="PROGRAMLISTING">
authenticate_ttl 1 hour
  
</pre>
            </td>
          </tr>
        </table>

        <p>il TAG <em>authenticate_ip_ttl timetolive</em></p>

        <p>Questa direttiva controlla quanto a lungo Squid conserva
        l&#39;associazione indirizzo IP/utente quando si utilizza uno o
        pi&ugrave; schemi di autenticazione in concomitanza con una ACL di
        tipo <em>&#39;max_user_ip&#39;</em>. Si raccomanda l&#39;utilizzo
        di un valore piccolo (per esempio 60 secondi) se si prevede che gli
        utenti possano cambiare indirizzo IP spesso, come nel caso di
        connessioni di tipo dialup. In reti locali di tipo corporate con
        indirizzi tendenzialmente statici &eacute; raccomandabile
        l&#39;utilizzo di valori maggiori (per esempio 2 ore). Il valore
        predefinito &eacute; 0 secondi.</p>

        <table border="0" bgcolor="#E0E0E0" width="100%">
          <tr>
            <td>
              <pre class="PROGRAMLISTING">
authenticate_ip_ttl 0 seconds
  
</pre>
            </td>
          </tr>
        </table>
      </div>

      <div class="SECT1">
        <hr />

        <h2 class="SECT1"><a name="SEC-BASIC-AUTHENTICATION" id=
        "SEC-BASIC-AUTHENTICATION"></a>11.4. Basic Authentication</h2>

        <p>Lo schema di autenticazione Basic era gi&agrave; disponibile in
        tutte le precedenti versioni di Squid, ma a partire dalla versione
        2.5 la sintassi delle direttive di configurazione contenute in
        <em>squid.conf</em> &eacute; sensibilmente variata rispetto alla
        versione precedente, per completezza analizzeremo entrambe le
        versioni.</p>

        <div class="SECT2">
          <hr />

          <h3 class="SECT2"><a name="SUBSEC-CONF-BASIC-AUTH-2.5" id=
          "SUBSEC-CONF-BASIC-AUTH-2.5"></a>11.4.1. Configurazione in Squid
          2.5</h3>

          <p>Lo schema di autenticazione <em>basic</em> utilizza i seguenti
          parametri</p>

          <table border="0" bgcolor="#E0E0E0" width="100%">
            <tr>
              <td>
                <pre class="PROGRAMLISTING">
auth_param basic program cmdline
auth_param basic children numberofchildren
auth_param basic realm realmstring
auth_param basic credentialsttl timetolive
   
</pre>
              </td>
            </tr>
          </table>

          <p>il TAG <em>program cmdline</em></p>

          <p>Specifica il comando che avvia il programma utenticatore
          esterno. Tale programma legge una riga da <em>stdin</em>
          contenente &quot;username password&quot; e risponde con
          &quot;OK&quot; o &quot;ERR&quot; in un loop senza fine. Come
          default, lo schema di autenticazione <em>basic</em> non viene
          attivato, a meno che non venga specificato un programma che si
          occupa di eseguire l&#39;autenticazione, ad esempio</p>

          <table border="0" bgcolor="#E0E0E0" width="100%">
            <tr>
              <td>
                <pre class="PROGRAMLISTING">
auth_param basic program /usr/local/squid/libexec/ncsa_auth \
/usr/local/squid/etc/passwd
   
</pre>
              </td>
            </tr>
          </table>

          <p>il TAG <em>children numberofchildren</em></p>

          <p>Indica quante istanze del programma di autenticazione devono
          essere eseguite contemporaneamente. Se viene configurato un
          numero di autenticatori troppo basso, Squid potrebbe essere
          costretto ad attendere un autenticatore libero, rallentando la
          navigazione. Il valore predefinito &egrave; 5</p>

          <table border="0" bgcolor="#E0E0E0" width="100%">
            <tr>
              <td>
                <pre class="PROGRAMLISTING">
auth_param basic children 5
   
</pre>
              </td>
            </tr>
          </table>

          <p>il TAG <em>realm realmstring</em></p>

          <p>Specifica il nome <em>realm</em> che viene fornito ai client
          per lo schema di autenticazione Basic, ovvero il testo che
          l&#39;utente vedr&agrave; nella dialog box di autenticazione
          proposta dal browser web. Il valore predefinito &egrave;
          &quot;Squid proxy-caching web server&quot;</p>

          <table border="0" bgcolor="#E0E0E0" width="100%">
            <tr>
              <td>
                <pre class="PROGRAMLISTING">
auth_param basic realm Squid proxy-caching web server
   
</pre>
              </td>
            </tr>
          </table>

          <p>il TAG <em>credentialsttl timetolive</em></p>

          <p>Specifica il tempo di vita (Time To Live o TTL) di una coppia
          <em>username:password</em> che viene validata esternamente. In
          altre parole, quanto spesso un programma helper debba validare
          nuovamente le credenziali per un dato utente. Il valore
          predefinito &eacute; due ore</p>

          <table border="0" bgcolor="#E0E0E0" width="100%">
            <tr>
              <td>
                <pre class="PROGRAMLISTING">
auth_param basic credentialsttl 2 hours
   
</pre>
              </td>
            </tr>
          </table>

          <p>&egrave; sempre possibile testare il corretto funzionamento di
          un helper per la Basic authentication semplicemente eseguendolo
          con la stessa riga comandi specificata in <em>squid.conf</em> e
          verificando che, immettendo delle coppie username:password, si
          ottengano le risposte &quot;OK&quot; o &quot;ERR&quot;
          previste.</p>
        </div>

        <div class="SECT2">
          <hr />

          <h3 class="SECT2"><a name="SUBSEC-CONF-BASIC-AUTH-2.4" id=
          "SUBSEC-CONF-BASIC-AUTH-2.4"></a>11.4.2. Configurazione in Squid
          2.4</h3>

          <p>Squid 2.4 supporta esclusivamente lo schema di autenticazione
          Basic ed utilizza i seguenti parametri</p>

          <table border="0" bgcolor="#E0E0E0" width="100%">
            <tr>
              <td>
                <pre class="PROGRAMLISTING">
authenticate_program cmdline
authenticate_children numberofchildren
   
</pre>
              </td>
            </tr>
          </table>

          <p>Il significato e la sintassi di queste direttive &eacute;
          analogo a quelle di Squid 2.5 che abbiamo trattato in
          precedenza</p>

          <p>il TAG <em>authenticate_program cmdline</em></p>

          <p>Specifica il comando che avvia il programma utenticatore
          esterno. Questo programma legge una riga da <em>stdin</em>
          contenente &quot;username:password&quot; e risponde con
          &quot;OK&quot; o &quot;ERR&quot; in un loop senza fine. Come
          default, lo schema di autenticazione basic non viene attivato a
          meno che non sia specificato un programma che esegue
          l&#39;autenticazione. Questo TAG equivale alla direttiva di Squid
          2.5 <em>auth_param basic program cmdline</em>, ad esempio</p>

          <table border="0" bgcolor="#E0E0E0" width="100%">
            <tr>
              <td>
                <pre class="PROGRAMLISTING">
authenticate_program /usr/local/squid/libexec/ncsa_auth /usr/local/squid/etc/passwd
   
</pre>
              </td>
            </tr>
          </table>

          <p>il TAG <em>authenticate_children numberofchildren</em></p>

          <p>Indica quante istanze del programma di autenticazione devono
          essere eseguite contemporaneamente. Se viene configurato un
          numero di autenticatori troppo basso, Squid potrebbe essere
          costretto ad attendere un autenticatore libero, rallentando la
          navigazione. Questo TAG equivale alla direttiva di Squid 2.5
          <em>&quot;auth_param basic children numberofchildren&quot;</em>,
          il valore predefinito &egrave; 5.</p>

          <table border="0" bgcolor="#E0E0E0" width="100%">
            <tr>
              <td>
                <pre class="PROGRAMLISTING">
authenticate_children 5
   
</pre>
              </td>
            </tr>
          </table>

          <p>Nel seguito di questo documento saranno trattati in dettaglio
          gli autenticatori relativi a Squid 2.5, si tenga presente che le
          configurazioni indicate possono essere valide anche per Squid 2.4
          sempre che si utilizzi la differente sintassi nelle direttive di
          configurazione in <em>squid.conf</em>.</p>
        </div>

        <div class="SECT2">
          <hr />

          <h3 class="SECT2"><a name="SUBSEC-NCSA" id=
          "SUBSEC-NCSA"></a>11.4.3. helper NCSA</h3>

          <p>&Eacute; storicamente il primo authentication helper
          utilizzato in Squid. Utilizza un file di password sullo stile di
          NCSA httpd (o pi&uacute; recentemente Apache) per eseguire
          l&#39;autenticazione con alcune varianti rispetto al formato
          originale</p>

          <ul>
            <li>
              <p>Le linee che iniziano con &#39;#&#39; sono considerate un
              commento</p>
            </li>

            <li>
              <p>&Eacute; possibile lasciare delle linee vuote</p>
            </li>

            <li>
              <p>Tutti i campi extra del file di password sono ignorati,
              ci&ograve; permette l&#39;utilizzo diretto di un file di
              password Unix</p>
            </li>
          </ul>

          <p>ecco un esempio di configurazione</p>

          <table border="0" bgcolor="#E0E0E0" width="100%">
            <tr>
              <td>
                <pre class="PROGRAMLISTING">
auth_param basic program /usr/local/squid/libexec/ncsa_auth \
/usr/local/squid/etc/passwd
auth_param basic children 10
auth_param basic realm Squid proxy-caching web server
auth_param basic credentialsttl 30 minutes
   
</pre>
              </td>
            </tr>
          </table>

          <p>In questo caso <em>ncsa_auth</em> si trova in
          <em>/usr/local/squid/libexec</em>, il file contenente le password
          &eacute; <em>/usr/local/squid/etc/passwd</em>, il numero di
          helper in esecuzione &eacute; 10 ed il TTL
          dell&#39;autenticazione &eacute; pari a 30 minuti. L&#39;helper
          <em>ncsa_auth</em> &eacute; utilizzabile su tutte le piattaforme
          supportate da Squid.</p>

          <div class="SECT3">
            <hr />

            <h4 class="SECT3"><a name=
            "SUBSUBSEC-GENERARE-IL-DB-DEGLI-UTENTI" id=
            "SUBSUBSEC-GENERARE-IL-DB-DEGLI-UTENTI"></a>11.4.3.1. Generare
            il DB degli utenti</h4>

            <p>Il file contenente le userid e le password che verranno
            interpretate da <em>ncsa_auth</em> pu&ograve; essere generato
            utilizzando l&#39;applicazione <em>htpasswd</em> fornita come
            corredo standard del server web apache. Di seguito la corretta
            sintassi per la creazione del file
            <em>/usr/local/squid/etc/passwd</em></p>

            <table border="0" bgcolor="#E0E0E0" width="100%">
              <tr>
                <td>
                  <pre class="PROGRAMLISTING">
[root@umilta /root]# htpasswd -c /usr/local/squid/etc/passwd stefano 
New password: 
Re-type new password: 
Adding password for user stefano 
    
</pre>
                </td>
              </tr>
            </table>

            <p>Pedro Lineu Orso ha realizzato due ottimi strumenti per la
            gestione tramite interfaccia WEB del file di password:
            <em>admuser</em> e <em>chpasswd</em> disponibili su <a href=
            "http://web.onda.com.br/orso/" target=
            "_top">http://web.onda.com.br/orso/</a>.</p>
          </div>
        </div>

        <div class="SECT2">
          <hr />

          <h3 class="SECT2"><a name="SUBSEC-PAM" id=
          "SUBSEC-PAM"></a>11.4.4. helper PAM</h3>

          <p>Questo authentication helper consente a Squid l&#39;utilizzo
          pratico di qualsiasi modulo PAM (Pluggable Authentication Module)
          per validare un utente. I moduli PAM pi&uacute; utilizzati sono
          Unix, Radius, Kerberos e SMB. Sono comunque disponibili molti
          altri moduli meno noti presso varie fonti, ecco un esempio di
          configurazione</p>

          <table border="0" bgcolor="#E0E0E0" width="100%">
            <tr>
              <td>
                <pre class="PROGRAMLISTING">
auth_param basic program /usr/local/squid/libexec/pam_auth
auth_param basic children 5
auth_param basic realm Squid proxy-caching web server
auth_param basic credentialsttl 45 minutes
   
</pre>
              </td>
            </tr>
          </table>

          <p>in questo caso <em>pam_auth</em> si trova in
          <em>/usr/local/squid/libexec</em>, il numero di helper in
          esecuzione &eacute; 5 ed il TTL dell&#39;autenticazione &eacute;
          pari a 45 minuti. L&#39;helper <em>pam_auth</em> &eacute;
          utilizzabile solamente sulle piattaforme supportate da Squid che
          forniscono i servizi PAM a livello di sistema. Il nome di default
          del servizio PAM utilizzato &eacute; <em>squid</em>. La
          configurazione del supporto PAM pu&ograve; variare in funzione
          della piattaforma utilizzata, sono disponibili le seguenti
          opzioni</p>

          <table border="0" bgcolor="#E0E0E0" width="100%">
            <tr>
              <td>
                <pre class="PROGRAMLISTING">
-n service_name  The PAM service name (default squid)
-t ttl           PAM connection ttl in seconds (default 0)
                 during this time the same connection will be reused
                 to authenticate all users
-o               Do not perform account mgmt (account expiration etc)
-1               Only one user authentication per PAM connection
   
</pre>
              </td>
            </tr>
          </table>

          <p>Per maggiori dettagli riferirsi a <em>pam</em>(8)<em>,
          &quot;PAM Systems Administrator Guide&quot;.</em></p>

          <div class="SECT3">
            <hr />

            <h4 class="SECT3"><a name="SUBSUBSEC-RED-HAT-LINUX-PAM" id=
            "SUBSUBSEC-RED-HAT-LINUX-PAM"></a>11.4.4.1. Red Hat Linux</h4>

            <p>Creare il file <em>/etc/pam.d/squid</em> utilizzando il
            comando</p>

            <table border="0" bgcolor="#E0E0E0" width="100%">
              <tr>
                <td>
                  <pre class="PROGRAMLISTING">
touch /etc/pam.d/squid 
    
</pre>
                </td>
              </tr>
            </table>

            <p>Il file deve contenere le seguenti entry:</p>

            <table border="0" bgcolor="#E0E0E0" width="100%">
              <tr>
                <td>
                  <pre class="PROGRAMLISTING">
Auth required     /lib/security/pam_stack.so service=system-auth
Auth required     /lib/security/pam_nologin.so 
account required  /lib/security/pam_stack.so service=system-auth
password required /lib/security/pam_stack.so service=system-auth
session required  /lib/security/pam_stack.so service=system-auth
    
</pre>
                </td>
              </tr>
            </table>
          </div>

          <div class="SECT3">
            <hr />

            <h4 class="SECT3"><a name="SUBSUBSEC-UNIX-STANDARD-PAM" id=
            "SUBSUBSEC-UNIX-STANDARD-PAM"></a>11.4.4.2. Unix Standard</h4>

            <p>Per utilizzare <em>/etc/passwd</em> standard modificare il
            file <em>/etc/pam.conf</em></p>

            <table border="0" bgcolor="#E0E0E0" width="100%">
              <tr>
                <td>
                  <pre class="PROGRAMLISTING">
squid auth required /lib/security/pam_unix.so.1
squid account required /lib/security/pam_unix.so.1
    
</pre>
                </td>
              </tr>
            </table>

            <p>si noti che alcuni moduli PAM, per esempio
            l&#39;autenticazione tramite shadow password, necessitano che
            il programma sia installato con privilegio di <em>root
            suid</em> per poter avere accesso al database delle password
            utente.</p>
          </div>
        </div>

        <div class="SECT2">
          <hr />

          <h3 class="SECT2"><a name="SUBSEC-LDAP" id=
          "SUBSEC-LDAP"></a>11.4.5. helper LDAP</h3>

          <p>L&#39;helper <em>squid_ldap_auth</em> consente a Squid di
          connettersi ad un Directory Service LDAP per validare username e
          password<em>.</em> Nel seguito di questo paragrafo verranno
          trattati alcuni argomenti la cui comprensione &eacute;
          strettamente dipendente da una buona conoscenza del protocollo
          LDAP, per maggiori dettagli al riguardo, riferirsi al sito del
          progetto OpenLDAP (<a href="http://www.openldap.org" target=
          "_top">http://www.openldap.org</a>).</p>

          <p>Il programma ha due modalit&agrave; di funzionamento: nella
          modalit&agrave; di funzionamento predefinita il DN (Distinguished
          Name) dell&#39;utente da validare &eacute; costruito utilizzando
          un DN base e l&#39;attributo user. Nell&#39;altra modalit&agrave;
          di funzionamento, viene utilizzato un filtro di ricerca per
          localizzare nella Directory un user DN valido rispetto al DN
          base. Questo autenticatore consente l&#39;interfacciamento con
          tutti i maggiori Directory Service attualmente disponibili</p>

          <ul>
            <li>
              <p>Microsoft Active Directory</p>
            </li>

            <li>
              <p>Novell NDS</p>
            </li>

            <li>
              <p>Lotus Notes Directory</p>
            </li>

            <li>
              <p>Sun Java System Directory</p>
            </li>
          </ul>

          <p>ecco un esempio di configurazione</p>

          <table border="0" bgcolor="#E0E0E0" width="100%">
            <tr>
              <td>
                <pre class="PROGRAMLISTING">
auth_param basic program /usr/local/squid/libexec/squid_ldap_auth -b \
dc=your,dc=domain 
auth_param basic children 5
auth_param basic realm Squid proxy-caching web server
auth_param basic credentialsttl 30 minutes
   
</pre>
              </td>
            </tr>
          </table>

          <p>in questo caso <em>squid_ldap_auth</em> si trova in
          <em>/usr/local/squid/libexec</em>, il numero di helper in
          esecuzione &eacute; 5 ed il TTL dell&#39;autenticazione &eacute;
          pari a 30 minuti e il server LDAP si trova sulla macchina proxy.
          L&#39;helper <em>squid_ldap_auth</em> &eacute; utilizzabile
          solamente sulle piattaforme supportate da Squid sui cui sono
          disponibili le librerie OpenLDAP od un un altra C-API LDAP
          compatibile. A riguardo dell&#39;helper sono disponibili le
          seguenti opzioni</p>

          <table border="0" bgcolor="#E0E0E0" width="100%">
            <tr>
              <td>
                <pre class="PROGRAMLISTING">
squid_ldap_auth -b basedn [-s searchscope]
               [-f searchfilter] [-D binddn -w bindpasswd]
               [-u attr] [-h host] [-p port] [-P] [-R] [ldap_server_name[:port]] ...
   
</pre>
              </td>
            </tr>
          </table>

          <p>L&#39;opzione -b deve essere sempre specificata. Per dettagli
          sulle opzioni si raccomanda di visionare la man page relativa a
          <em>squid_ldap_auth</em> fornita con Squid.</p>

          <div class="SECT3">
            <hr />

            <h4 class="SECT3"><a name="SUBSEC-ES-DI-CONFIGURAZIONE-LDAP"
            id="SUBSEC-ES-DI-CONFIGURAZIONE-LDAP"></a>11.4.5.1. Esempi di
            configurazione</h4>

            <p>Di seguito vengono proposti alcuni esempi di utilizzo di
            <em>squid_ldap_auth.</em></p>

            <p>Nel caso in cui la Directory utilizza il layout definito
            dalla RFC 2307 (<a href="http://www.faqs.org/rfcs/rfc2307.html"
            target="_top">http://www.faqs.org/rfcs/rfc2307.html</a>) con un
            singolo dominio, &eacute; sufficiente specificare il nome del
            DN base sotto il quale si trovano gli utenti ed i server</p>

            <table border="0" bgcolor="#E0E0E0" width="100%">
              <tr>
                <td>
                  <pre class="PROGRAMLISTING">
squid_ldap_auth -b ou=people,dc=your,dc=domain ldapserver
    
</pre>
                </td>
              </tr>
            </table>

            <p>se invece si utilizzano dei sottodomini, si rende necessario
            ricorrere ad un filtro per localizzale il DN dell&#39;utente in
            quanto questo non pu&ograve; essere ricostruito a partire dal
            DN base e dal login name</p>

            <table border="0" bgcolor="#E0E0E0" width="100%">
              <tr>
                <td>
                  <pre class="PROGRAMLISTING">
squid_ldap_auth -b dc=your,dc=domain -f uid=%s ldapserver
    
</pre>
                </td>
              </tr>
            </table>

            <p>In modo simile, se si intende concedere l&#39;accesso solo
            agli utenti che hanno un attributo specifico</p>

            <table border="0" bgcolor="#E0E0E0" width="100%">
              <tr>
                <td>
                  <pre class="PROGRAMLISTING">
squid_ldap_auth -b dc=your,dc=domain -f (&amp;(uid=%s)(specialattribute=value)) ldapserver
    
</pre>
                </td>
              </tr>
            </table>

            <p>nel caso in cui l&#39;attributo <em>user</em> del DN
            dell&#39;utente sia &quot;cn&quot; invece di &quot;uid&quot; e
            non si vogliano fare ricerche per identificare l&#39;utente, o
            nel caso di Active Directory, &eacute; possibile utilizzare
            qualcosa di simile</p>

            <table border="0" bgcolor="#E0E0E0" width="100%">
              <tr>
                <td>
                  <pre class="PROGRAMLISTING">
squid_ldap_auth -u cn -b cn=Users,dc=your,dc=domain ldapserver
    
</pre>
                </td>
              </tr>
            </table>

            <p>nel caso in cui, volendo eseguire delle ricerche, la
            Directory non consenta ricerche di tipo anonimo, &eacute;
            possibile utilizzare le opzioni -D e -w per specificare un DN
            utente e relativa password per connettersi alla Directory ed
            eseguire la ricerca, come nel seguente esempio per Active
            Directory</p>

            <table border="0" bgcolor="#E0E0E0" width="100%">
              <tr>
                <td>
                  <pre class="PROGRAMLISTING">
squid_ldap_auth -p -R -b dc=your,dc=domain \
-D cn=squid,cn=users,dc=your,dc=domain -w secretsquidpassword \
-f (&amp;(userPrincipalName=%s)(objectClass=Person)) activedirectoryserver
    
</pre>
                </td>
              </tr>
            </table>
          </div>
        </div>

        <div class="SECT2">
          <hr />

          <h3 class="SECT2"><a name="SUBSEC-WINBIND" id=
          "SUBSEC-WINBIND"></a>11.4.6. helper Winbindd</h3>

          <p>L&#39;helper <em>wb_auth</em> consente la validazione degli
          utenti su di un dominio Windows NT 4 o Windows 2000 Active
          Directory. Per il suo corretto funzionamento necessita che Samba
          2.2.4 (<a href="http://www.samba.org/" target=
          "_top">http://www.samba.org/</a>) o seguenti siano installati sul
          sistema. Per i dettagli relativi alla configurazione di Samba,
          riferirisi alle sezioni relative all&#39;<a href=
          "#SEC-AUTENTICAZIONE-CON-SAMBA-2.2.X">Autenticazione con Samba
          2.2.x</a> e alla configurazione di <a href=
          "#SEC-WINBIND">Winbindd</a>. Ecco un esempio di
          configurazione</p>

          <table border="0" bgcolor="#E0E0E0" width="100%">
            <tr>
              <td>
                <pre class="PROGRAMLISTING">
auth_param basic program /usr/local/squid/libexec/wb_auth
auth_param basic children 5
auth_param basic realm Squid proxy-caching web server
auth_param basic credentialsttl 30 minutes
   
</pre>
              </td>
            </tr>
          </table>

          <p>In questo caso <em>wb_auth</em> si trova in
          <em>/usr/local/squid/libexec</em>, il numero di helper in
          esecuzione &eacute; 5 ed il TTL dell&#39;autenticazione &eacute;
          pari a 30 minuti. L&#39;helper <em>wb_auth</em> &eacute;
          utilizzabile solamente sulle piattaforme supportate da Squid per
          cui &eacute; disponibile Samba versione 2.2.4 o seguenti. Sono
          disponibili le seguenti opzioni:</p>

          <table border="0" bgcolor="#E0E0E0" width="100%">
            <tr>
              <td>
                <pre class="PROGRAMLISTING">
-d enable debugging
-h this message
   
</pre>
              </td>
            </tr>
          </table>

          <p>L&#39;opzione <em>-d</em> consente una diagnostica abbastanza
          chiara e precisa dei problemi. Per controllare il funzionamento
          di winbindd, &eacute; possibile utilizzare il tool
          <em>wbinfo</em> fornito con Samba.</p>

          <p>Attenzione: <em>wb_auth</em> <em>non funziona con Samba
          3.x</em>, &egrave; necessario riferirsi alla sezione dedicata a
          <a href="#SEC-AUTENTICAZIONE-CON-SAMBA-3.X">Samba 3</a> per
          ottenere maggiori dettagli.</p>
        </div>

        <div class="SECT2">
          <hr />

          <h3 class="SECT2"><a name="SUBSEC-MSNT" id=
          "SUBSEC-MSNT"></a>11.4.7. helper MSNT</h3>

          <p>Questo helper consente di verificare l&#39;autenticazione
          degli utenti appartenenti a un dominio Windows NT 4 o Active
          Directory Windows 2000/2003. Tale funzionalit&agrave; &eacute;
          attualmente resa disponibile con prestazioni migliori
          dall&#39;helper <a href="#SUBSEC-WINBIND">Winbind</a>. Ecco un
          esempio di configurazione</p>

          <table border="0" bgcolor="#E0E0E0" width="100%">
            <tr>
              <td>
                <pre class="PROGRAMLISTING">
auth_param basic program /usr/local/squid/libexec/msntauth
auth_param basic children 8
auth_param basic realm Squid proxy-caching web server
auth_param basic credentialsttl 15 minutes
   
</pre>
              </td>
            </tr>
          </table>

          <p>In questo caso <em>msntauth</em> si trova in
          <em>/usr/local/squid/libexec</em>, il numero di helper in
          esecuzione &eacute; 8 ed il TTL dell&#39;autenticazione &eacute;
          pari a 15 minuti. L&#39;helper <em>msntauth</em> &eacute;
          utilizzabile solamente sulle piattaforme supportate da Squid su
          cui &eacute; possibile compilare le librerie Samba su cui
          &eacute; basato (Samba non &eacute; comunque richiesto).</p>

          <p>A partire dalla versione 2, <em>msntauth</em> utilizza un file
          di configurazione denominato <em>msntauth.conf</em>, la directory
          di default del file <em>msntauth.conf</em> &egrave;
          <em>/usr/local/squid/etc/msntauth.conf</em>, il suo formato
          &egrave; il seguente:</p>

          <table border="0" bgcolor="#E0E0E0" width="100%">
            <tr>
              <td>
                <pre class="PROGRAMLISTING">
# 
#      PDC       BDC         DOMAIN 
#      --------- ----------- ----------- 
server paperino  pippo       mio_dominio 
# 
denyusers /usr/local/squid/etc/denyusers 
allowusers /usr/local/squid/etc/allowusers
   
</pre>
              </td>
            </tr>
          </table>

          <p>nell&#39;esempio di cui sopra <em>paperino</em> e
          <em>pippo</em> sono i nomi dei server che svolgono le funzioni di
          domain controller, <em>mio_dominio</em> &egrave; il nome del
          dominio windows. Gli utenti non abilitati ad accedere alla rete
          internet possono essere indicati nel file identificato dalla
          direttiva <em>denyusers</em>. Questo file contiene una lista di
          nomi utente per i quali non &egrave; richiesta una struttura
          particolare. Se il file non esiste o &egrave; vuoto a nessun
          utente verr&agrave; applicata la negazione di accesso, il file
          deve essere leggibile dall&#39;utente con cui gira Squid,
          specificato dalla direttiva <em>cache_effective_user</em> in
          <em>squid.conf</em>. Gli utenti abilitati per accedere alla rete
          internet vengono dichiarati nel file identificato dalla direttiva
          <em>allowusers</em>, questo file contiene una lista di utenti
          autorizzati la cui compilazione non richiede una particolare
          struttura, se il file non esiste o &egrave; vuoto verr&agrave;
          comunque ignorato.</p>
        </div>
      </div>

      <div class="SECT1">
        <hr />

        <h2 class="SECT1"><a name="SEC-SQUID-25-AUTENTICAZIONE-NTLM" id=
        "SEC-SQUID-25-AUTENTICAZIONE-NTLM"></a>11.5. NTLM
        Authentication</h2>

        <p>In questa sezione tratteremo lo schema di autenticazione
        <em>NTLM</em> che &egrave; stato implementato a partire versione
        2.5 di Squid, faremo riferimento al protocollo <em>NTLM</em>,
        analizzando le modalit&agrave; di utilizzo di questo sistema di
        validazione.</p>

        <div class="SECT2">
          <hr />

          <h3 class="SECT2"><a name="SUBSEC-CONF-NTLM-AUTHENTICATION" id=
          "SUBSEC-CONF-NTLM-AUTHENTICATION"></a>11.5.1. Configurazione</h3>

          <p>Vediamo in questo paragrafo quali sono le necessit&agrave;
          immediate alle quali risponde lo schema di autenticazione NTLM di
          Squid</p>

          <ul>
            <li>
              <p>Implementare una gestione centralizzata degli utenti di
              tipo <em>single-sign-on</em> evitando particolari oneri
              gestionali per l&#39;amministratore della cache e
              semplificando le procedure di accesso ad internet degli
              utenti.</p>
            </li>

            <li>
              <p>Incrementare il livello di sicurezza evitando che
              transitino sulla rete password in chiaro</p>
            </li>
          </ul>

          <p>l&#39;Autenticazione <a href="#SEC-AUTENTICAZIONE">NTLM</a>
          funziona <em>esclusivamente</em> con la versione 2.5 di Squid.
          Sino alla versione 2.5.STABLE4 viene supportata soltanto la
          versione 1 del protocollo NTLM, a partire dalla versione
          2.5.STABLE5 viene anche supportata la versione 2 del protocollo
          NTLM grazie al nuovo supporto dei pacchetti del tipo NTLM
          NEGOTIATE. Si rammenta al lettore che, se si intende utilizzare
          delle password o degli oggetti di lunghezza superiore a 14
          caratteri, &egrave; necessario ricorrere ad un helper che sia in
          grado di interpretare correttamente i pacchetti NTLM NEGOTIATE
          (NTLMv2) con la relativa funzionalit&agrave; abilitata in
          <em>squid.conf</em>. Lo schema di autenticazione NTLM utilizza i
          seguenti parametri</p>

          <table border="0" bgcolor="#E0E0E0" width="100%">
            <tr>
              <td>
                <pre class="PROGRAMLISTING">
auth_param ntlm program cmdline
auth_param ntlm children numberofchildren
auth_param ntlm max_challenge_reuses number
auth_param ntlm max_challenge_lifetime timespan
auth_param ntlm use_ntlm_negotiate on|off
   
</pre>
              </td>
            </tr>
          </table>

          <p>il TAG <em>program cmdline</em></p>

          <p>Specifica il comando che avvia il programma utenticatore
          esterno. Tale programma legge una riga da <em>stdin</em>
          contenente pacchetti NTLM di tipo NEGOTIATE in formato uuencoded
          e risponde su <em>stdout</em> con pacchetti NTLM di tipo
          challenge/response in formato uuencoded in un loop senza fine. Di
          default, lo schema di autenticazione NTLM non viene attivato, a
          meno che non sia specificato un programma autenticatore. Ad
          esempio:</p>

          <table border="0" bgcolor="#E0E0E0" width="100%">
            <tr>
              <td>
                <pre class="PROGRAMLISTING">
auth_param ntlm program /usr/local/squid/libexec/wb_ntlmauth
   
</pre>
              </td>
            </tr>
          </table>

          <p>il TAG <em>children numberofchildren</em></p>

          <p>Indica quante istanze del programma di autenticazione devono
          essere eseguite contemporaneamente. Se viene configurato un
          numero di autenticatori troppo basso, Squid potrebbe essere
          costretto ad attendere un autenticatore libero, rallentando la
          navigazione. Il valore predefinito &egrave; 5.</p>

          <table border="0" bgcolor="#E0E0E0" width="100%">
            <tr>
              <td>
                <pre class="PROGRAMLISTING">
auth_param ntlm children 5
   
</pre>
              </td>
            </tr>
          </table>

          <p>il TAG <em>max_challenge_reuses number</em></p>

          <p>Specifica il massimo numero di volte che un challenge fornito
          da un helper pu&ograve; essere riutilzzato. Il valore 0 implica
          che il challenge pu&ograve; essere utilizzato una volta sola
          (caching disabilitato).</p>

          <table border="0" bgcolor="#E0E0E0" width="100%">
            <tr>
              <td>
                <pre class="PROGRAMLISTING">
auth_param ntlm max_challenge_reuses 0
   
</pre>
              </td>
            </tr>
          </table>

          <p>il TAG <em>max_challenge_lifetime timespan</em></p>

          <p>Specifica il massimo periodo di tempo per cui un challenge
          fornito da un helper pu&ograve; essere riutilzzato.
          L&#39;effetivo periodo di validit&agrave; del challenge &eacute;
          dato dal minimo tra il numero di riutilizzi consentiti ed il
          tempo qui specificato.</p>

          <table border="0" bgcolor="#E0E0E0" width="100%">
            <tr>
              <td>
                <pre class="PROGRAMLISTING">
auth_param ntlm max_challenge_lifetime 2 minutes
   
</pre>
              </td>
            </tr>
          </table>

          <p>il TAG <em>use_ntlm_negotiate</em></p>

          <p>Abilita il supporto per lo scambio dei pacchetti NTLM
          NEGOTIATE con l&#39;helper. L&#39;helper NTLM configurato deve
          essere in grado di gestire i pacchetti NTLM NEGOTIATE. In caso di
          dubbi riferirsi alla documentazione dell&#39;helper.
          <em>ntlm_auth</em> fornito con Samba 3.0.2 o seguenti supporta
          l&#39;utilizzo di questa opzione. Per compatibilit&agrave; con i
          vecchi helper e configurazioni esistenti, il valore predefinito
          &eacute; off. Questa opzione &eacute; disponibile a partire dalla
          versione 2.5.STABLE5 di Squid.</p>

          <table border="0" bgcolor="#E0E0E0" width="100%">
            <tr>
              <td>
                <pre class="PROGRAMLISTING">
auth_param ntlm use_ntlm_negotiate on
   
</pre>
              </td>
            </tr>
          </table>

          <p>a differenza dello schema di autenticazione Basic, <em>non
          &eacute; possibile</em> testare il corretto funzionamento di un
          helper per la NTLM authentication, in quanto le transazioni di
          autenticazione non sono di tipo unitario, ma prevedono delle
          sequenze di challenge/response non simulabili tra il browser
          client e l&#39;autenticatore.</p>
        </div>

        <div class="SECT2">
          <hr />

          <h3 class="SECT2"><a name="SEC-AUTH-NTLM-NATIVA" id=
          "SEC-AUTH-NTLM-NATIVA"></a>11.5.2. Autenticazione NTLM
          nativa</h3>

          <p>Anche se non &egrave; corretto utilizzare il temine
          &quot;autenticazione NTLM nativa&quot;, in quanto si tratta di un
          sistema di autenticazione proprietario realizzato dalla
          Microsoft, in questo paragrafo tratteremo l&#39;utilizzo degli
          helper NTLM che sono stati inclusi nativamente nella
          distribuzione di Squid, questi helper non devono ricorrere
          necessariamente al supporto di altre applicazioni esterne come
          Samba.</p>

          <div class="SECT3">
            <hr />

            <h4 class="SECT3"><a name="SUBSEC-NTLM-AUTH" id=
            "SUBSEC-NTLM-AUTH"></a>11.5.2.1. helper SMB (ntlm_auth)</h4>

            <p>Questo helper permette di autenticare gli utenti tramite il
            protocollo NTLMv1 nell&#39;ambito di un Domain Controller per
            un dominio WIndows NT <em>4</em> o in <em>Active
            Directory.</em> La configurazione &egrave; quanto mai
            semplice</p>

            <table border="0" bgcolor="#E0E0E0" width="100%">
              <tr>
                <td>
                  <pre class="PROGRAMLISTING">
auth_param ntlm program /usr/local/squid/libexec/ntlm_auth DOMINIO/SERVER [DOMINIO/SERVER ...]
auth_param ntlm children 10 
auth_param ntlm max_challenge_reuses 2 
auth_param ntlm max_challenge_lifetime 15 minutes 
auth_param ntlm use_ntlm_negotiate off
    
</pre>
                </td>
              </tr>
            </table>

            <p>In questo caso <em>ntlm_auth</em> si trova in
            <em>/usr/local/squid/libexec</em>, il numero di helper in
            esecuzione &eacute; 5, i challenge possono essere riutilizzati
            due volte ed il loro TTL &eacute; pari a 15 minuti.</p>

            <p>L&#39;helper <em>ntlm_auth</em> &eacute; utilizzabile
            solamente sulle piattaforme supportate da Squid su cui &eacute;
            possibile compilare le librerie Samba su cui &eacute; basato
            (Samba non &eacute; comunque richiesto), e NON supporta i
            pacchetti NTLM NEGOTIATE quindi il protocollo NTLMv2, la
            lunghezza delle password utilizzate non pu&ograve; superare un
            numero massimo di 14 caratteri. La macchina SERVER deve essere
            un Domain Controller e deve essere sicuramente raggiungibile,
            in caso di incertezze, si consiglia di mettere una voce nel
            file <em>/etc/hosts</em>. &Eacute; possibile specificare
            pi&ugrave; di un domain controller, ma tutti i domain
            controller devono appartenere allo stesso dominio. Sono
            disponibili le seguenti opzioni</p>

            <table border="0" bgcolor="#E0E0E0" width="100%">
              <tr>
                <td>
                  <pre class="PROGRAMLISTING">
-b enables load-balancing among controllers.
-f enables failover among controllers (DEPRECATED and always active).
-l changes behavior on domain controller failures to last-ditch.
-d enables debugging statements if DEBUG was defined at build-time.
    
</pre>
                </td>
              </tr>
            </table>

            <p>L&#39;opzione <em>-d</em> consente una diagnostica
            abbastanza chiara e precisa dei problemi</p>

            <p>Questo helper presentava alcuni problemi che venivano
            erroneamente imputati alla non perfetta implementazione del
            protocolo SMB e che provocavano delle saltuarie richieste di
            autenticazione da parte del Browser. A partire da Squid
            2.5.STABLE5, questo tipo di anomalia &egrave; stato eliminato,
            pertanto questo helper pu&ograve; essere tranquillamente
            utilizzato nel caso in cui si decidesse di utilizzare il
            protocollo NTLMv1 per autenticarsi in un sistema <em>Active
            Directory</em>.</p>
          </div>

          <div class="SECT3">
            <hr />

            <h4 class="SECT3"><a name="SUBSEC-FAKEAUTH-AND-NO-CHECK" id=
            "SUBSEC-FAKEAUTH-AND-NO-CHECK"></a>11.5.2.2. helper fakeauth
            &amp; no_check</h4>

            <p>Questi helper non compiono alcuna validazione, ma si
            limitano ad eseguire una transazione NTLM di tipo
            challenge/response senza eseguire alcuna validazione. Il loro
            utilizzo pu&ograve; rivelarsi particolarmente utile a scopo di
            debugging relativamente alla componente NTLM di Squid o per
            casi particolari, casi nei quali si voglia eseguire solamente
            il logging degli utenti. I riferimenti di configurazione per
            <em>squid.conf</em> sono i seguenti</p>

            <table border="0" bgcolor="#E0E0E0" width="100%">
              <tr>
                <td>
                  <pre class="PROGRAMLISTING">
auth_param ntlm program /usr/squid/libexec/fake_auth 
auth_param ntlm children 5 
auth_param ntlm max_challenge_reuses 20 
auth_param ntlm max_challenge_lifetime 15 minutes
auth_param ntlm use_ntlm_negotiate off
    
</pre>
                </td>
              </tr>
            </table>

            <p>In questo caso <em>fake_auth</em> si trova in
            <em>/usr/local/squid/libexec</em>, il numero di helper in
            esecuzione &eacute; 5, i challenge possono essere riutilizzati
            20 volte ed il loro TTL &eacute; pari a 15 minuti. Gli helper
            <em>fake_auth</em> e <em>no_check</em> sono utilizzabili su
            tutte le piattaforme supportate da Squid, e NON supportano i
            pacchetti NTLM NEGOTIATE (NTLMv2).</p>
          </div>

          <div class="SECT3">
            <hr />

            <h4 class="SECT3"><a name="SEC-WINDOWS-NTLM-AUTH" id=
            "SEC-WINDOWS-NTLM-AUTH"></a>11.5.2.3. helper Windows
            win32_ntlm_auth</h4>

            <p>L&#39;helper <em>win32_ntlm_auth</em> riguarda
            esclusivamente Squid per la piattaforma Win32 e consente la
            validazione trasparente degli utenti su di un dominio Windows
            NT 4 o Windows 2000 Active Directory. Inoltre &eacute;
            supportato in modo totalmente automatico l&#39;utilizzo dei
            pacchetti NTLM NEGOTIATE (NTLMv2). Non necessita di alcuna
            componente esterna in quanto si appoggia sulle API native del
            sistema operativo</p>

            <table border="0" bgcolor="#E0E0E0" width="100%">
              <tr>
                <td>
                  <pre class="PROGRAMLISTING">
auth_param ntlm program c:/squid/libexec/win32_ntlm_auth.exe
auth_param ntlm children 5
auth_param ntlm max_challenge_reuses 0
auth_param ntlm max_challenge_lifetime 2 minutes
auth_param ntlm use_ntlm_negotiate on
    
</pre>
                </td>
              </tr>
            </table>

            <p>In questo caso <em>win32_ntlm_auth.exe</em> si trova in
            <em>c:/squid/libexec</em>, il numero di helper in esecuzione
            &eacute; 5, i challenge non possono essere riutilizzati, il
            supporto per i pacchetti NTLM NEGOTIATE &eacute; abilitato.
            L&#39;helper <em>win32_ntlm_auth</em> &eacute; utilizzabile
            solamente in ambiente Windows nativo o Cygwin ed &eacute;
            disponibile nei relativi package Squid. Per questo helper sono
            disponibili le seguenti opzioni</p>

            <table border="0" bgcolor="#E0E0E0" width="100%">
              <tr>
                <td>
                  <pre class="PROGRAMLISTING">
-d  enable debugging
-v  enable verbose NTLM packet debugging.
-A  specify a Windows Local Group name allowed to authenticate
-D  specify a Windows Local Group name not allowed to authenticate
-h  this message
    
</pre>
                </td>
              </tr>
            </table>

            <p>Le opzioni <em>-d</em> e <em>-v</em> consentono una
            diagnostica abbastanza chiara e precisa di eventuali problemi.
            Le opzioni <em>-A</em> e <em>-D</em> consentono di specificare
            un gruppo Windows LOCALE autorizzato o non autorizzato alla
            navigazione, si raccomanda l&#39;utilizzo di <a href=
            "#SEC-EXTERNAL-ACL">ACL esterne</a> per ottenere una maggiore
            flessibilit&agrave;.</p>
          </div>
        </div>

        <div class="SECT2">
          <hr />

          <h3 class="SECT2"><a name="SEC-AUTENTICAZIONE-CON-SAMBA-2.2.X"
          id="SEC-AUTENTICAZIONE-CON-SAMBA-2.2.X"></a>11.5.3.
          Autenticazione NTLM con Samba 2.2.x</h3>

          <p>Vedremo di seguito come utilizzare il servizio
          <em>Winbindd</em> di Samba versione 2.2.x come supporto per
          l&#39;autenticazione NTLM di Squid 2.5.</p>

          <div class="SECT3">
            <hr />

            <h4 class="SECT3"><a name="SEC-COMPILAZIONE-HELPERS" id=
            "SEC-COMPILAZIONE-HELPERS"></a>11.5.3.1. Compilazione
            helpers</h4>

            <p>Per utilizzare gli helpers basati su <em>Winbindd</em>
            &egrave; necessario avere <em>installato e correttamente
            configurato</em> Samba 2.2.4 o seguenti, Squid-2.5 utilizza
            un&#39;interfaccia interna di Samba per la comunicazione con
            <em>Winbindd</em>, per questo motivo il suo funzionamento
            pu&ograve; essere influenzato da modifiche a tale interfaccia
            da parte del team di sviluppo di Samba. Squid-2.5.STABLE2
            supporta Samba 2.2.6 e Samba 2.2.7a e forse anche le versioni
            seguenti. Per utilizzare le versioni precedenti di Samba
            &egrave; necessario utilizzare la nuova opzione di
            compilazione</p>

            <table border="0" bgcolor="#E0E0E0" width="100%">
              <tr>
                <td>
                  <pre class="PROGRAMLISTING">
--with-samba-sources=path<em> </em>
    
</pre>
                </td>
              </tr>
            </table>

            <p>questa opzione &egrave; necessaria per indicare il percorso
            contenente i sorgenti di Samba, ad esempio</p>

            <table border="0" bgcolor="#E0E0E0" width="100%">
              <tr>
                <td>
                  <pre class="PROGRAMLISTING">
--with-samba-sources=/usr/src/samba-2.2.8
    
</pre>
                </td>
              </tr>
            </table>

            <p>l&#39;utilizzo di tale opzione potrebbe anche rendersi
            necessario per le future versioni di Samba o in caso di
            applicazione di patch ai suoi sorgenti. Squid-2.5.STABLE1
            supporta Samba 2.2.4 e Samba 2.2.5, per le versioni di Samba a
            partire dalla 2.2.6 e seguenti &egrave; necessario sostituire,
            prima della compilazione di Squid, gli include
            <em>winbind_nss.h</em> e <em>winbindd_nss_config.h</em>
            presenti nel source tree di Squid con quelli del source tree di
            Samba.</p>
          </div>

          <div class="SECT3">
            <hr />

            <h4 class="SECT3"><a name="SEC-CONFIGURAZIONE-DI-SAMBA2" id=
            "SEC-CONFIGURAZIONE-DI-SAMBA2"></a>11.5.3.2. Configurazione di
            Samba2</h4>

            <p>Come detto precedentemente, per utilizzare
            l&#39;autenticazione <em>Winbindd</em> &egrave; necessario
            installare Samba, versione 2.2.4 o seguenti, e configuralo in
            modo opportuno. Alcune linee guida per una corretta
            installazione possono essere le seguenti. In fase di
            compilazione, eseguendo il <em>configure</em> di Samba,
            inserire le seguenti opzioni:</p>

            <table border="0" bgcolor="#E0E0E0" width="100%">
              <tr>
                <td>
                  <pre class="PROGRAMLISTING">
--with-winbind --with-winbind-auth-challenge 
    
</pre>
                </td>
              </tr>
            </table>

            <p>nella grande maggioranza delle distribuzioni GNU Linux, la
            versione binaria di Samba che viene fornita &eacute; compilata
            senza l&#39;opzione <em>--with-winbind-auth-challenge</em>, si
            raccomanda quindi la ricompilazione ad hoc per la propria
            installazione e si consiglia anche di non utilizzare la
            versione fornita a corredo della propria distribuzione.</p>

            <p>Dopo avere compilato il demone, dovremo integrare il file
            <em>smb.conf</em> le seguenti direttive (<em>si prega di
            confrontare la documentazione di samba</em> per maggiori
            informazioni)</p>

            <table border="0" bgcolor="#E0E0E0" width="100%">
              <tr>
                <td>
                  <pre class="PROGRAMLISTING">
;******************* section global ***************** 
[global] 
password server = * 
wins server = 192.168.5.1 192.168.0.1 
security = domain
encrypt passwords = Yes 
workgroup = DOMINIO 
;******************* winbindd *********************** 
winbind separator = \ template 
homedir = /home/%D/%U template 
shell = /bin/bash 
winbind uid = 10000-20000 
winbind gid = 10000-20000 
winbind enum users = yes 
winbind enum groups = yes 
    
</pre>
                </td>
              </tr>
            </table>

            <p>sar&agrave; quindi necessario inserire il server Samba nel
            dominio come &quot;member&quot; con il comando
            <em>smbpasswd</em>(8)</p>

            <table border="0" bgcolor="#E0E0E0" width="100%">
              <tr>
                <td>
                  <pre class="PROGRAMLISTING">
smbpasswd -j DOM -r DOMPDC -UAdministrator%password
    
</pre>
                </td>
              </tr>
            </table>

            <p>l&#39;opzione <em>-j</em> viene utilizzata per aggiungere il
            server <em>samba</em> nel dominio NT quale membro del dominio,
            il valore <em>DOM</em> &egrave; il nome del dominio al quale si
            vuole aggiugere la macchina <em>samba</em>. Grazie a questa
            opzione, il nostro server <em>samba</em> sar&agrave; in grado
            di eseguire l&#39;autenticazione degli utenti verso uno
            qualsiasi dei domain controller cos&igrave; come potrebbe
            operare uno qualsiasi dei server Windows NT, 2000 e 2003.
            L&#39;opzione <em>-r</em> invece, indica il nome della macchina
            remota ovvero il nome netbios del server SMB/CIFS da contattare
            per inserire il nostro server <em>samba</em> nel dominio. Il
            valore <em>DOMPDC</em> equivale quindi al nome netbios del
            domain controller. Assicurarsi che i demoni Samba (<a href=
            "http://www.samba.org/" target=
            "_top">http://www.samba.org/</a>) <em>smbd</em>, <em>nmbd</em>
            e <em>winbindd</em> siano stati avviati automaticamente con il
            boot del sistema, prima dell&#39;avvio di Squid. Maggiori
            dettagli sul comando <em>smbpasswd</em>(8) possono essere
            reperiti alla URLs <a href=
            "http://us1.samba.org/samba/ftp/docs/htmldocs/smbpasswd.8.html"
            target=
            "_top">http://us1.samba.org/samba/ftp/docs/htmldocs/smbpasswd.8.html</a>.</p>

            <p>Se Samba viene utilizzato sulla macchina solamente per il
            supporto <em>winbindd</em>, a partire dalla versione 2.2.6 di
            Samba &eacute; anche possibile non eseguire il demone
            <em>smbd.</em> &Eacute; per&ograve; INDISPENSABILE eseguire un
            rinnovo periodico della relazione di trust tra la macchina
            Samba ed il dominio Windows. Per fare ci&ograve;, nel caso in
            cui non si esegua <em>smbd</em>, &eacute; sufficiente
            schedulare il seguente comando una volta al giorno</p>

            <table border="0" bgcolor="#E0E0E0" width="100%">
              <tr>
                <td>
                  <pre class="PROGRAMLISTING">
smbpasswd -t DOM -r DOMPDC
    
</pre>
                </td>
              </tr>
            </table>

            <p>ecco una entry da inserire nella tabella di
            <em>crontab</em>(8)</p>

            <table border="0" bgcolor="#E0E0E0" width="100%">
              <tr>
                <td>
                  <pre class="PROGRAMLISTING">
02 4 * * * root /usr/bin/smbpasswd -t DOM -r DOMPDC
    
</pre>
                </td>
              </tr>
            </table>

            <p>questa linea inserita nella tabella di <em>crontab</em> ci
            consentira di eseguire il comando <em>smbpasswd</em>(8) una
            volta al giorno e rinnovare la relazione di trust tra la
            macchina UNIX&reg; e il server Windows NT/2000, dove
            <em>DOM</em> &egrave; il nome di dominio e <em>DOMPDC</em>
            &egrave; il nome netbios del Domain Controller.</p>
          </div>

          <div class="SECT3">
            <hr />

            <h4 class="SECT3"><a name="SEC-WINBIND" id=
            "SEC-WINBIND"></a>11.5.3.3. helper wb_ntlmauth</h4>

            <p>L&#39;helper <em>wb_ntlmauth</em> consente la validazione
            trasparente degli utenti su di un dominio Windows NT 4 o
            Windows 2000 Active Directory. Per il suo corretto
            funzionamento necessita che Samba 2.2.4 o seguenti siano
            installati sul sistema. Di seguito vediamo un esempio di
            configurazione:</p>

            <table border="0" bgcolor="#E0E0E0" width="100%">
              <tr>
                <td>
                  <pre class="PROGRAMLISTING">
auth_param ntlm program /usr/squid/libexec/wb_ntlmauth [domain]
auth_param ntlm children 5 
auth_param ntlm max_challenge_reuses 0 
auth_param ntlm max_challenge_lifetime 15 minutes
auth_param ntlm use_ntlm_negotiate off
    
</pre>
                </td>
              </tr>
            </table>

            <p>In questo caso <em>wb_ntlmauth</em> si trova in
            <em>/usr/local/squid/libexec</em>, il numero di helper in
            esecuzione &eacute; 5, i challenge non possono essere
            riutilizzati ed il loro TTL &eacute; pari a 15 minuti. &Egrave;
            possibile specificare il dominio predefinito per
            l&#39;autenticazione sulla riga comandi dell&#39;helper.</p>

            <p>Naturalmente almeno un domain controller del dominio deve
            essere raggiungibile, si consiglia di verificare il corretto
            funzionamento della risoluzione dei nomi di rete Microsoft
            (WINS, LMHOSTS o hosts).</p>

            <p>L&#39;helper <em>wb_ntlmauth</em> &eacute; utilizzabile
            solamente sulle piattaforme supportate da Squid per cui
            &eacute; disponibile anche Samba 2.2.4 o seguenti, e NON
            supporta i pacchetti NTLM NEGOTIATE. In merito all&#39;utilizzo
            di Samba si rammenta al lettore che devono essere in esecuzione
            almeno i demoni <em>winbindd</em> e <em>nmbd</em>. Per questo
            helper sono disponibili le seguenti opzioni</p>

            <table border="0" bgcolor="#E0E0E0" width="100%">
              <tr>
                <td>
                  <pre class="PROGRAMLISTING">
-d enable debugging
-h this message
    
</pre>
                </td>
              </tr>
            </table>

            <p>L&#39;opzione <em>-d</em> consente una diagnostica
            abbastanza chiara e precisa dei problemi. Per controllare il
            funzionamento di <em>winbindd</em>, &eacute; possibile
            utilizzare il tool <em>wbinfo</em> fornito con Samba.
            <em>wb_ntlmauth</em> non funziona con Samba 3.x, riferirsi alla
            sezione su <a href="#SEC-AUTENTICAZIONE-CON-SAMBA-3.X">Samba
            3</a> per maggiori dettagli.</p>
          </div>
        </div>

        <div class="SECT2">
          <hr />

          <h3 class="SECT2"><a name="SEC-AUTENTICAZIONE-CON-SAMBA-3.X" id=
          "SEC-AUTENTICAZIONE-CON-SAMBA-3.X"></a>11.5.4. Autenticazione
          NTLM con Samba3</h3>

          <p>Gli helpers basati su winbindd 2.2.x soffrono di un problema
          di compatibilit&agrave; tra le varie versioni di <em>samba</em>,
          in quanto l&#39;interfaccia software di <em>winbindd</em> non
          &eacute; mai stata standardizzata dal gruppo di sviluppo di
          Samba. Per ovviare a questo problema, si &eacute; instaurata una
          collaborazione tra i gruppi di sviluppo di samba e di Squid, che
          ha portato alla realizzazione di un autenticatore NTLM per Squid,
          <em>ntlm_auth</em>, basato sulle caratteristiche di winbindd 3
          che viene incluso direttamente nel package Samba3. Gli
          autenticatori <em>wb_ntlmauth, wb_auth</em> e <em>wb_group</em>
          basati su winbindd 2.2 inclusi in Squid non funzionano con
          <em>Samba 3</em></p>

          <div class="SECT3">
            <hr />

            <h4 class="SECT3"><a name="SEC-SAMBA3-NTLM-AUTH" id=
            "SEC-SAMBA3-NTLM-AUTH"></a>11.5.4.1. helper esterno Samba 3.x
            ntlm_auth</h4>

            <p>Questo autenticatore &eacute; in grado di operare in
            modalit&aacute; <em>basic</em> e <em>ntlm</em>. Inoltre a
            partire da Samba 3.0.2 &eacute; supportato in modo totalmente
            automatico l&#39;utilizzo dei pacchetti NTLM NEGOTIATE
            (NTLMv2). Assumendo che Samba sia installato in
            <em>/usr/local/samba</em>, i parametri da utilizzare in
            <em>squid.conf</em> diventano</p>

            <table border="0" bgcolor="#E0E0E0" width="100%">
              <tr>
                <td>
                  <pre class="PROGRAMLISTING">
auth_param ntlm program /usr/local/samba/bin/ntlm_auth --helper-protocol=squid-2.5-ntlmssp
auth_param ntlm children 5
auth_param ntlm max_challenge_reuses 0
auth_param ntlm max_challenge_lifetime 15 minutes
auth_param ntlm use_ntlm_negotiate on
auth_param basic program /usr/local/samba/bin/ntlm_auth --helper-protocol=squid-2.5-basic
auth_param basic children 5
auth_param basic realm Squid proxy-caching web server
auth_param basic credentialsttl 2 hours
    
</pre>
                </td>
              </tr>
            </table>

            <p>la precedente configurazione consente di sostituire gli
            autenticatori <em>wb_auth</em> e <em>wb_ntlmauth</em>
            abilitando il supporto per i pacchetti NTLM NEGOTIATE. Come
            accadeva gi&agrave; per Samba 2, anche Samba 3 deve essere
            compilato con questa opzione di configure</p>

            <table border="0" bgcolor="#E0E0E0" width="100%">
              <tr>
                <td>
                  <pre class="PROGRAMLISTING">
--with-winbind 
    
</pre>
                </td>
              </tr>
            </table>
          </div>

          <div class="SECT3">
            <hr />

            <h4 class="SECT3"><a name="SUBSEC-INSERIRE-NEL-DOMINIO" id=
            "SUBSEC-INSERIRE-NEL-DOMINIO"></a>11.5.4.2. Inserire nel
            dominio la macchina Samba 3.0</h4>

            <p>Dopo l&#39;installazione di <em>Samba 3</em>, &eacute;
            necessario inserire la macchina in un dominio Windows NT 4 o
            Active Directory, la procedura da utilizzare varia a seconda
            del tipo di dominio.</p>

            <ul>
              <li>
                <p>Dominio Windows NT 4</p>

                <p>La configurazione da utilizzare in <em>smb.conf</em>
                &eacute; identica a quella utilizzata con <a href=
                "#SEC-CONFIGURAZIONE-DI-SAMBA2">Samba 2</a>, con la
                differenza che le funzionalit&agrave; del comando
                <em>smbpasswd</em> sono state incluse nel comando
                <em>net</em>(8) di Samba 3 (<a href=
                "http://www.samba.org/samba/docs/man/net.8.html" target=
                "_top">http://www.samba.org/samba/docs/man/net.8.html</a>).
                L&#39;utility <em>net</em> inclusa con Samba 3 lavora in
                maniera simile al comando <em>net</em> del DOS<a name=
                "AEN3482" href="#FTN.AEN3482" id="AEN3482">[21]</a> e di
                Windows. Il comando per inserire la macchina samba in
                dominio Windows NT diventa quindi</p>

                <table border="0" bgcolor="#E0E0E0" width="90%">
                  <tr>
                    <td>
                      <pre class="PROGRAMLISTING">
net join -S DOMPDC -UAdministrator%password
     
</pre>
                    </td>
                  </tr>
                </table>

                <p>con l&#39;opzione <em>-S</em> si indica il nome netbios
                del server di destinazione o il relativo indirizzo IP,
                nell&#39;esempio <em>DOMPDC</em> &egrave; il nome netbios
                del domain controller</p>
              </li>

              <li>
                <p>Dominio Active Directory (Samba 3 deve essere compilato
                con support Kerberos)</p>

                <p>Inserire nel file <em>smb.conf</em> le seguenti
                direttive:</p>

                <table border="0" bgcolor="#E0E0E0" width="90%">
                  <tr>
                    <td>
                      <pre class="PROGRAMLISTING">
realm = your.kerberos.REALM
security = ADS
encrypt passwords = yes
     
</pre>
                    </td>
                  </tr>
                </table>

                <p>nel caso in cui Samba non riesca ad identificare il
                server ADS tramite il REALM</p>

                <table border="0" bgcolor="#E0E0E0" width="90%">
                  <tr>
                    <td>
                      <pre class="PROGRAMLISTING">
password server = your.kerberos.server
     
</pre>
                    </td>
                  </tr>
                </table>

                <p>inserire la macchina Samba 3 in dominio con il comando
                <em>net</em>(8)</p>

                <table border="0" bgcolor="#E0E0E0" width="90%">
                  <tr>
                    <td>
                      <pre class="PROGRAMLISTING">
net ads join -U Administrator%password
     
</pre>
                    </td>
                  </tr>
                </table>

                <p>l&#39;opzione <em>ads</em> viene utilizzata per
                identificare le ActiveDirectory, l&#39;opzione <em>rap</em>
                viene invece utilizzata per le macchine NT3 oppure
                Windows9x, per finire l&#39;opzione <em>rpc</em> pu&ograve;
                essere utilizzata per le macchine NT4 o Windows 2000, se
                l&#39;argomento viene omesso il comando <em>net</em>(8)
                tenter&agrave; di determinare automaticamente il tipo di
                sistema.</p>
              </li>
            </ul>

            <p>Si raccomanda di riferirsi alla documentazione della
            versione di <em>Samba 3</em> utilizzata per verificare la
            corretta procedura da seguire in funzione
            dell&#39;implementazione Kerberos utilizzata sul sistema.
            Infine, per consentire agli helper <em>Samba 3</em> di lavorare
            correttamente con Squid &egrave; necessario fare in modo che il
            gruppo specificato nella direttiva
            <em>cache_effective_group</em> di <em>squid.conf</em> abbia i
            permessi di lettura sulla directory
            <em>winbindd_privileged</em> in cui si trova la pipe di
            winbindd, quindi nel caso in cui il gruppo utilizzato da squid
            sia ad esempio <em>nogroup</em>:</p>

            <table border="0" bgcolor="#E0E0E0" width="100%">
              <tr>
                <td>
                  <pre class="PROGRAMLISTING">
chgrp nogroup /dove/sta/samba/winbindd_privileged
chmod 750 /dove/sta/samba/winbindd_privileged
    
</pre>
                </td>
              </tr>
            </table>

            <p>Il risultato di un <em>ls -la
            /dove/sta/samba/winbindd_pipe/pipe</em> dovrebbe essere:</p>

            <table border="0" bgcolor="#E0E0E0" width="100%">
              <tr>
                <td>
                  <pre class="PROGRAMLISTING">
srwxrwxrwx 1 root root 0 Aug 14 22:50 pipe
    
</pre>
                </td>
              </tr>
            </table>

            <p>anche con <em>Samba 3</em>, se viene utilizzato sulla
            macchina solamente il supporto <em>winbindd</em> &eacute;
            possibile non eseguire il demone <em>smbd.</em> Anche in questo
            caso &eacute; per&ograve; INDISPENSABILE eseguire un rinnovo
            periodico della relazione di trust tra la macchina Samba ed il
            dominio Windows. Per fare ci&ograve;, nel caso in cui non si
            esegua <em>smbd</em>, &eacute; sufficiente schedulare il
            seguente comando una volta al giorno</p>

            <table border="0" bgcolor="#E0E0E0" width="100%">
              <tr>
                <td>
                  <pre class="PROGRAMLISTING">
net rpc changetrustpw
    
</pre>
                </td>
              </tr>
            </table>

            <p>le possibilit&agrave; sono [<em>rpc</em>|<em>ads</em>]
            CHANGETRUSTPW per forzare il rinnovo della relazione di trust,
            ecco una entry da inserire nella tabella di
            <em>crontab</em>(8)</p>

            <table border="0" bgcolor="#E0E0E0" width="100%">
              <tr>
                <td>
                  <pre class="PROGRAMLISTING">
02 4 * * * root /usr/bin/net rpc changetrustpw
    
</pre>
                </td>
              </tr>
            </table>

            <p>questa linea inserita nella tabella di <em>crontab</em> ci
            consentira di eseguire il comando <em>net</em>(8) una volta al
            giorno e rinnovare la relazione di trust tra la macchina
            UNIX&reg; e il server Windows NT4/2000.</p>
          </div>
        </div>

        <div class="SECT2">
          <hr />

          <h3 class="SECT2"><a name="SEC-PROB-COMUNI-CON-NTLM" id=
          "SEC-PROB-COMUNI-CON-NTLM"></a>11.5.5. Problemi comuni con
          NTLM</h3>

          <p>La modalit&agrave; di funzionamento connection oriented
          propria di <em>NTLM</em>, il fatto che non tutti gli user agent
          supportino il sistema di autenticazione <em>NTLM</em>,
          nonch&egrave; particolari configurazioni relative al dominio
          Windows di appartenenza, possono provocare dei problemi di
          utilizzo anche piuttosto fastidiosi in presenza
          dell&#39;autenticazione <em>NTLM</em>. Vediamo ora alcuni dei
          problemi pi&ugrave; comuni che possono presentarsi con
          <em>NTLM</em>.</p>

          <div class="SECT3">
            <hr />

            <h4 class="SECT3"><a name="SUBSEC-JAVA-RUNTIME" id=
            "SUBSEC-JAVA-RUNTIME"></a>11.5.5.1. Java runtime</h4>

            <p>Navigando su siti che utilizzano applet Java, il JRE
            richiede di continuo l&#39;autenticazione all&#39;utente.
            Ci&ograve; accade perch&eacute; il browser non &eacute; in
            grado di condividere l&#39;autenticazione della connessione con
            la Java Virtual Machine</p>

            <ul>
              <li>
                <p>soluzione: <em>consentire nelle ACL il traffico Java non
                autenticato</em></p>
              </li>
            </ul>

            <table border="0" bgcolor="#E0E0E0" width="100%">
              <tr>
                <td>
                  <pre class="PROGRAMLISTING">
acl java_jvm browser Java/1.4
http_access allow java_jvm
    
</pre>
                </td>
              </tr>
            </table>
          </div>

          <div class="SECT3">
            <hr />

            <h4 class="SECT3"><a name="SUBSEC-FTP" id=
            "SUBSEC-FTP"></a>11.5.5.2. ftp</h4>

            <p>Navigando su siti ftp con URL del tipo
            <em>ftp://ftp.miosito.com</em>, a volte pu&ograve; succedere
            che il browser richieda l&#39;autenticazione per accedere agli
            oggetti icona FTP di Squid. Questo &eacute; dovuto ad un
            problema nel riconoscimento dei siti Internet/Intranet da parte
            di alcune versioni recenti di Internet Explorer</p>

            <ul>
              <li>
                <p>soluzione: <em>consentire nelle ACL l&#39;accesso non
                autenticato agli oggetti interni di Squid</em></p>
              </li>
            </ul>

            <table border="0" bgcolor="#E0E0E0" width="100%">
              <tr>
                <td>
                  <pre class="PROGRAMLISTING">
acl internal_icons urlpath_regex -i /squid-internal-static/icons/
http_access allow internal_icons
    
</pre>
                </td>
              </tr>
            </table>
          </div>

          <div class="SECT3">
            <hr />

            <h4 class="SECT3"><a name="SUBSEC-WINDOWS-2003" id=
            "SUBSEC-WINDOWS-2003"></a>11.5.5.3. Windows 2003</h4>

            <p>&Eacute; impossibile navigare utilizzando una macchina
            Windows 2003. Ci&ograve; accade in quanto in Windows 2003
            l&#39;utilizzo del protocollo LM/NTLM &eacute; disabilitato per
            default e le versione di Squid precedenti la 2.5.STABLE5 non
            supportano la funzione di NTLM NEGOTIATE</p>

            <ul>
              <li>
                <p>soluzione: <em>utilizzare</em> squid 2.5.STABLE5
                <em>con</em> ntlm_auth <em>di Samba 3.0.2 o seguenti
                abilitando il supporto NTLM NEGOTIATE</em></p>
              </li>

              <li>
                <p>soluzione: <em>attivare il supporto LM/NTLM in Windows
                2003</em></p>
              </li>
            </ul>

            <p>per abilitare il supporto LM/NTLM in Windows 2003 server
            &egrave; necessario aprire il tool <em>&quot;Machine Local
            Security Policy</em>&quot;, nelle opzioni di sicurezza,
            modificare la voce &quot;<em>Network Security: LAN Manager
            Authentication Level</em>&quot; da &quot;<em>Send NTLM response
            only</em>&quot; a &quot;<em>Send LM &amp; NTLM
            responses</em>&quot;.</p>
          </div>

          <div class="SECT3">
            <hr />

            <h4 class="SECT3"><a name="SUBSEC-UTENTI-NON-AUTENTICATI" id=
            "SUBSEC-UTENTI-NON-AUTENTICATI"></a>11.5.5.4. Utenti non
            autenticati</h4>

            <p>Utilizzando NTLM pu&ograve; accadere che alcuni utenti non
            vengano autenticati in modo sistematico, e Samba restituisce
            l&#39;errore NT_STATUS_INVALID_WORKSTATION. Questo avviene
            perch&eacute; l&#39;utente &eacute; autorizzato a fare la logon
            su un numero ristretto di workstation, ma non sul Proxy
            Server.</p>

            <ul>
              <li>
                <p>soluzione: <em>aggiungere il Proxy Server all&#39;elenco
                delle macchine autorizzate nelle propriet&agrave;
                dell&#39;utente Windows</em></p>
              </li>

              <li>
                <p>soluzione: <em>utilizzare</em> squid.2.5-STABLE5
                <em>con</em> ntlm_auth <em>di Samba 3.0.2 abilitando il
                supporto NTLM NEGOTIATE</em></p>
              </li>
            </ul>
          </div>
        </div>
      </div>

      <div class="SECT1">
        <hr />

        <h2 class="SECT1"><a name="SEC-DIGEST-AUTHENTICATION" id=
        "SEC-DIGEST-AUTHENTICATION"></a>11.6. Digest Authentication</h2>

        <p>l&#39;Autenticazione <a href=
        "#SUBSEC-DIGEST-AUTHENTICATION">Digest</a> funziona
        <em>esclusivamente con la versione 2.5</em> di Squid</p>

        <div class="SECT2">
          <hr />

          <h3 class="SECT2"><a name="SEC-CONFIGURAZIONE-DIGEST" id=
          "SEC-CONFIGURAZIONE-DIGEST"></a>11.6.1. Configurazione</h3>

          <p>Lo schema di autenticazione Digest utilizza i seguenti
          parametri</p>

          <table border="0" bgcolor="#E0E0E0" width="100%">
            <tr>
              <td>
                <pre class="PROGRAMLISTING">
auth_param digest program cmdline
auth_param digest children numberofchildren
auth_param digest realm realmstring
auth_param digest nonce_garbage_interval timeinterval
auth_param digest nonce_max_duration timeinterval
auth_param digest nonce_max_count number
auth_param digest nonce_strictness on|off
auth_param digest post_workaround on|off
   
</pre>
              </td>
            </tr>
          </table>

          <p>il TAG <em>program cmdline</em></p>

          <p>Specifica il comando che avvia il programma utenticatore
          esterno. Tale programma legge una riga da stdin contenente
          &quot;username&quot;:&quot;realm&quot; e risponde su stdout con
          un appropriato valore H(A1) codificato base64 in un loop senza
          fine. Riferirsi alla RFC 2616 (<a href=
          "http://www.faqs.org/rfcs/rfc2616.html" target=
          "_top">http://www.faqs.org/rfcs/rfc2616.html</a>) per la
          definizione di H(A1).</p>

          <p>Di default, lo schema di autenticazione Digest non viene
          attivato a meno che non sia specificato un programma
          autenticatore. Ad esempio:</p>

          <table border="0" bgcolor="#E0E0E0" width="100%">
            <tr>
              <td>
                <pre class="PROGRAMLISTING">
auth_param digest program /usr/local/squid/libexec/digest_pw_auth /usr/local/squid/etc/digpass
   
</pre>
              </td>
            </tr>
          </table>

          <p>il TAG <em>children numberofchildren</em></p>

          <p>Indica quante istanze del programma di autenticazione devono
          essere eseguite contemporaneamente. Se viene configurato un
          numero di autenticatori troppo basso, Squid potrebbe essere
          costretto ad attendere un autenticatore libero, rallentando la
          navigazione. Il valore predefinito &egrave; 5, quando
          l&#39;elaborazione di H(A1) avviene tramite rete, pu&ograve;
          essere raccomandabile aumentare questo valore.</p>

          <table border="0" bgcolor="#E0E0E0" width="100%">
            <tr>
              <td>
                <pre class="PROGRAMLISTING">
auth_param digest children 5
   
</pre>
              </td>
            </tr>
          </table>

          <p>il TAG <em>realm realmstring</em></p>

          <p>Specifica il nome realm che viene fornito ai client per lo
          schema di autenticazione Digest (Il testo che l&#39;utente
          vedr&agrave; nella dialog box di autenticazione del browser). Il
          valore predefinito &egrave; &quot;Squid proxy-caching web
          server&quot;.</p>

          <table border="0" bgcolor="#E0E0E0" width="100%">
            <tr>
              <td>
                <pre class="PROGRAMLISTING">
auth_param digest realm Squid proxy-caching web server
   
</pre>
              </td>
            </tr>
          </table>

          <p>il TAG <em>nonce_garbage_interval timeinterval</em></p>

          <p>specifica ogni quanto tempo viene verificata la
          validit&agrave; dei <em>nonce</em> assegnati ai client Il valore
          predefinito &eacute; 5 minuti.</p>

          <table border="0" bgcolor="#E0E0E0" width="100%">
            <tr>
              <td>
                <pre class="PROGRAMLISTING">
auth_param digest nonce_garbage_interval 5 minutes
   
</pre>
              </td>
            </tr>
          </table>

          <p>il TAG <em>nonce_max_duration timeinterval</em></p>

          <p>specifica la durata massima della validit&agrave; di un dato
          <em>nonce</em>. Il valore predefinito &eacute; 30 minuti.</p>

          <table border="0" bgcolor="#E0E0E0" width="100%">
            <tr>
              <td>
                <pre class="PROGRAMLISTING">
auth_param digest nonce_max_duration 30 minutes
   
</pre>
              </td>
            </tr>
          </table>

          <p>il TAG <em>nonce_max_count number</em></p>

          <p>specifica il massimo numero di volte che un dato
          <em>nonce</em> pu&ograve; essere riutilizzato. Il valore
          predefinito &eacute; 50.</p>

          <table border="0" bgcolor="#E0E0E0" width="100%">
            <tr>
              <td>
                <pre class="PROGRAMLISTING">
auth_param digest nonce_max_count 50
   
</pre>
              </td>
            </tr>
          </table>

          <p>il TAG <em>nonce_strictness on|off</em></p>

          <p>determina se Squid richiede incrementi del nonce count
          esattamente di uno o se invece accetta incrementi generici (off),
          per quei useragent che generano dei nonce count che incrementano
          casualmente di un valore superiore all&#39;unit&agrave; (Per
          esempio 1,2,4,6). Il valore predefinito &eacute; off.</p>

          <table border="0" bgcolor="#E0E0E0" width="100%">
            <tr>
              <td>
                <pre class="PROGRAMLISTING">
auth_param digest nonce_strictness off
   
</pre>
              </td>
            </tr>
          </table>

          <p>il TAG <em>check_nonce_count on|off</em></p>

          <p>disabilita totalmente il nonce count check come workaround ad
          alcune implementazioni anomale di digest qop in alcuni browser.
          Il valore predefinito &eacute; on, ovvero verificare il nonce
          count per evitare attacchi di tipo <em>authentication
          replay</em>.</p>

          <table border="0" bgcolor="#E0E0E0" width="100%">
            <tr>
              <td>
                <pre class="PROGRAMLISTING">
auth_param digest check_nonce_count on
   
</pre>
              </td>
            </tr>
          </table>

          <p>il TAG <em>post_workaround on|off</em></p>

          <p>questo &eacute; un workaround per un bug presente in alcuni
          browser che inviano una richiesta incorretta di digest durante
          un&#39;operazione di POST basata su un nonce di una precedente
          operazione di GET. Questa funzione &eacute; normalmente
          disattiva.</p>

          <table border="0" bgcolor="#E0E0E0" width="100%">
            <tr>
              <td>
                <pre class="PROGRAMLISTING">
auth_param digest post_workaround off
   
</pre>
              </td>
            </tr>
          </table>

          <div class="SECT3">
            <hr />

            <h4 class="SECT3"><a name="SEC-PASSWORD-DIGEST" id=
            "SEC-PASSWORD-DIGEST"></a>11.6.1.1. helper digest_pw_auth</h4>

            <p>&Eacute; attualmente l&#39;unico autenticatore disponibile
            per lo schema di autenticazione Digest, viene tendenzialmente
            fornito come riferimento per nuove implementazioni. Come
            back-end viene utilizzato un file il cui formato prevede linee
            del tipo <em>&quot;username:password</em>&quot;.</p>

            <ul>
              <li>
                <p>Le linee che iniziano con &#39;#&#39; sono considerate
                un commento</p>
              </li>

              <li>
                <p>&Eacute; possibile lasciare delle linee vuote</p>
              </li>
            </ul>

            <p>esempio di configurazione</p>

            <table border="0" bgcolor="#E0E0E0" width="100%">
              <tr>
                <td>
                  <pre class="PROGRAMLISTING">
auth_param digest program /usr/local/squid/libexec/digest_pw_auth /usr/local/squid/etc/digpass
auth_param digest children 10
auth_param digest realm Squid proxy-caching web server
auth_param digest nonce_garbage_interval 5 minutes
auth_param digest nonce_max_duration 30 minutes
auth_param digest nonce_max_count 25
auth_param digest check_nonce_count on
    
</pre>
                </td>
              </tr>
            </table>

            <p>In questo caso <em>digest_pw_auth</em> si trova in
            <em>/usr/local/squid/libexec</em>, il file contenente le
            password &eacute; <em>/usr/local/squid/etc/digpass</em>, il
            numero di helper in esecuzione &eacute; 10, il garbage dei
            <em>nonce</em> avviene ogni 5 minuti, la loro durata &eacute;
            di 30 minuti con 25 riutilizzi massimi ed il TTL
            dell&#39;autenticazione &eacute; pari a 30 minuti.</p>

            <p>L&#39;helper <em>digest_pw_auth</em> &eacute; utilizzabile
            su tutte le piattaforme supportate da Squid.</p>
          </div>
        </div>
      </div>
    </div>

    <div class="CHAPTER">
      <hr />

      <h1><a name="CHA-AVVIARE-SQUID" id="CHA-AVVIARE-SQUID"></a>Capitolo
      12. Avviare Squid</h1>

      <div class="SECT1">
        <h2 class="SECT1"><a name="SEC-PREAMBOLO-AVVIO" id=
        "SEC-PREAMBOLO-AVVIO"></a>12.1. Preambolo</h2>

        <p>In questo capitolo analizziamo nel dettaglio come avviare il
        Proxy Server Squid utilizzando la <em>shell</em>, inoltre terremo
        anche conto del diverso funzionamento dei vari Sistemi Operativi
        che supportano Squid.</p>

        <p>Nei sistemi UNIX&reg; &egrave; fondamentale l&#39;utente che
        esegue il processo, nel capitolo <a href=
        "#SEC-UTENTE-E-GROUPID">configurare ed installare Squid</a> abbiamo
        gi&agrave; visto che &egrave; possibile eseguire Squid utilizzando
        un utente ed un gruppo specifico. Quando il proxy server viene
        avviato, grazie ai TAG <em>cache_effective_user</em> e
        <em>cache_effective_group</em> che sono contenuti nel file
        <em>squid.conf</em>, &egrave; possibile modificare
        l&#39;identificativo UID e GID che esegue il processo Squid. Il
        cambiamento della userid e del gruppo riduce la possibilit&agrave;
        che il sistema possa essere modificato a causa di un exploit dovuto
        ad un improbabile bug di Squid. Questo cambiamento di UID e di GID
        &egrave; molto importante perch&egrave; l&#39;utente utilizzato per
        eseguire il processo Squid non &egrave; comunque abilitato ad
        ottenere i permessi amministrativi riservati all&#39;utente
        root.</p>

        <p>Le modalit&agrave; di avvio del demone Squid possono variare
        sensibilmente a secondo dell&#39;utilizzo di una versione di Squid
        compilata dai sorgenti ufficiali o di una versione di Squid fornita
        con una qualsiasi distribuzione UNIX&reg;.</p>
      </div>

      <div class="SECT1">
        <hr />

        <h2 class="SECT1"><a name="SEC-MULTIPIATTAFORMA" id=
        "SEC-MULTIPIATTAFORMA"></a>12.2. Istruzioni multipiattaforma</h2>

        <p>Al termine della compilazione e dell&#39;installazione di Squid
        &egrave; necessario verificare la sintassi del file di
        configurazione <em>squid.conf</em> avviando Squid utilizzando il
        comando <em>squid -k parse</em></p>

        <table border="0" bgcolor="#E0E0E0" width="100%">
          <tr>
            <td>
              <pre class="PROGRAMLISTING">
[root@mandrake root]# squid -k parse
  
</pre>
            </td>
          </tr>
        </table>

        <p>a questo punto &egrave; necessario creare gli oggetti che
        compongono la cache utilizzando il comando <em>squid -z</em></p>

        <table border="0" bgcolor="#E0E0E0" width="100%">
          <tr>
            <td>
              <pre class="PROGRAMLISTING">
[root@mandrake root]# squid -z
2004/01/25 15:58:06| Creating Swap Directories
  
</pre>
            </td>
          </tr>
        </table>

        <p>con questo comando genereremo il Disk Storage dedicato alla
        cache di Squid, il comando deve essere utilizzato in ogni caso
        prima di avviare il Proxy Server. Se eseguendo il comando <em>squid
        -z</em> si dovesse ottenere un messaggio di errore del tipo
        <em>permission denied</em>, sar&agrave; necessario controllare che
        nel file <em>squid.conf</em> siano stati correttamente abilitati i
        TAG <em><a href=
        "#SEC-UTENTE-E-GROUPID">cache_effective_user</a></em> e
        <em><a href="#SEC-UTENTE-E-GROUPID">cache_effective_group</a></em>.
        Inoltre si verificheranno i permessi assegnati alla directory di
        cache che abbiamo definito con il TAG <em><a href=
        "#SEC-OPZIONI-FILES-LOG">cache_dir</a></em>, ovviamente i permessi
        dovranno essere GID e UID dell&#39;utente definito dal TAG
        <em>cache_effective_user</em> e <em>cache_effective_group</em>.</p>

        <p>Solo dopo aver creato le directory dedicate al Disk Storage
        consigliamo di eseguire Squid in modalit&agrave; debugging per
        capire se tutto stia funzionando correttamente. A questo punto
        avviamo Squid utilizzando l&#39;istruzione <em>squid</em> <em>-N -d
        1 -D</em>, questo comando inizializza Squid senza farlo divenire un
        demone di background</p>

        <table border="0" bgcolor="#E0E0E0" width="100%">
          <tr>
            <td>
              <pre class="PROGRAMLISTING">
root@ns:/root&gt; squid -N -d 1 -D
2004/03/06 12:02:35| Starting Squid Cache version 2.5.STABLE4 for i386-portbld-freebsd4.9...
2004/03/06 12:02:35| Process ID 68005
2004/03/06 12:02:35| With 3584 file descriptors available
2004/03/06 12:02:35| DNS Socket created at 0.0.0.0, port 1718, FD 4
  
</pre>
            </td>
          </tr>
        </table>

        <p>digitando la sequenza di tasti [<em>Ctrl+Z</em>] potremo
        bloccare il processo Squid. Nel caso in cui si dovessero presentare
        ulteriori problemi con l&#39;avviamento di Squid, sar&agrave;
        necessario verificare i permessi definiti per le directory
        identificate dal TAG che imposta lo spazio disco per i file di
        <a href="#SEC-OPZIONI-FILES-LOG">cache</a>
        (<em>cache_access_log</em>, <em>cache_log</em>,
        <em>cache_store_log</em>). Dopo aver risolto tutti i problemi
        legati ai permessi di accesso sui files, potremmo finalmente
        avviare ed utilizzare il proxy server</p>

        <table border="0" bgcolor="#E0E0E0" width="100%">
          <tr>
            <td>
              <pre class="PROGRAMLISTING">
[root@mandrake root]# squid 
  
</pre>
            </td>
          </tr>
        </table>

        <p>questo il comando che consentir&agrave; di avviare il proxy
        server in condizioni di lavoro generiche.</p>
      </div>

      <div class="SECT1">
        <hr />

        <h2 class="SECT1"><a name="SEC-AVVIARE-SQUID-AUTOMATICAMENTE" id=
        "SEC-AVVIARE-SQUID-AUTOMATICAMENTE"></a>12.3. Avviare Squid
        automaticamente con il boot del sistema</h2>

        <p>Il processo di avviamento di un computer, qualunque sia il tipo
        di architettura adottato, prende il nome di processo di boot (cfr.
        <a href="http://info.astrian.net/jargon/terms/b.html#boot" target=
        "_top">Jargon</a> file), durante questo processo viene caricato ed
        eseguito nella memoria del computer il Kernel del Sistema Operativo
        che consente di configurare e inizializzare i vari dispositivi
        hardware creando tutti processi di Sistema. Prima che il Sistema
        Operativo stesso venga avviato completamente, si devono anche
        verificare una serie di eventi molto importanti, tra questi
        possiamo senzadubbio citare il processo di mount dei file system ed
        il contestuale avviamento dei demoni o servizi di sistema. Tutti
        questi eventi vengono eseguiti da una serie di script che prendono
        il nome di script di <em>init</em> del Sistema Operativo e
        compongono il processo di <em>init</em> di Sistema. I sistemi
        UNIX&reg; prevedono diversi sistemi di script di avvio</p>

        <ul>
          <li>
            <p>script di avvio in stile <em>System V</em></p>

            <p>il sistema di <em>init</em> di System V prevede ben sette
            livelli di esecuzione o <em>run level</em>, ogni <em>run
            level</em> rappresenta un particolare insieme di servizi</p>

            <ul>
              <li>
                <p>livello 0 &egrave; il sistema in shutdown</p>
              </li>

              <li>
                <p>livello 1 &egrave; la modalit&agrave; monoutente</p>
              </li>

              <li>
                <p>i livelli dal 2 al 5 invece definiscono i diversi strati
                di multiutenza</p>
              </li>

              <li>
                <p>livello 6 &egrave; il livello di riavvio (reboot) del
                sistema</p>
              </li>
            </ul>

            <p>il file <em>/etc/inittab</em> comunica al processo di
            <em>init</em> quale <em>run level</em> si debba inizializzare
            all&#39;avviamento del Sistema Operativo, le copie originali
            degli script di <em>init</em> risiedono in una directory
            speciale chiamata <em>init.d</em>, questa directory &egrave;
            solitamente situata in <em>/etc</em>, ogni script &egrave;
            responsabile di un servizio specifico ed ogni script riconosce
            gli argomenti <em>start</em> e <em>stop</em>. Nel momento in
            cui <em>init</em> cerca di avviare un run level, inizia a
            ricercare gli script di avviamento nelle directory
            <em>rc[0-6].d</em> dove <em>0-6</em> &egrave; lo specifico
            livello run level. Le directory <em>rc[0-6].d</em> contengono
            dei link simbolici che puntano agli script di <em>init</em>
            veri e propri, il nome di questi link simbolici inizia sempre
            con le lettere <em>S</em> o <em>K</em> che sono sempre seguite
            da un numero o dal nome dello script che controlla il tipo di
            servizio.</p>
          </li>

          <li>
            <p>script di init in stile <em>BSD</em></p>

            <p>FreeBSD come molti altri sistemi BSD, esegue un solo script
            all&#39;avviamento del sistema, in particolare legge il file
            <em>/etc/rc</em> che a sua volta richiama altri tre scripts. Si
            tratta dei files <em>/etc/defaults/rc.conf</em>,
            <em>/etc/rc.conf</em> e <em>/etc/rc.conf.local</em></p>

            <ul>
              <li>
                <p><em>/etc/defaults/rc.conf</em></p>
              </li>
            </ul>

            <p>&egrave; il file che elenca tutti i parametri di
            configurazione di FreeBSD, notoriamente e per ragioni di
            sicurezza non avvia alcun servizio</p>

            <ul>
              <li>
                <p><em>/etc/rc.conf</em></p>
              </li>
            </ul>

            <p>sovrascrive i parametri di configurazione del file
            <em>/etc/defaults/rc.conf</em>, effettivamente &egrave; questo
            il file che definisce se avviare o meno i servizi di
            sistema</p>

            <ul>
              <li>
                <p><em>/etc/rc.conf.local</em></p>
              </li>
            </ul>

            <p>riguarda principalmente le configurazioni locali, anche
            questo script si occupa di sovrascrivere i parametri di
            configurazione del file <em>/etc/defaults/rc.conf</em></p>
          </li>
        </ul>

        <p>Tutti i sistemi UNIX&reg; prevedono almeno due tipi di
        avviamento</p>

        <ul>
          <li>
            <p>l&#39;avviamento automatico (multiutenza)</p>

            <p>che prevede l&#39;avviamento ed il caricamento del Kernel di
            sistema, individua e configura l&#39;hardware, crea i processi
            di sistema, esegue gli script di avviamento (init) e procede
            con l&#39;avviamento in multiutenza</p>
          </li>

          <li>
            <p>l&#39;avviamento manuale (single user mode)</p>

            <p>che prevede l&#39;avviamento ed il caricamento del Kernel di
            sistema, individia e configura l&#39;hardware, crea i processi
            di sistema e cede il controllo del Sistema all&#39;utente</p>
          </li>
        </ul>

        <p>Nei sistemi UNIX&reg; &egrave; quindi possibile avviare Squid
        automaticamente con la partenza del Sistema Operativo utilizzando
        uno script <a href="contrib/squid" target="_top">generico</a> del
        tipo <em>init.d</em>. Il file che abbiamo inserito nello spazio
        <em>contrib</em> dovrebbe essere compatibile con la maggior parte
        dei sistemi UNIX&reg; che utilizzano lo schema di avviamento
        <em>init.d</em>.</p>

        <div class="SECT2">
          <hr />

          <h3 class="SECT2"><a name="SUB-SEC-AVVIARE-SQUID-INITTAB" id=
          "SUB-SEC-AVVIARE-SQUID-INITTAB"></a>12.3.1. Avviare Squid
          utilizzando la tabella di <em>inittab</em></h3>

          <p>Molti sistemi UNIX&reg; come Digital Unix, Solaris, IRIX,
          HP-UX ed alcune distribuzioni GNU Linux, prevedono la presenza
          del file <em>/etc/inittab</em>. In questo file possiamo inserire
          alcune linee per consentire l&#39;avvio automatico con di Squid
          con il Sistema Operativo</p>

          <table border="0" bgcolor="#E0E0E0" width="100%">
            <tr>
              <td>
                <pre class="PROGRAMLISTING">
sq:3:respawn:/usr/local/squid/sbin/squid.sh &lt; /dev/null &gt;&gt; /tmp/squid.log 2&gt;&amp;1
   
</pre>
              </td>
            </tr>
          </table>

          <p>questa linea richiama uno script di shell <em>squid.sh</em>
          con il quale &egrave; possibile avviare Squid, di seguito
          mostriamo uno script <em>squid.sh</em> molto semplice</p>

          <table border="0" bgcolor="#E0E0E0" width="100%">
            <tr>
              <td>
                <pre class="PROGRAMLISTING">
#!/bin/sh
C=/usr/local/squid
PATH=/usr/bin:/bin:$C/sbin
export PATH
# User to notify on restarts
notify=&quot;root&quot;
# Squid command line options
opts=&quot;-D&quot;
cd $C
umask 022
sleep 5
while [ -f /var/run/nosquid ]; do
sleep 1
done
/usr/bin/tail -20 $C/var/logs/cache.log \
| Mail -s &quot;Squid riavviato su `hostname` in `date`&quot; $notify
exec sbin/squid $opts
   
</pre>
              </td>
            </tr>
          </table>

          <p>questo script &egrave; stato testato per avviare una versione
          compilata utilizzando i codici sorgenti di Squid su piattaforma
          GNU Linux.</p>
        </div>

        <div class="SECT2">
          <hr />

          <h3 class="SECT2"><a name="SUBSEC-AVVIARE-UTILIZZANDO-RCLOCAL"
          id="SUBSEC-AVVIARE-UTILIZZANDO-RCLOCAL"></a>12.3.2. Avviare Squid
          utilizzando il file <em>rc.local</em></h3>

          <p>Nei sistemi ispirati a BSD &egrave; possibile avviare
          automaticamente Squid utilizzando i files
          &quot;<em>rc</em>&quot;, generalmente il file in questione
          &egrave; <em>/etc/rc.local</em> oppure
          <em>/etc/rc.d/rc.local</em> per le distribuzioni RedHat Linux,
          Fedora e Mandrake. Le istruzioni da inserire nel file possono
          essere le seguenti</p>

          <table border="0" bgcolor="#E0E0E0" width="100%">
            <tr>
              <td>
                <pre class="PROGRAMLISTING">
if [ -f /usr/local/squid/sbin/squid ]; then
echo -n &#39; Squid avviato&#39;
/usr/local/squid/sbin/squid
fi
   
</pre>
              </td>
            </tr>
          </table>

          <p>Per verificare se Squid &egrave; in ascolto utilizziamo
          <em>squidclient</em></p>

          <table border="0" bgcolor="#E0E0E0" width="100%">
            <tr>
              <td>
                <pre class="PROGRAMLISTING">
[root@portatilo root]# /usr/local/squid/bin/squidclient http://www.cisco.com/ &gt; test
   
</pre>
              </td>
            </tr>
          </table>

          <p>ora verifichiamo il contenuto del file <em>test</em></p>
        </div>

        <div class="SECT2">
          <hr />

          <h3 class="SECT2"><a name="SUBSEC-AVVIARE-BSD" id=
          "SUBSEC-AVVIARE-BSD"></a>12.3.3. Avviare Squid con i sistemi
          <em>*BSD</em></h3>

          <p>Ecco uno script di start-up per un sistema BSD, il file deve
          essere posizionato nella directory
          <em>/usr/local/etc/rc.d</em></p>

          <table border="0" bgcolor="#E0E0E0" width="100%">
            <tr>
              <td>
                <pre class="PROGRAMLISTING">
#!/bin/sh
# nome del file: squid.sh
echo -n &#39; Squid &#39;
case &quot;$1&quot; in
start)
/usr/local/squid/bin/squid -D
;;
stop)
/usr/local/squid/bin/squid -k shutdown
;;
restart)
/usr/local/squid/bin/squid -k reconfigure
;;
*)
echo &quot;Usage: `basename $0` {start|stop|restart}&quot;
;;
esac
   
</pre>
              </td>
            </tr>
          </table>
        </div>
      </div>

      <div class="SECT1">
        <hr />

        <h2 class="SECT1"><a name="SEC-AVVIARE-VERSIONE-COMPILATA-RH" id=
        "SEC-AVVIARE-VERSIONE-COMPILATA-RH"></a>12.4. Avviare una versione
        compilata su Red Hat Linux</h2>

        <p>Come noto tutte le versioni di RedHat Linux, a partire dalla
        release 7.2, sino ad arrivare alla versione 9.0 non vengono
        pi&ugrave; supportate. E&#39; stato anche istituito un webservice
        di supporto non ufficiale da parte di FedoraLegacy (URLs <a href=
        "http://www.fedoralegacy.org/" target=
        "_top">http://www.fedoralegacy.org/</a>) che &egrave; diverso tempo
        che non rilascia patch per le applicazioni pi&ugrave; importanti.
        In molti casi Squid pu&ograve; rappresentare una applicazione
        mission critical per il core business ed inoltre, secondo il parere
        di chi scrive, non &egrave; mai una buona idea aggiornare un
        Sistema Operativo che funziona bene e che offre servizi importati
        per la nostra community. Una nuova release di un Sistema Operativo
        pu&ograve; offrire delle nuove funzionalit&agrave; ma potrebbe
        anche compromettere la stabilit&agrave; e l&#39;affidabilit&agrave;
        del sistema precedente qualora si decidesse di eseguire
        l&#39;aggiornamento.</p>

        <p>Abbiamo realizzato dei test funzionali utilizzando una
        distribuzione Red Hat Linux 7.3, gli stessi sono stati ripetuti con
        successo utilizzando Fedora Core 1 e possiamo supporre che la
        configurazione che andremo a descrivere possa funzionare anche con
        Mandrake Linux e le altre distribuzioni Red Hat, il cui sistema di
        init &egrave; praticamente uguale identico.</p>

        <p>Il Sistema di <em>init</em> di una distribuzione Red Hat Linux
        &egrave; ispirato al modello System V, dunque legge il contenuto
        del file <em>/etc/inittab</em></p>

        <table border="0" bgcolor="#E0E0E0" width="100%">
          <tr>
            <td>
              <pre class="PROGRAMLISTING">
id:x:initdefault:
  
</pre>
            </td>
          </tr>
        </table>

        <p>questa linea identifica il <em>run level</em> che viene attivato
        come default. In questo esempio la <em>x</em> identifica il numero
        di run level e tutti i link simbolici contenuti nella directory
        <em>/etc/rcx.d/</em> verranno mandati in esecuzione.</p>

        <p>La prima attivit&agrave; da svolgere &egrave; quella di
        rimuovere la versione che viene distribuita ed installata con il
        Sistema Operativo. Nel caso di studio che stiamo documentando, in
        prima istanza verificheremo la versione di Squid installata sul
        Sistema e poi procederemo alla rimozione del pacchetto utilizzando
        il comando <em>rpm</em>(8), <em>rpm</em> &egrave; l&#39;acronimo di
        RPM Package Manager o Red Hat Package Manager</p>

        <table border="0" bgcolor="#E0E0E0" width="100%">
          <tr>
            <td>
              <pre class="PROGRAMLISTING">
[root@klingon root]# rpm -qa | grep &#39;squid&#39;
squid-2.4.STABLE6-6.7.3
  
</pre>
            </td>
          </tr>
        </table>

        <p>rimuoviamo il package</p>

        <table border="0" bgcolor="#E0E0E0" width="100%">
          <tr>
            <td>
              <pre class="PROGRAMLISTING">
[root@klingon root]# rpm -e squid-2.4.STABLE6-6.7.3
warning: /etc/squid/squid.conf saved as /etc/squid/squid.conf.rpmsave
  
</pre>
            </td>
          </tr>
        </table>

        <p>l&#39;operazione appena effettuata non canceller&agrave; il
        vostro file di configurazione <em>squid.conf</em> ma lo
        rinominer&agrave; eseguendo una copia di sicurezza. Il messaggio di
        warning contenuto nell&#39;esempio sopracitato &egrave; piuttosto
        chiaro. La procedura di disinstallazione del package <em>rpm</em>
        ha rimosso anche altri files come <em>/etc/sysconfig/squid</em>.
        Questo file dovr&agrave; essere prontamente ricreato</p>

        <table border="0" bgcolor="#E0E0E0" width="100%">
          <tr>
            <td>
              <pre class="PROGRAMLISTING">
[root@klingon root]# touch /etc/sysconfig/squid
  
</pre>
            </td>
          </tr>
        </table>

        <p>editiamo il file utilizzando il nostro editor preferito</p>

        <table border="0" bgcolor="#E0E0E0" width="100%">
          <tr>
            <td>
              <pre class="PROGRAMLISTING">
# default squid options
# -D disables initial dns checks. If you most likely will not to have an
# internet connection when you start squid, uncomment this
SQUID_OPTS=&quot;-D&quot;
# Time to wait for Squid to shut down when asked. Should not be necessary
# most of the time.
SQUID_SHUTDOWN_TIMEOUT=100
  
</pre>
            </td>
          </tr>
        </table>

        <p>ora possiamo finalmente procedere con l&#39;installazione di
        Squid utilizzando il codice sorgente, per seguire la procedura di
        configurazione ed installazione &egrave; necessario riferirsi al
        <a href="#SEC-SOURCE-CODE">paragrafo</a> che abbiamo dedicato a
        questo argomento.</p>

        <p>Terminato il processo di compilazione e di installazione, con il
        comando <em>ln</em>(8) imposteremo un link simbolico del nuovo
        eseguibile <em>/usr/local/squid/sbin/squid</em> in
        <em>/usr/sbin/squid</em>. I sistemi UNIX&reg; definiscono due
        concetti a riguardo dei collegamenti. Possiamo avere dei
        <em>collegamenti fisici</em> o dei <em>collegamenti simbolici</em>.
        Un collegamento fisico viene rappresentato da un nome di un file
        mentre il collegamento simbolico &egrave; un file speciale che
        contiene un percorso fisico diretto verso il file originale. Quindi
        un collegamento simbolico pu&ograve; puntare verso un file che
        pu&ograve; essere fisicamente ubicato su un&#39;altro file
        system</p>

        <table border="0" bgcolor="#E0E0E0" width="100%">
          <tr>
            <td>
              <pre class="PROGRAMLISTING">
[root@klingon root]# ln -s /usr/local/squid/sbin/squid /usr/sbin/squid
[root@klingon root]# ls /usr/sbin/squid
lrwxrwxrwx 1 root 27 apr 8 23:06 /usr/sbin/squid -&gt; /usr/local/squid/sbin/squid*
  
</pre>
            </td>
          </tr>
        </table>

        <p>a questo punto procediamo con la generazione dell&#39;ambiente
        di init ricreando il file di init per il demone Squid, questo ci
        consentir&agrave; di avviare il proxy server con il boot del
        Sistema Operativo. Il nome del file di init &egrave;
        <em>/etc/rc.d/init.d/squid</em></p>

        <table border="0" bgcolor="#E0E0E0" width="100%">
          <tr>
            <td>
              <pre class="PROGRAMLISTING">
[root@klingon root]# touch /etc/rc.d/init.d/squid
[root@klingon root]# chmod u+x,g+x,o+x /etc/rc.d/init.d/squid
  
</pre>
            </td>
          </tr>
        </table>

        <p>nell&#39;esempio che riportiamo in calce, Vi proponiamo un file
        di init per i sistemi Red Hat, modificato in alcuni punti. Le
        modifiche devono essere riferite al tipo di albero delle directory
        che sono state definite come standard per una versione di Squid
        compilata. Per altre informazioni sull&#39;albero delle directory
        fare riferimento al <a href=
        "#SUBSEC-ALBERO-DIRECTORY-MAKEINSTALL">paragrafo</a> che abbiamo
        dedicato all&#39;argomento. Questo file consentir&agrave; a Red Hat
        Linux di eseguire una versione compilata sulla macchina locale</p>

        <table border="0" bgcolor="#E0E0E0" width="100%">
          <tr>
            <td>
              <pre class="PROGRAMLISTING">
#!/bin/bash
# filename : /etc/rc.d/init.d/squid
# modifiche: il file &egrave; stato modificato per eseguire una versione di Squid \
# compilata, il file &egrave; stato testato su Red Hat Linux 7.3 
#
# squid This shell script takes care of starting and stopping
# Squid Internet Object Cache
#
# chkconfig: - 90 25
# description: Squid - Internet Object Cache. Internet object caching is \
# a way to store requested Internet objects (i.e., data available \
# via the HTTP, FTP, and gopher protocols) on a system closer to the \
# requesting site than to the source. Web browsers can then use the \
# local Squid cache as a proxy HTTP server, reducing access time as \
# well as bandwidth consumption.
# pidfile: /usr/local/squid/var/run/squid.pid
# config : /usr/local/squid/etc/squid.conf
# cache : /usr/local/squid/var/cache
# logs : /usr/local/squid/var/logs
PATH=/usr/bin:/sbin:/bin:/usr/sbin
export PATH
# Source function library.
. /etc/rc.d/init.d/functions
# Source networking configuration.
. /etc/sysconfig/network
# Check that networking is up.
[ ${NETWORKING} = &quot;no&quot; ] &amp;&amp; exit 0
# check if the squid conf file is present
#
# &egrave; stata modificata la directory dove &egrave; ubicato il file \
# di configurazione di Squid
[ -f /usr/local/squid/etc/squid.conf ] || exit 0
if [ -f /etc/sysconfig/squid ]; then
. /etc/sysconfig/squid
else
SQUID_OPTS=&quot;-D&quot;
SQUID_SHUTDOWN_TIMEOUT=100
fi
# determine the name of the squid binary
#
# ci si riferisce al percorso del vecchio eseguibile \
# ed avremo provveduto a creare un eventuale link simbolico \
# che punta al nuovo file eseguibile
[ -f /usr/sbin/squid ] &amp;&amp; SQUID=squid
[ -z &quot;$SQUID&quot; ] &amp;&amp; exit 0
prog=&quot;$SQUID&quot;
# determine which one is the cache_swap directory
# nel caso in cui la directory di swap sia vuota squid ne \
# crea una, attenzione al percorso di squid.conf
CACHE_SWAP=`sed -e &#39;s/#.*//g&#39; /usr/local/squid/etc/squid.conf | \
grep cache_dir | awk &#39;{ print $3 }&#39;`
[ -z &quot;$CACHE_SWAP&quot; ] &amp;&amp; CACHE_SWAP=/usr/local/squid/var/cache
RETVAL=0
start() {
for adir in $CACHE_SWAP; do
if [ ! -d $adir/00 ]; then 
echo -n &quot;init_cache_dir $adir... &quot;
$SQUID -z -F 2&gt;/dev/null
fi
done
echo -n $&quot;Starting $prog: &quot;
$SQUID $SQUID_OPTS 2&gt; /dev/null &amp;
RETVAL=$?
[ $RETVAL -eq 0 ] &amp;&amp; touch /var/lock/subsys/$SQUID
[ $RETVAL -eq 0 ] &amp;&amp; echo_success
[ $RETVAL -ne 0 ] &amp;&amp; echo_failure
echo
return $RETVAL
}
stop() {
echo -n $&quot;Stopping $prog: &quot;
$SQUID -k check &gt;/dev/null 2&gt;&amp;1
RETVAL=$?
if [ $RETVAL -eq 0 ] ; then
$SQUID -k shutdown &amp;
rm -f /var/lock/subsys/$SQUID
timeout=0
while : ; do
[ -f /usr/local/squid/var/run/squid.pid ] || break
if [ $timeout -ge $SQUID_SHUTDOWN_TIMEOUT ]; then
echo
return 1
fi
sleep 2 &amp;&amp; echo -n &quot;.&quot; 
timeout=$((timeout+2))
done
echo_success
echo 
else
echo_failure
echo
fi
return $RETVAL
} 
reload() {
$SQUID $SQUID_OPTS -k reconfigure 
}
restart() {
stop
start
} 
condrestart() {
[ -e /var/lock/subsys/squid ] &amp;&amp; restart || :
}
rhstatus() { 
status $SQUID
$SQUID -k check
}
probe() {
return 0
} 
case &quot;$1&quot; in
start)
start
;;
stop)
stop
;;
reload)
reload
;;
restart)
restart
;;
condrestart)
condrestart
;;
status)
rhstatus
;;
probe)
exit 0
;;
*)
echo $&quot;Usage: $0 {start|stop|status|reload|restart|condrestart}&quot;
exit 1
esac
exit $?
  
</pre>
            </td>
          </tr>
        </table>

        <p>ora verifichiamo l&#39;esistenza di un&#39;utente appropriato
        per eseguire Squid. In particolare per le distribuzioni Red Hat
        Linux, dovrebbe essere gi&agrave; presente l&#39;utente squid. In
        effetti l&#39;utente dovrebbe essere presente in quanto creato
        precedentemente dalla procedura di installazione della
        distribuzione originale in formato RPM</p>

        <table border="0" bgcolor="#E0E0E0" width="100%">
          <tr>
            <td>
              <pre class="PROGRAMLISTING">
[root@klingon root]# more /etc/passwd | grep squid
squid:x:23:23::/var/spool/squid:/dev/null
  
</pre>
            </td>
          </tr>
        </table>

        <p>in merito al Disk Storage di Squid, accertiamoci di configurare
        anche nel nuovo file di configurazione lo stesso percorso che
        abbiamo utilizzato nella versione precedente di Squid (TAG
        <em>cache_dir</em>)</p>

        <table border="0" bgcolor="#E0E0E0" width="100%">
          <tr>
            <td>
              <pre class="PROGRAMLISTING">
[root@klingon root]# more /etc/squid/squid.conf.rpmsave | grep cache_dir
#
cache_dir ufs /home/var/spool/squid 2024 16 256
  
</pre>
            </td>
          </tr>
        </table>

        <p>ora procederemo con l&#39;assegnazione dei permessi sulle
        directory, questo processo &egrave; fondamentale per consentire ai
        processi di disk I/O di Squid di essere eseguiti. Inoltre editeremo
        il file <em>squid.conf</em> per impostare al meglio la nuova
        configurazione. In questo caso non dimentichiamo che stiamo
        effettuando una migrazione da una versione 2.4 pacchettizata da Red
        Hat ad una versione 2.5 direttamente compilata utilizzando i
        sorgenti prelevati dal sito del progetto Squid. Ricordiamo al
        lettore che vi sono delle differenze piuttosto importanti tra la
        versione 2.4 e la versione 2.5 (cfr. capitolo <a href=
        "#CHA-DIFFERENZE-TRA-24-E-25">differenze</a> tra Squid 2.4 a Squid
        2.5), pertanto non sar&agrave; possibile riutilizzare in alcun modo
        lo stesso file di configurazione</p>

        <table border="0" bgcolor="#E0E0E0" width="100%">
          <tr>
            <td>
              <pre class="PROGRAMLISTING">
[root@klingon root]# cd /usr/local/squid/var/
[root@klingon var]# chown -R squid:squid *
[root@klingon var]# ls
totale 20
drwxr-xr-x 5 root 4096 apr 7 22:17 ./
drwxr-xr-x 9 root 4096 apr 7 21:30 ../
d-wx--x--x 2 squid 4096 apr 7 22:17 cache/
d-wx--x--x 2 squid 4096 apr 7 21:30 logs/
d-wx--x--x 2 squid 4096 apr 7 22:17 run/
  
</pre>
            </td>
          </tr>
        </table>

        <p>per riprodurre il file <em>squid.conf</em> in maniera fedele
        possiamo aiutarci con il comando <em>grep</em>(8), <em>grep</em>
        ricerca nei file specificati le righe che contengono una
        corrispondenza, possiamo cos&igrave; ricercare nel nuovo file di
        configurazione i TAG pi&ugrave; significativi. Nell&#39;esempio
        vediamo la parte relativa alla configurazione SNMP</p>

        <table border="0" bgcolor="#E0E0E0" width="100%">
          <tr>
            <td>
              <pre class="PROGRAMLISTING">
[root@klingon root]# more /etc/squid/squid.conf.rpmsave | grep snmp
acl snmpManager src 192.168.0.4/255.255.255.255
acl snmppublic snmp_community public
# TAG: snmp_port
# NOTE: SNMP support requires use the --enable-snmp configure
snmp_port 3401
# TAG: snmp_access
snmp_access allow snmpManager
snmp_access allow snmppublic localhost
snmp_access allow allowed_hosts
snmp_access deny all
  
</pre>
            </td>
          </tr>
        </table>

        <p>al termine della preparazione del file <em>squid.conf</em>
        possiamo provare ad avviare nuovamente Squid</p>

        <table border="0" bgcolor="#E0E0E0" width="100%">
          <tr>
            <td>
              <pre class="PROGRAMLISTING">
[root@klingon root]# squid -k parse
[root@klingon root]# /etc/rc.d/init.d/squid start
Avvio di squid: [ OK ]
[root@klingon root]# netstat --l | grep webcache
tcp 0 0 *:webcache *:* LISTEN
[root@klingon root]# netstat --l | grep 3401
udp 0 0 *:3401 *:*
[root@klingon root]# nmap localhost
Starting nmap 3.50 ( http://www.insecure.org/nmap/ ) at 2004-04-08 23:57 CEST
Interesting ports on localhost (127.0.0.1):
(The 1645 ports scanned but not shown below are in state: closed)
PORT STATE SERVICE
3128/tcp open squid-http
  
</pre>
            </td>
          </tr>
        </table>

        <p>grandioso, Squid &egrave; in funzione e la migrazione &egrave;
        stata totalmente completata. A questo punto dovremo fare in modo di
        avviare il processo squid con il relativo livello di init del
        Sistema Operativo (3 o 5) utilizzando il comando
        <em>chkconfig</em>(8), <em>chkconfig</em> fornisce una facility a
        linea di comando per mantenere le directory <em>/etc/rc[0-6].d</em>
        in maniera gerarchica e consentire agli Amministratori di Sistema
        di manipolare i link simbolici contenuti all&#39;interno di queste
        directory</p>

        <table border="0" bgcolor="#E0E0E0" width="100%">
          <tr>
            <td>
              <pre class="PROGRAMLISTING">
[root@klingon root]# chkconfig squid on
[root@klingon root]# ls /etc/rc.d/rc3.d/S90squid
lrwxrwxrwx 1 root 15 apr 9 00:03 /etc/rc.d/rc3.d/S90squid -&gt; ../init.d/squid*
  
</pre>
            </td>
          </tr>
        </table>

        <p>potremo continuare ad utilizzare tranquillamente tutte le
        facility di gestione di un Sistema Red Hat come ad esempio il
        comando <em>service</em>, questa utility consente di manipolare i
        servizi di sistema</p>

        <table border="0" bgcolor="#E0E0E0" width="100%">
          <tr>
            <td>
              <pre class="PROGRAMLISTING">
[root@klingon root]# service squid stop
Interruzione di squid: [ OK ]
[root@klingon root]# service squid start
Avvio di squid: [ OK ]
  
</pre>
            </td>
          </tr>
        </table>

        <p>Maggiori dettagli a riguardo degli scrip di avviamento sono
        reperibili nelle FAQ in lingua inglese presso la URLs <a href=
        "http://www.squid-cache.org/Doc/FAQ/FAQ-3.html#ss3.6" target=
        "_top">http://www.squid-cache.org/Doc/FAQ/FAQ-3.html#ss3.6</a>.</p>
      </div>

      <div class="SECT1">
        <hr />

        <h2 class="SECT1"><a name="SEC-REDHAT-FEDORA" id=
        "SEC-REDHAT-FEDORA"></a>12.5. RedHat, Fedora Core e Mandrake
        Linux</h2>

        <p>In fase di installazione, sar&agrave; direttamente il package in
        formato <em>rpm</em> che viene fornito con il Sistema Operativo,
        che si occuper&agrave; di creare l&#39;utente necessario
        all&#39;esecuzione del demone e che definir&agrave; i permessi per
        l&#39;accesso al filesystem da parte del processo Squid. Qualora in
        fase di installazione non si sia provveduto all&#39;installazione
        del proxy, il comando per installare l&#39;applicazione
        &egrave;</p>

        <table border="0" bgcolor="#E0E0E0" width="100%">
          <tr>
            <td>
              <pre class="PROGRAMLISTING">
[root@pippo root]# rpm -ihv squid25-arch.rpm
  
</pre>
            </td>
          </tr>
        </table>

        <p>dopo aver editato il file di configurazione principale di Squid
        e dopo averne verificato la correttezza, potremo creare la
        struttura delle directory degli oggetti di cache con il comando</p>

        <table border="0" bgcolor="#E0E0E0" width="100%">
          <tr>
            <td>
              <pre class="PROGRAMLISTING">
[root@pippo root]# squid -z
  
</pre>
            </td>
          </tr>
        </table>

        <p>con <em>Red Hat Linux</em>, <em>Fedora Core</em> e <em>Mandrake
        Linux</em> il comando per avviare Squid &egrave;</p>

        <table border="0" bgcolor="#E0E0E0" width="100%">
          <tr>
            <td>
              <pre class="PROGRAMLISTING">
[root@voyager root]# service squid start
  
</pre>
            </td>
          </tr>
        </table>

        <p>da annotare che in molte di queste distribuzioni Linux, il
        semplice avvio del servizio &egrave; sufficente per la generazione
        della cache su disco</p>
      </div>

      <div class="SECT1">
        <hr />

        <h2 class="SECT1"><a name="SEC-DEBIAN" id="SEC-DEBIAN"></a>12.6.
        Debian GNU/Linux</h2>

        <p>In fase di installazione sar&agrave; la distribuzione del
        pacchetto in formato <em>deb</em> fornita con il Sistema Operativo,
        che si occuper&agrave; di creare l&#39;utente necessario
        all&#39;esecuzione del demone e che definir&agrave; i permessi per
        l&#39;accesso al filesystem da parte del processo Squid. Qualora in
        fase di installazione non si sia provveduto all&#39;installazione
        del proxy, il comando per installare l&#39;applicazione
        &egrave;</p>

        <table border="0" bgcolor="#E0E0E0" width="100%">
          <tr>
            <td>
              <pre class="PROGRAMLISTING">
[root@voyager root]# apt-get install squid
  
</pre>
            </td>
          </tr>
        </table>

        <p>dopo avere editato il file di configurazione principale di Squid
        e dopo averne verificato la sua correttezza, potremo creare la
        struttura delle directory degli oggetti di cache con il comando</p>

        <table border="0" bgcolor="#E0E0E0" width="100%">
          <tr>
            <td>
              <pre class="PROGRAMLISTING">
[root@voyager root]# squid -z
  
</pre>
            </td>
          </tr>
        </table>

        <p>Se utilizziamo <em>Debian Woody</em> il comando per avviare
        Squid &egrave;</p>

        <table border="0" bgcolor="#E0E0E0" width="100%">
          <tr>
            <td>
              <pre class="PROGRAMLISTING">
[root@voyager root]# /etc/init.d/squid start
  
</pre>
            </td>
          </tr>
        </table>
      </div>

      <div class="SECT1">
        <hr />

        <h2 class="SECT1"><a name="SEC-FREEBSD" id="SEC-FREEBSD"></a>12.7.
        FreeBSD</h2>

        <p>Definiremo le opzioni di configurazione, compileremo ed
        installeremo Squid direttamente dall&#39;albero dei ports di
        <em>FreeBSD</em> ricorrendo ai seguenti comandi</p>

        <table border="0" bgcolor="#E0E0E0" width="100%">
          <tr>
            <td>
              <pre class="PROGRAMLISTING">
[root@mandrake root]# cd /usr/ports/www/squid/
[root@mandrake root]# make config
  
</pre>
            </td>
          </tr>
        </table>

        <p><img src="images/makeconfig.png" alt="" /></p>Il comando
        <em>make config</em> consente di impostare in maniera interattiva
        alcune opzioni di configurazione che permettono di abilitare una
        serie di features piuttosto esotiche di Squid Proxy Server, il
        comando che utilizzeremo per installare Squid &egrave;
        <br />
        <br />

        <table border="0" bgcolor="#E0E0E0" width="100%">
          <tr>
            <td>
              <pre class="PROGRAMLISTING">
[root@mandrake root]# make install clean
  
</pre>
            </td>
          </tr>
        </table>

        <p>eseguita l&#39;installazione verificheremo la correttezza dei
        permessi sul filesystem, come abbiamo visto i permessi sono
        necessari per consentire la corretta generazione dello storage
        nonch&egrave; per la scrittura dei file di logs. I processi avviati
        da Squid verranno gestiti dall&#39;utente <em>squid</em>
        (squid-2.5.4_6 e successivi) che verr&agrave; generato
        automaticamente al momento dell&#39;installazione del ports. Dopo
        aver editato il file di configurazione principale
        <em>squid.conf</em> ed averne verificato la sua correttezza
        procediamo con la generazione degli oggetti che compongono la
        cache</p>

        <table border="0" bgcolor="#E0E0E0" width="100%">
          <tr>
            <td>
              <pre class="PROGRAMLISTING">
[root@mandrake root]# squid -z
  
</pre>
            </td>
          </tr>
        </table>

        <p>dopo aver generato lo spazio dedicato al diskstorage procediamo
        all&#39;avviamento di Squid ricorrendo allo script di avviamento
        che &egrave; stato installato direttamente dal ports</p>

        <table border="0" bgcolor="#E0E0E0" width="100%">
          <tr>
            <td>
              <pre class="PROGRAMLISTING">
[root@mandrake root]# /usr/local/etc/rc.d/squid.sh start
  
</pre>
            </td>
          </tr>
        </table>

        <p>non dimentichiamo di modificare lo script di override del
        sistema di init <em>/etc/rc.conf</em> di <em>FreeBSD</em>, nel
        quale dovremo includere la seguente entry (squid-2.5.4_6 e
        successivi)</p>

        <table border="0" bgcolor="#E0E0E0" width="100%">
          <tr>
            <td>
              <pre class="PROGRAMLISTING">
squid_enable=&quot;YES&quot;
  
</pre>
            </td>
          </tr>
        </table>

        <p>lo script di avvio &egrave; stato posizionato tra gli script di
        avviamento delle applicazioni lato user, pertanto Squid
        verr&agrave; avviato al momento del processo di boot del sistema
        operativo.</p>
      </div>

      <div class="SECT1">
        <hr />

        <h2 class="SECT1"><a name="SEC-OS2" id="SEC-OS2"></a>12.8. OS/2 o
        EComStation</h2>

        <p>Nella distribuzione di Squid per OS/2 ed EComStation viene
        incluso il file <em>squid.cmd</em> che dovr&agrave; essere
        preventivamente editato per definire il percorso (<em>path</em>)
        dell&#39;eseguibile di Squid.</p>

        <table border="0" bgcolor="#E0E0E0" width="100%">
          <tr>
            <td>
              <pre class="PROGRAMLISTING">
@setlocal 
@set SQUID_DIRECTORY=e:\squid 
@%SQUID_DIRECTORY%\bin\squid %1 %2 %3 %4 %5 %6 %7 %8 %9 
@endlocal
  
</pre>
            </td>
          </tr>
        </table>

        <p>prima di avviare il Proxy Server sar&agrave; necessario editare
        il file di configurazione adeguandolo alle nostre esigenze,
        verificarne la sintassi e successivamente dovremo generare gli
        oggetti che compongono la cache</p>

        <table border="0" bgcolor="#E0E0E0" width="100%">
          <tr>
            <td>
              <pre class="PROGRAMLISTING">
$ squid -z
  
</pre>
            </td>
          </tr>
        </table>

        <p>solo ora sar&agrave; possibile eseguire il file
        <em>squid.cmd</em> per avviare Squid</p>
      </div>

      <div class="SECT1">
        <hr />

        <h2 class="SECT1"><a name="SEC-WINDOWS" id="SEC-WINDOWS"></a>12.9.
        Windows NT/2000/XP/2003</h2>

        <ul>
          <li>
            <p>estrarre l&#39;archivio binario nella directory desiderata
            (il default &egrave; <em>c:\squid</em>)</p>
          </li>

          <li>
            <p>copiare il file <em>squid.conf.default</em> come
            <em>squid.conf</em> e <em>mime.conf.default</em> come
            <em>mime.conf</em></p>
          </li>

          <li>
            <p>editare il file <em>squid.conf</em> e modificare, se
            necessario, i riferimenti al percorso <em>c:/squid</em>,
            utilizzando nei percorsi del tipo &quot;<em>path</em>&quot; il
            carattere &quot;<em>/</em>&quot; e non il carattere
            &quot;<em>\</em>&quot;</p>
          </li>

          <li>
            <p>creare manualmente tutte le directory specificate in
            <em>squid.conf</em>, tranne quelle relative alla cache
            directory</p>
          </li>

          <li>
            <p>installare il servizio specificando il nome del file di
            configurazione nel caso lo stesso sia diverso da
            <em>c:/squid/etc/squid.conf</em> ed il nome del servizio se lo
            stesso diverso da <em>SquidNT</em></p>
          </li>
        </ul>

        <table border="0" bgcolor="#E0E0E0" width="100%">
          <tr>
            <td>
              <pre class="PROGRAMLISTING">
squid -i [-f configfile] [-n servicename] 
  
</pre>
            </td>
          </tr>
        </table>

        <ul>
          <li>
            <p>creare la struttura di cache directory</p>
          </li>
        </ul>

        <table border="0" bgcolor="#E0E0E0" width="100%">
          <tr>
            <td>
              <pre class="PROGRAMLISTING">
squid -z [-f configfile] 
  
</pre>
            </td>
          </tr>
        </table>

        <ul>
          <li>
            <p>configurare nel registro di Windows le opzioni di avvio di
            Squid</p>
          </li>
        </ul>

        <table border="0" bgcolor="#E0E0E0" width="100%">
          <tr>
            <td>
              <pre class="PROGRAMLISTING">
squid -O servicecommandline [-n servicename]
  
</pre>
            </td>
          </tr>
        </table>

        <ul>
          <li>
            <p>avviare ed arrestare il servizio dal pannello di controllo
            dei servizi o ricorrendo al comando <em>net stop</em> o <em>net
            start</em></p>
          </li>
        </ul>
      </div>
    </div>

    <div class="CHAPTER">
      <hr />

      <h1><a name="CHA-CONFIGURARE-SNMP" id=
      "CHA-CONFIGURARE-SNMP"></a>Capitolo 13. Monitorare il funzionamento
      di Squid</h1>

      <div class="SECT1">
        <h2 class="SECT1"><a name="SEC-PREAMBOLO-MONITORING" id=
        "SEC-PREAMBOLO-MONITORING"></a>13.1. Preambolo</h2>

        <p>Il monitoraggio in tempo reale dei servizi di rete &eacute; una
        delle componenti essenziali per garantirne la loro erogazione.
        Squid mette a disposizione due tipi differenti di interfaccia per
        eseguire tale attivit&agrave;</p>

        <ul>
          <li>
            <p>Supporto SNMP (Simple Network Management Protocol)</p>
          </li>

          <li>
            <p>Il Cache Manager</p>
          </li>
        </ul>

        <p>nelle pagine seguenti approfondiremo al meglio queste due
        componenti.</p>
      </div>

      <div class="SECT1">
        <hr />

        <h2 class="SECT1"><a name="SEC-SQUID-CON-SNMP" id=
        "SEC-SQUID-CON-SNMP"></a>13.2. Squid ed SNMP</h2>

        <p>Il troubleshooting &egrave; necessario per risolvere molti
        problemi che si possono verificare all&#39;interno di una rete, una
        delle aspirazioni di un buon amministratore di rete &egrave; quella
        di non avere problemi. Il software che consente di effettuare il
        network management delle reti TCP/IP &egrave; principalmente basato
        sul protocollo <em>Simple Network Management Protocol</em> (SNMP).
        SNMP &egrave; un protocollo del tipo client/server che &egrave;
        descritto come protocollo di management e viene utilizzato per
        consentire la gestione di intere reti geografiche e di tenere sotto
        controllo qualsiasi tipo di apparato. Il Draft che descrive il
        protocollo SNMP &egrave; la RFC 1157 (<a href=
        "http://www.ietf.org/rfc/rfc1157.txt" target=
        "_top">http://www.ietf.org/rfc/rfc1157.txt</a>).</p>

        <p>Gli agenti SNMP (il server) si occupano di monitorare lo stato
        degli apparati di rete e trasmettono i dati o consentono
        l&#39;analisi delle informazioni relative al loro stato di
        funzionamento. Il manager (il client SNMP) viene eseguito sulla
        Network Management Station (NMS), questa postazione &egrave; in
        effetti il collettore di tutte le informazioni provenienti dai vari
        apparati di rete, le informazioni vengono immagazzinate sulla base
        di dati che possono essere visualizzati in tempo reale. Esistono
        diversi applicativi che consentono di manipolare le informazioni
        fornite dalla stazione di NMS.</p>

        <p>La maggioranza degli apparati TCP/IP vengono forniti con un SNMP
        manager, Squid &egrave; un software che, se opportunamente
        configurato, pu&ograve; tranquillamente funzionare come server SNMP
        e fornire informazioni dettagliate sullo stato della webcache
        nonch&egrave; sul traffico che sta gestendo in un dato momento.</p>

        <p>SNMP &egrave; un protocollo del tipo richiesta/risposta, il
        protocollo SNMP utilizza per il trasporto dei pacchetti il
        protocollo UDP (porte 161/162UDP), il transito dei dati &egrave;
        &quot;insicuro&quot; in quanto avviene in chiaro senza alcun tipo
        di crittografia. La richiesta e la risposta ai messaggi che SNMP
        invia nei datagrammi UDP viene chiamata <em>Protocol Data
        Units</em> (PDU).</p>

        <div class="SECT2">
          <hr />

          <h3 class="SECT2"><a name="SUBSEC-CONFIGURAZIONE-SUPPORTO-SNMP"
          id="SUBSEC-CONFIGURAZIONE-SUPPORTO-SNMP"></a>13.2.1.
          Configurazione supporto SNMP</h3>

          <p>Abbiamo gi&agrave; detto che con Squid viene incluso un agente
          <em>Simple Network Managment Protocol</em> (SNMP), per
          configurare il supporto SNMP &egrave; necessario compilare Squid
          con le seguenti opzioni di configure</p>

          <table border="0" bgcolor="#E0E0E0" width="100%">
            <tr>
              <td>
                <pre class="PROGRAMLISTING">
./configure --enable-snmp
   
</pre>
              </td>
            </tr>
          </table>

          <p>inoltre sar&agrave; anche necessario editare il file
          <em>squid.conf</em> per specificare una lista di
          <em>communities</em>, &egrave; possibile effettuare questa
          operazione utilizzando il TAG ACL riportato nell&#39;esempio
          sottostante dove l&#39;indirizzo IP 10.0.0.2 &egrave; quello
          della proxy appliance:</p>

          <table border="0" bgcolor="#E0E0E0" width="100%">
            <tr>
              <td>
                <pre class="PROGRAMLISTING">
acl locallan src 10.0.0.0/255.255.255.0 
acl localla1 src 10.0.1.0/255.255.255.0 
acl snmpManager src 10.0.0.2/255.255.255.255 
acl snmppublic snmp_community public 
acl snmpjoebloggs snmp_community joebloggs 
   
</pre>
              </td>
            </tr>
          </table>

          <p>nel nostro caso, oltre alle access list che definiscono la
          rete locale, vengono create 3 nuove ACL</p>

          <ul>
            <li>
              <p>una per il ManagerServer SNMP</p>
            </li>

            <li>
              <p>due per le <em>communities</em> che prendono il nome di
              &quot;public&quot; e &quot;joebloggs&quot;</p>
            </li>
          </ul>

          <p>i nomi delle <em>communities</em> vengono determinati a
          piacere dall&#39;amministratore del network. E&#39; necessario
          specificare una porta sulla quale deve rimanere in ascolto
          l&#39;agente SNMP, per fare questo si utilizza il TAG
          <em>snmp_port</em>, la porta utilizzata come default da Squid
          &egrave; la <em>3401</em></p>

          <table border="0" bgcolor="#E0E0E0" width="100%">
            <tr>
              <td>
                <pre class="PROGRAMLISTING">
snmp_port 3401 
   
</pre>
              </td>
            </tr>
          </table>

          <p>&egrave; anche possibile effettuare il forward delle richieste
          SNMP su un&#39;altro server SNMP che, nella fattispecie, potrebbe
          gi&agrave; essere in ascolto sulla stessa macchina sulla quale
          &egrave; appunto in funzione il proxy, &egrave; possibile
          eseguire questa operazione utilizzando il seguente TAG</p>

          <table border="0" bgcolor="#E0E0E0" width="100%">
            <tr>
              <td>
                <pre class="PROGRAMLISTING">
forward_snmp_port 
   
</pre>
              </td>
            </tr>
          </table>

          <p>Per autorizzare l&#39;accesso all&#39;agente SNMP di Squid
          devono essere definite le autorizzazioni per i TAG ACL che
          abbiamo creato in precedenza, ad esempio</p>

          <table border="0" bgcolor="#E0E0E0" width="100%">
            <tr>
              <td>
                <pre class="PROGRAMLISTING">
snmp_access allow snmpManager 
snmp_access allow snmppublic localhost 
snmp_access allow snmppublic locallan 
snmp_access deny all 
   
</pre>
              </td>
            </tr>
          </table>

          <p>nel nostro caso l&#39;agente SNMP potr&agrave; sempre essere
          avviato da <em>snmpManager</em>, ovvero la macchina che esegue
          l&#39;appliance di cache e potr&agrave; essere consultato da
          localhost (127.0.0.1) e la locallan (10.0.0.0/24), tutte le altre
          macchine della WAN non potranno accedere al servizio. Se non
          viene definita alcuna ACL, l&#39;accesso SNMP &egrave; sempre
          vietato come standard predefinito. E&#39; anche possibile
          definire indirizzi IP determinati che legano l&#39;agente SNMP di
          Squid per quello che concerne il traffico in entrata e quello in
          uscita, &egrave; possibile effettuare il bind facendo ricorso al
          seguente TAG:</p>

          <table border="0" bgcolor="#E0E0E0" width="100%">
            <tr>
              <td>
                <pre class="PROGRAMLISTING">
snmp_incoming_address 0.0.0.0 
snmp_outgoing_address 0.0.0.0 
   
</pre>
              </td>
            </tr>
          </table>

          <p>dopo aver configurato correttamente l&#39;agente SNMP &egrave;
          importante verificare che l&#39;appliance Squid sia in ascolto
          sulla porta 3401 (predefinita), per effettuare questa verifica
          &egrave; necessario utilizzare il comando netstat (sistemi Linux
          e FreeBSD):</p>

          <table border="0" bgcolor="#E0E0E0" width="100%">
            <tr>
              <td>
                <pre class="PROGRAMLISTING">
[root@calimero root]# netstat -na |grep udp|grep 3401 
udp        0      0 0.0.0.0:3401            0.0.0.0:* 
   
</pre>
              </td>
            </tr>
          </table>

          <p>verificato il funzionamento dell&#39;agente SNMP possiamo
          finalmente testare il funzionamento del proxy server Squid,
          &egrave; attuabile testare le funzionalit&agrave; dell&#39;agente
          SNMP con una semplice utility presente nei migliori sistemi
          UNIX&reg;: <em>snmpwalk</em></p>

          <table border="0" bgcolor="#E0E0E0" width="100%">
            <tr>
              <td>
                <pre class="PROGRAMLISTING">
[root@calimero root]# snmpwalk -p 3401 nomehost_0 public .1.3.6.1.4.1.3495.1.1 
enterprises.3495.1.1.1.0 = 84 
enterprises.3495.1.1.2.0 = 12916 
enterprises.3495.1.1.3.0 = Timeticks: (1326) 0:00:13.26
[root@calimero root]# snmpwalk -p 3401 nomehost_1 public .1.3.6.1.4.1.3495.1.1 
enterprises.3495.1.1.1.0 = 84 
enterprises.3495.1.1.2.0 = 171000 
enterprises.3495.1.1.3.0 = Timeticks: (8406) 0:01:24.06
   
</pre>
              </td>
            </tr>
          </table>
        </div>

        <div class="SECT2">
          <hr />

          <h3 class="SECT2"><a name="SUBSEC-MRTG-E-SQUID" id=
          "SUBSEC-MRTG-E-SQUID"></a>13.2.2. MRTG e Squid</h3>

          <p>Dopo aver configurato il proxy server come agente SNMP,
          &egrave; anche possibile controllare al meglio le performance
          dell&#39;applicazione Squid utilizzando <em>MRTG</em>: Multi
          Router Traffic Grapher &egrave; un prodotto software noto negli
          ambienti del networking avanzato, la configurazione di questo
          software non &egrave; certo oggetto di questo capitolo e per
          maggiori informazioni &egrave; possibile accedere alla URLs
          <a href="http://www.mrtg.it/" target=
          "_top">http://www.mrtg.it/</a> .</p>

          <p>Ad ogni buon conto, <em>MRTG</em> &egrave; un programma che
          utilizza il linguaggio perl e che molte distribuzioni Linux
          installano come &quot;default&quot; nella loro configurazione per
          i servers. <em>MRTG</em> viene utilizzato dai network manager per
          la sua duttilit&agrave; e per la facilit&agrave; di utilizzo nel
          controllo degli apparati di rete come, ad esempio, i Router della
          CISCO Systems (<a href="http://www.cisco.com/" target=
          "_top">http://www.cisco.com/</a>).</p>

          <p>Attivato l&#39;agente SNMP di Squid &egrave; possibile
          utilizzare Multi Router Traffic Grapher per verificare il
          traffico e l&#39;uptime dalla cache appliance, se si dispone di
          una distribuzione Linux Red Hat 7.1 o 7.2 ecco la entry da
          aggiungere nel file <em>/etc/mrtg/mrtg.cgf</em></p>

          <table border="0" bgcolor="#E0E0E0" width="100%">
            <tr>
              <td>
                <pre class="PROGRAMLISTING">
LoadMIBs: /etc/squid/mib.txt 
Target[proxy-srvkbinout]: cacheServerInKb&amp;cacheServerOutKb:public@192.168.8.11:3401
MaxBytes[proxy-srvkbinout]: 1250000 
Title[proxy-srvkbinout]: Cache Server Traffic In / Out 
PageTop[proxy-srvkbinout]: &lt;H1&gt;Cache Statistics: traffic (In/Out)&lt;/H1&gt; 
Suppress[proxy-srvkbinout]: y 
LegendI[proxy-srvkbinout]: Traffic In 
LegendO[proxy-srvkbinout]: Traffic Out 
Legend1[proxy-srvkbinout]: Traffic In 
Legend2[proxy-srvkbinout]: Traffic Out 
YLegend[proxy-srvkbinout]: per minute 
ShortLegend[proxy-srvkbinout]: b/min 
kMG[proxy-srvkbinout]: k,M,G,T 
kilo[proxy-srvkbinout]: 1024 
Options[proxy-srvkbinout]: nopercent, perminute
   
</pre>
              </td>
            </tr>
          </table>

          <p><img src="images/proxy.http-day.png" alt="" /></p>Per quello
          che concerne l&#39;integrazione di <em>MRTG</em> con Squid, va
          segnalata la home page di Chris. L&#39;autore pubblica una serie
          di interessanti configurazioni, la URL&#39;s di riferimento
          &egrave; <a href="http://www.psychofx.com/chris/unix/mrtg/"
          target="_top">http://www.psychofx.com/chris/unix/mrtg/</a> .
          <br />
          <br />

          <p>Nell&#39;area <a href="contrib" target="_top">/contrib</a>
          potrete trovare alcuni file di configurazione <em>MRTG</em>, tali
          file Vi saranno utili ad una corretta utilizzazione con Squid
          proxy server.</p>
        </div>

        <div class="SECT2">
          <hr />

          <h3 class="SECT2"><a name="SUBSEC-ISTRUZIONE-RISORSE-MRTG" id=
          "SUBSEC-ISTRUZIONE-RISORSE-MRTG"></a>13.2.3. Istruzioni e risorse
          per utilizzare Squid con MRTG</h3>

          <p>Segue una lista di URLs per <em>utilizzare MRTG con
          Squid</em>, tutte le informazioni sono reperibili anche nelle
          Squid FAQ alla URLs <a href=
          "http://www.squid-cache.org/Doc/FAQ/FAQ-18.html#ss18.9" target=
          "_top">http://www.squid-cache.org/Doc/FAQ/FAQ-18.html#ss18.9</a></p>

          <ol type="1">
            <li>
              <p>Monitoraggio della Cache - <a href=
              "http://www.cache.dfn.de/DFN-Cache/Development/Monitoring/"
              target="_top">How to setup and monitoring</a> by
              DFN-Cache</p>
            </li>

            <li>
              <p>Utilizzare MRTG per <a href=
              "http://www.acmeconsulting.it/pagine/opensource/squid/mrtg.htm"
                 target="_top">monitorare Squid by</a> Guido Serassio</p>
            </li>

            <li>
              <p>Manuale di configurazione di Squid - <a href=
              "http://squid.visolve.com/related/snmp/monitoringsquid.htm"
              target="_top">Monitoring Squid by Visolve</a></p>
            </li>

            <li>
              <p>Utilizzare <a href=
              "http://www.arnes.si/~matija/utrecht/lecture.html" target=
              "_top">MRTG con Squid</a> - workshop session by Matija
              Grabnar</p>
            </li>

            <li>
              <p><a href=
              "http://hermes.wwwcache.ja.net/FAQ/FAQ-2.html#mrtg" target=
              "_top">How do I monitor my Squid 2 cache using MRTG?</a> by
              The National Janet Web Cache Service</p>
            </li>
          </ol>

          <p>Altri esempi di configurazione di Squid con MRTG</p>

          <ol type="1">
            <li>
              <p>Collezione di <a href=
              "http://howto.aphroland.de/HOWTO/MRTG/SquidMonitoringWithMRTG"
                 target="_top">MRTG HOWTO</a></p>
            </li>

            <li>
              <p>Utilizzare MRTG per monitorare<a href=
              "http://people.ee.ethz.ch/~oetiker/webtools/mrtg/squid.html"
              target="_top">MRTG per monitorare</a> Squid - dal sito di
              MRTG</p>
            </li>

            <li>
              <p><a href=
              "http://thproxy.jinr.ru/file-archive/doc/squid/cache-snmp/mrtg-demo/"
                 target="_top">MRTG &amp; Squid</a> by Glenn Chisholm</p>
            </li>

            <li>
              <p><a href=
              "http://www.braindump.dk/en/wiki/?catid=7&amp;wikipage=ConfigFiles"
                 target="_top">Braindump</a> by Joakim Recht</p>
            </li>
          </ol>
        </div>
      </div>

      <div class="SECT1">
        <hr />

        <h2 class="SECT1"><a name="SEC-CACHE-MANAGER" id=
        "SEC-CACHE-MANAGER"></a>13.3. Il Cache Manager</h2>

        <p>Il Cache Manager &egrave; una applicazione web del tipo CGI
        (Common Gateway Interface) che consente di visualizzare diverse
        statistiche relative al processo Squid. La programmazione CGI
        riguarda la realizzazione di programmi che ricevono gli input
        direttamente da una pagina web, si tratta di una pagina web nella
        quale viene utilizzata una form HTML. Per utilizzare correttamente
        il Cache Manager &egrave; necessario installare un server web sulla
        stessa macchina dove &egrave; in esecuzione Squid.</p>

        <div class="SECT2">
          <hr />

          <h3 class="SECT2"><a name="SUBSEC-CONF-CACHEMANAGER-APACHE" id=
          "SUBSEC-CONF-CACHEMANAGER-APACHE"></a>13.3.1. Configurare il
          Cache Manager con Apache</h3>

          <p>In prima istanza assicurarsi che sia stato installato Apache e
          che la directory che contiene gli script <em>cgi-bin</em>
          utilizzi la direttiva <em>ScriptAlias</em>, &egrave; necessario
          modificare il file <em>httpd.conf</em> definendo la direttiva
          <em>ScriptAlias</em> per il singolo <em>VirtualHost</em></p>

          <table border="0" bgcolor="#E0E0E0" width="100%">
            <tr>
              <td>
                <pre class="PROGRAMLISTING">
&lt;VirtualHost 192.168.0.4&gt;
ScriptAlias /squid/cgi-bin/ /usr/local/squid/libexec/
&lt;/VirtualHost&gt;
   
</pre>
              </td>
            </tr>
          </table>

          <p>ora assicuriamoci che solo alcune workstation possano accedere
          al Cache Manager, sempre all&#39;interno della direttiva
          <em>VirtualHost</em> inseriremo le seguenti informazioni</p>

          <table border="0" bgcolor="#E0E0E0" width="100%">
            <tr>
              <td>
                <pre class="PROGRAMLISTING">
&lt;VirtualHost 192.168.0.4&gt;
&lt;Location /usr/local/libexec/squid/cachemgr.cgi&gt;
order allow,deny
allow from workstation.domain.com
&lt;/Location&gt;
&lt;/VirtualHost&gt;
   
</pre>
              </td>
            </tr>
          </table>

          <p>possiamo inserire pi&ugrave; linee per ogni direttiva
          <em>allow</em>, possiamo autorizzare interi domini o intere
          subnet. In alternativa &egrave; anche possibile proteggere il
          Cache Manager impostando una password di accesso sul server web
          utilizzando la direttiva <em>Location</em>. Per proteggere
          l&#39;accesso al Cache Manager con una password inseriremo le
          seguenti direttive nel file <em>httpd.conf</em></p>

          <table border="0" bgcolor="#E0E0E0" width="100%">
            <tr>
              <td>
                <pre class="PROGRAMLISTING">
&lt;VirtualHost 192.168.0.4&gt;
&lt;Location /usr/local/libexec/squid/cachemgr.cgi&gt;
AuthUserFile /etc/htpasswd
AuthGroupFile /dev/null
AuthName User/Password Required
AuthType Basic
require user cachemanager
&lt;/Location&gt;
&lt;/VirtualHost&gt;
   
</pre>
              </td>
            </tr>
          </table>

          <p>il file <em>/etc/htpasswd</em> contiene gli userID le password
          in formato MD5, non dimentichiamo mai che il protocollo HTTP non
          &egrave; un protocollo sicuro in quanto i dati transitano sempre
          in chiaro, maggiori informazioni sul web server Apache sono
          disponibili alla URLs <a href="http://httpd.apache.org/" target=
          "_top">http://httpd.apache.org/</a>.</p>
        </div>

        <div class="SECT2">
          <hr />

          <h3 class="SECT2"><a name="SUBSEC-CACHEMGR-PASSWORD" id=
          "SUBSEC-CACHEMGR-PASSWORD"></a>13.3.2. Impostare la password di
          accesso al Cache Manager</h3>

          <p>Con il Cache Manager &egrave; possibile visualizzare diverse
          informazioni sullo stato della cache ed &egrave; anche possibile
          bloccare il processo di Squid, &egrave; dunque una buona idea
          definire dei livelli di accesso al Cache Manager. Prima di
          impostare una password per l&#39;accesso alle varie
          funzionalit&agrave; del Cache Manager &egrave; necessario
          definire un utente amministratore della cache ricorrendo al
          TAG</p>

          <table border="0" bgcolor="#E0E0E0" width="100%">
            <tr>
              <td>
                <pre class="PROGRAMLISTING">
cache_mgr squidmaster@dominio.com
   
</pre>
              </td>
            </tr>
          </table>

          <p>a questo punto possiamo impostare i diversi livelli di
          sicurezza del Cache Manager ricorrendo all&#39;utilizzo di una o
          pi&ugrave; password. Per eseguire le operazioni di protezione del
          Cache Manager dovremo ricorrere all&#39;utilizzo del TAG
          <em>cachemgr_passwd</em>. Rammentiamo ancora al lettore che il
          traffico http non &egrave; sicuro perch&egrave; i dati
          attraversano la rete in chiaro. Per proteggere questi dati da
          occhi indiscreti &egrave; possibile ricorrere agli standard
          SSL<a name="AEN4099" href="#FTN.AEN4099" id="AEN4099">[22]</a> o
          TLS<a name="AEN4101" href="#FTN.AEN4101" id="AEN4101">[23]</a>
          che sono alla base protocollo HTTPS (RFC 2818 - <a href=
          "http://www.faqs.org/rfcs/rfc2818.html" target=
          "_top">http://www.faqs.org/rfcs/rfc2818.html</a>). L&#39;utilizzo
          del TAG all&#39;interno del file <em>squid.conf</em> &egrave; il
          seguente</p>

          <table border="0" bgcolor="#E0E0E0" width="100%">
            <tr>
              <td>
                <pre class="PROGRAMLISTING">
cachemgr_passwd [password] [azione] [azione]
   
</pre>
              </td>
            </tr>
          </table>

          <p>dove <em>password</em> &egrave; appunto la parola chiave che
          intendiamo utilizzare, il TAG <em>azione</em> corrisponde ai
          comandi che possono essere eseguiti dal Cache Manager</p>

          <table border="0" bgcolor="#E0E0E0" width="100%">
            <tr>
              <td>
                <pre class="PROGRAMLISTING">
cachemgr_passwd pippo shutdown
cachemgr_passwd paperino info stats/objects
   
</pre>
              </td>
            </tr>
          </table>

          <p>con questo esempio viene impostata come password la parola
          <em>pippo</em> per consentire al Cache Manager di eseguire la
          chiusura di Squid. Utilizzando la parola chiave paperino potremo
          visualizzare le informazioni relative al processo Squid.
          L&#39;utente che effettuer&agrave; il login al cachemgr.cgi
          &egrave; <em>squidmaster@dominio.com</em></p>
        </div>

        <div class="SECT2">
          <hr />

          <h3 class="SECT2"><a name="SUBSEC-ACL-CACHEMGR" id=
          "SUBSEC-ACL-CACHEMGR"></a>13.3.3. Definire una ACL per consentire
          l&#39;accesso al Cache Manager</h3>

          <p>Il Cache Manager interroga Squid utilizzando il protocollo
          <em>cache_object</em>, il TAG che definisce il ricorso di questo
          protocollo &egrave; <em>proto cache_obiect</em></p>

          <table border="0" bgcolor="#E0E0E0" width="100%">
            <tr>
              <td>
                <pre class="PROGRAMLISTING">
acl manager proto cache_object
acl localhost src 127.0.0.1/255.255.255.255
acl all src 0.0.0.0/0.0.0.0
   
</pre>
              </td>
            </tr>
          </table>

          <p>nell&#39;esempio sopracitato, la macchina 127.0.0.1 &egrave;
          <em>localhost</em>, il webserver Apache &egrave; in funzione
          sulla stessa macchina che esegue Squid (<em>localhost</em>). A
          questo punto dobbiamo definire delle regole che consentono
          l&#39;accesso al Cache Manager da parte di <em>localhost</em></p>

          <table border="0" bgcolor="#E0E0E0" width="100%">
            <tr>
              <td>
                <pre class="PROGRAMLISTING">
http_access deny manager !localhost
http_access allow all
   
</pre>
              </td>
            </tr>
          </table>

          <p>in alcuni casi il server web pu&ograve; essere stato
          installato su una macchina diversa da <em>localhost</em></p>

          <table border="0" bgcolor="#E0E0E0" width="100%">
            <tr>
              <td>
                <pre class="PROGRAMLISTING">
acl manager proto cache_object
acl localhost src 127.0.0.1/255.255.255.255
acl mywebserver src 192.168.0.4/255.255.255.255
acl all src 0.0.0.0/0.0.0.0
http_access deny manager !localhost !mywebserver
http_access allow all
   
</pre>
              </td>
            </tr>
          </table>

          <p>dopo aver installato e configurato Apache, definite le parole
          chiave per l&#39;accesso alle varie funzionalit&agrave; del Cache
          Manager ed infine aver definito le ACL, siamo finalmente in grado
          di utilizzare il Cache Manager di Squid.</p>
        </div>
      </div>
    </div>

    <div class="CHAPTER">
      <hr />

      <h1><a name="CHA-OPZIONI-DI-SHELL" id=
      "CHA-OPZIONI-DI-SHELL"></a>Capitolo 14. Opzioni offerte dal comando
      <em>squid(8)</em></h1>

      <div class="SECT1">
        <h2 class="SECT1"><a name="SEC-PREAMBOLO-OPZIONI-SHELL" id=
        "SEC-PREAMBOLO-OPZIONI-SHELL"></a>14.1. Preambolo</h2>

        <p>Il comando <em>squid</em>(8) mette a disposizione degli utenti
        diverse opzioni per l&#39;avvio del processo Squid, questi comandi
        possono essere impartiti direttamente dalla shell di sistema
        UNIX&reg; like oppure dalla linea di comando (cmd) dei sistemi OS/2
        o Windows NT/2000/2003. Le opzioni messe a disposizione dal comando
        <em>squid</em>(8) consentono di ottenere un controllo molto
        accurato relativamente ai processi avviati da Squid.</p>
      </div>

      <div class="SECT1">
        <hr />

        <h2 class="SECT1"><a name="SEC-OPZIONI-SQUID" id=
        "SEC-OPZIONI-SQUID"></a>14.2. Opzioni di squid(8)</h2>

        <ul>
          <li>
            <p><em>squid -a [port]</em></p>

            <p>l&#39;opzione <em>[port]</em> viene utilizzata per indicare
            una porta alternativa per le richieste HTTP in entrata, questa
            opzione viene generalmente utilizzata per delle configurazioni
            non standard</p>
          </li>

          <li>
            <p><em>squid -d [level]</em></p>

            <p>l&#39;opzione <em>[devel]</em> pu&ograve; essere espressa da
            un valore compreso da 0 a 9 e viene utilizzata per visualizzare
            i messaggi di debug, il valore specifica il livello
            &quot;stderr&quot; del messaggio di debug</p>
          </li>

          <li>
            <p><em>squid -f [file]</em></p>

            <p>l&#39;opzione <em>[file]</em> viene utilizzata per
            specificare un file di configurazione alternativo a
            <em>squid.conf</em>, l&#39;opzione deve essere seguita dal path
            completo (<em>/usr/local/etc/squid/squid.conf.test</em>)</p>
          </li>

          <li>
            <p><em>squid -h</em></p>

            <p>l&#39;opzione <em>-h</em> stampa i messaggi di aiuto e le
            modalit&agrave; di utilizzo del comando</p>
          </li>

          <li>
            <p><em>squid -k</em> <em>reconfigure</em> | <em>rotate</em> |
            <em>shutdown</em> | <em>interrupt</em> | <em>kill</em> |
            <em>debug</em> | <em>check</em> | <em>parse</em></p>

            <ul>
              <li>
                <p><em>squid -k reconfigure</em></p>

                <p>l&#39;opzione <em>reconfigure</em> invia un segnale di
                &quot;HUP&quot; al server causando la rilettura del file di
                configurazione</p>
              </li>

              <li>
                <p><em>squid -k rotate</em></p>

                <p>l&#39;opzione <em>rotate</em> invia un segnale di
                &quot;TERM&quot; al server causando la riscrittura dei
                files di log, se nel file di configurazione il TAG
                <em>logfile_rotate</em> &egrave; posto sul valore
                <em>0</em> (zero), Squid chiude e riapre tutti i files di
                log</p>
              </li>

              <li>
                <p><em>squid -k shutdown</em></p>

                <p>l&#39;opzione <em>shutdown</em> invia un segnale di
                &quot;TERM&quot; al server causando la chiusura del
                processo Squid, tale operazione si verificher&agrave; solo
                dopo il termine dell&#39;ultima connessione sospesa.
                L&#39;ammontare del tempo dedicato alla chiusura di Squid
                &egrave; contenuto nel TAG <em>shutdown_lifetime</em></p>
              </li>

              <li>
                <p><em>squid -k interrupt</em></p>

                <p>l&#39;opzione <em>interrupt</em> invia un segnale di
                &quot;INT&quot; al server causando la chiusura immediata di
                Squid senza attendere il termine dell&#39;ultima
                connessione attiva</p>
              </li>

              <li>
                <p><em>squid -k kill</em></p>

                <p>l&#39;opzione <em>kill</em> invia un segnale di
                &quot;KILL&quot; al server causando la chiusura immediata
                del processo, tale operazione avverr&agrave; senza
                preventivamente tenere conto delle connessioni attive e
                files di log</p>
              </li>

              <li>
                <p><em>squid -k debug</em></p>

                <p>l&#39;opzione <em>debug</em> invia un segnale di
                &quot;USR2&quot; causando la generazione dei messaggi di
                debug da parte di Squid. E&#39; necessario un&#39;altro
                segnale &quot;USR2&quot; per bloccare la generazione dei
                messaggi</p>
              </li>

              <li>
                <p><em>squid -k check</em></p>

                <p>l&#39;opzione <em>check</em> invia un segnale di
                &quot;ZERO&quot; al processo pid di Squid. Si tratta di un
                controllo sull&#39;attivit&agrave; di processo avviata da
                Squid</p>
              </li>

              <li>
                <p><em>squid -k parse</em></p>

                <p>l&#39;opzione <em>parse</em> esegue la verifica della
                correttezza della sintassi utilizzata nel file di
                configurazione <em>squid.conf</em></p>
              </li>
            </ul>
          </li>

          <li>
            <p><em>squid -s</em></p>

            <p>l&#39;opzione <em>-s</em> abilita il log di Squid
            direttamente sul syslog di sistema</p>
          </li>

          <li>
            <p><em>squid -u [port]</em></p>

            <p>l&#39;opzione <em>-u [port]</em> consente di specificare una
            porta alternativa per i messaggi ICP, viene utilizzato per le
            configurazioni non standard</p>
          </li>

          <li>
            <p><em>squid -v</em></p>

            <p>l&#39;opzione <em>-v</em> consente di visualizzare i dati
            sulla versione utilizzata di Squid nonch&egrave; tutte le
            opzioni di configurazione (configure) utilizzate</p>
          </li>

          <li>
            <p><em>squid -z</em></p>

            <p>l&#39;opzione <em>-z</em> consente di generale le directory
            per lo swap della memoria cache, questa opzione deve essere
            utilizzata la prima volta che viene utilizzato Squid, le
            directory verranno generate sulla base del <em>path</em>
            (percorso) specificato nella TAG <em>cache_dir</em></p>
          </li>

          <li>
            <p><em>squid -D</em></p>

            <p>l&#39;opzione <em>-D</em> non effettua il test iniziale del
            DNS, Squid normalmente verifica la risoluzione dei nomi
            all&#39;avvio per consentire un corretto funzionamento</p>
          </li>

          <li>
            <p><em>squid -F</em></p>

            <p>se il log dello <em>swap.state</em> e la cache &egrave;
            stato rigenerato con processo di foreground prima di qualsiasi
            richiesta al server, l&#39;opzione <em>-F</em> riduce il tempo
            di rigenerazione della cache</p>
          </li>

          <li>
            <p><em>squid -N</em></p>

            <p>l&#39;opzione <em>-N</em> indica a Squid di non diviene
            automaticamente un demone di background</p>
          </li>

          <li>
            <p><em>squid -R</em></p>

            <p>l&#39;opzione <em>-R</em> non abilita l&#39;opzione
            <em>SO_REUSEADDR</em> sul socket</p>
          </li>

          <li>
            <p><em>squid -V</em></p>

            <p>l&#39;opzione <em>-V</em> abilita il supporto per gli host
            virtuali per l&#39;acceleratore di httpd</p>
          </li>

          <li>
            <p><em>squid -X</em></p>

            <p>l&#39;opzione <em>-X</em> abilita il debug completo
            nell&#39;analisi del file di configurazione</p>
          </li>

          <li>
            <p><em>squid -Y</em></p>

            <p>se la vostra cache &egrave; di tipo <em>child</em> ed usa il
            protocollo ICP, l&#39;opzione <em>-Y</em> consente una
            rigenerazione veloce della cache</p>
          </li>
        </ul>
      </div>
    </div>

    <div class="CHAPTER">
      <hr />

      <h1><a name="CHA-PRIVACY" id="CHA-PRIVACY"></a>Capitolo 15.
      Privacy</h1>

      <div class="SECT1">
        <h2 class="SECT1"><a name="SEC-PREAMBOLO-PRIVACY" id=
        "SEC-PREAMBOLO-PRIVACY"></a>15.1. Preambolo</h2>

        <p>L&#39;avvento della <em>new-economy</em>, oltre a generare delle
        nuove forme di schiavit&ugrave; , ha determinato il deprecabile
        fenomeno della catalogazione dei profili utente: i managers
        rampanti, per fidelizzare gli utenti e controllare le loro
        attitudini, hanno la necessit&agrave; di conoscere sempre maggiori
        dettagli sulla privacy degli utenti della rete: questo fenomeno
        viene principalmente utilizzato per rivendere al miglior offerente
        abitudini, gusti e scelte degli utenti e per creare nuove
        opportunit&agrave; di business.</p>
      </div>

      <div class="SECT1">
        <hr />

        <h2 class="SECT1"><a name="SEC-NOTE-OPERATIVE" id=
        "SEC-NOTE-OPERATIVE"></a>15.2. Note operative</h2>

        <p>E&#39; possibile proteggere da occhi indiscreti la nostra rete
        utilizzando Squid. Per motivi legati alla sicurezza &egrave;
        fondamentale anonimizzare l&#39;indirizzamento IP della LAN/WAN ed
        eventualmente proteggere altre informazioni come quelle relative al
        client web utilizzato dagli utenti.</p>

        <p>Con il TAG <em>forwarded_for</em> Squid pu&ograve; includere il
        Vostro indirizzo IP o il nome dell&#39;host che inoltra con le sue
        richieste HTTP, il valori sono [on|off]. La situazione generica
        &egrave; molto simile a questa</p>

        <table border="0" bgcolor="#E0E0E0" width="100%">
          <tr>
            <td>
              <pre class="PROGRAMLISTING">
X-Forwarded-For: <em>192.168.2.3</em> 
  
</pre>
            </td>
          </tr>
        </table>

        <p>&egrave; comunque possibile disabilitare questa funzione per far
        apparire un messaggio generico unitamente all&#39;inoltro della
        richiesta http verso il server web del tipo</p>

        <table border="0" bgcolor="#E0E0E0" width="100%">
          <tr>
            <td>
              <pre class="PROGRAMLISTING">
X-Forwarded-For: <em>unknown</em> 
  
</pre>
            </td>
          </tr>
        </table>

        <p>per <em>disabilitare</em> l&#39;inoltro dell&#39;indirizzo IP da
        cui parte la richiesta diretta verso il server web Il TAG da
        abilitare &egrave;</p>

        <table border="0" bgcolor="#E0E0E0" width="100%">
          <tr>
            <td>
              <pre class="PROGRAMLISTING">
forwarded_for off 
  
</pre>
            </td>
          </tr>
        </table>

        <p>se correttamente configurato Squid pu&ograve; anonimizzare le
        intestazioni inoltrate tramite la richiesta HTTP, per eseguire
        questa misura di sicurezza deve essere utilizzando il TAG
        <em>anonymize_headers</em>. Nel caso che analizzeremo in seguito,
        verr&agrave; modificato l&#39;header relativo allo
        <em>User-Agent</em> ovvero il browser web utilizzato dagli utenti
        della rete che sono a valle del proxy. Utilizzo</p>

        <table border="0" bgcolor="#E0E0E0" width="100%">
          <tr>
            <td>
              <pre class="PROGRAMLISTING">
anonymize_headers allow|deny header_name 
  
</pre>
            </td>
          </tr>
        </table>

        <p>l&#39;opzione <em>anonymizer_headers</em> consente di eseguire
        configurazioni molto accurate: &egrave; infatti possibile
        specificare esattamente quali intestazioni autorizzare. Ci sono due
        metodi per utilizzare questa features</p>

        <ol type="1">
          <li>
            <p>specificare le intestazioni autorizzate</p>
          </li>

          <li>
            <p>dettagliare gli header permessi.</p>
          </li>
        </ol>

        <p>Per riprodurre le opzioni di base, gi&agrave; previste nelle
        vecchie versioni di Squid con il l&#39;opzione
        <em>http_anonymizer</em> standard dovr&agrave; essere utilizzato il
        seguente TAG</p>

        <table border="0" bgcolor="#E0E0E0" width="100%">
          <tr>
            <td>
              <pre class="PROGRAMLISTING">
anonymize_headers deny From Referer Server 
anonymize_headers deny User-Agent WWW-Authenticate Link 
  
</pre>
            </td>
          </tr>
        </table>

        <p>per riprodurre la vecchia funzione <em>http_anonymizer
        paranoid</em> &egrave; invece necessario utilizzare il seguente
        TAG</p>

        <table border="0" bgcolor="#E0E0E0" width="100%">
          <tr>
            <td>
              <pre class="PROGRAMLISTING">
anonymize_headers allow Allow Authorization Cache-Control 
anonymize_headers allow Content-Encoding Content-Length 
anonymize_headers allow Content-Type Date Expires Host 
anonymize_headers allow If-Modified-Since Last-Modified 
anonymize_headers allow Location Pragma Accept 
anonymize_headers allow Accept-Encoding Accept-Language 
anonymize_headers allow Content-Language Mime-Version 
anonymize_headers allow Retry-After Title Connection 
anonymize_headers allow Proxy-Connection 
  
</pre>
            </td>
          </tr>
        </table>

        <p>Nota<em>:</em> non &egrave; possibile utilizzare ambedue le
        regole allow e deny. Tutte le linee <em>anonymize_headers</em>
        devono avere sempre lo stesso secondo argomento. La regola base
        &egrave; che tutte le intestazioni sono autorizzate, quindi nessuna
        funzionalit&agrave; di anonymizing viene eseguita, con questo TAG
        &egrave; anche possibile anonimizzare lo user-agent ovvero il
        browser web</p>

        <table border="0" bgcolor="#E0E0E0" width="100%">
          <tr>
            <td>
              <pre class="PROGRAMLISTING">
anonymize_headers deny User-Agent 
  
</pre>
            </td>
          </tr>
        </table>

        <p>vediamo ora il TAG <em>fake_user_agent</em>. Se viene resa
        anonima l&#39;intestazione dello User-Agent utilizzando TAG
        <em>anonymize_headers</em> molti server web potrebbero rifiutare la
        richiesta HTTP inoltrata da Squid. Per evitare questo disdicevole
        inconveniente &egrave; possibile utilizzare degli artifizi, ecco un
        esempio concreto</p>

        <table border="0" bgcolor="#E0E0E0" width="100%">
          <tr>
            <td>
              <pre class="PROGRAMLISTING">
fake_user_agent Nutscrape/1.0 (Commodore Vic20; 8-bit) 
# ( da un&#39;idea di Paul Southworth - <a href="mailto:pauls@etext.org"
target="_top">pauls@etext.org</a> ) 
  
</pre>
            </td>
          </tr>
        </table>

        <p>vediamo, dopo aver effettuato la cura intensiva, come si
        presenta il nostro browser sul web</p>

        <table border="0" bgcolor="#E0E0E0" width="100%">
          <tr>
            <td>
              <pre class="PROGRAMLISTING">
Accept: image/gif, image/x-xbitmap, image/jpeg, image/pjpeg, image/png, */* 
Accept-Encoding: gzip 
Accept-Language: it,en 
Accept-Charset: iso-8859-1,*,utf-8 
User-Agent: Nutscrape/1.0 (Commodore Vic20; 8-bit) 
Via: 1.0 proxy.merlino.bbs:3128 (Squid/2.3.STABLE1) 
X-Forwarded-For: unknown 
Host: www.delegate.org 
Cache-Control: max-age=259200 
Connection: keep-alive 
  
</pre>
            </td>
          </tr>
        </table>
      </div>

      <div class="SECT1">
        <hr />

        <h2 class="SECT1"><a name="SEC-INTERNET-JUNKBUSTER" id=
        "SEC-INTERNET-JUNKBUSTER"></a>15.3. Internet Junkbuster</h2>

        <p>Abbiamo gi&agrave; analizzato il fatto che un proxy server come
        Squid possa ricorrere all&#39;utilizzo di diversi programmi esterni
        (helpers).</p>

        <p>Un ottimo sistema per proteggere la nostra privacy o la privacy
        aziendale &egrave; quello di affiancare a Squid un proxy server
        esterno che &egrave; stato disegnato per filtrare in modo
        intelligente e costruttivo i <em>cookies</em> ed i <em>banners
        pubblicitari</em>. Internet Junkbuster &egrave; un proxy server che
        pu&ograve; anche cooperare con Squid, le sue eccellenti
        potenzialit&agrave; sono descritte molto dettagliatamente nella
        documentazione on-line presso la URLs <a href=
        "http://www.junkbuster.com/" target=
        "_top">http://www.junkbuster.com/</a>.</p>

        <p>Anche sulla scorta di quanto abbiamo gi&agrave; scritto dobbiamo
        anche dire che la <em>degenerazione del business</em> sulla rete
        internet &egrave; sopratutto identificabile nella pornografia,
        senza certo esprimere pareri in merito, purtroppo, sempre
        pi&ugrave; spesso capita di doversi trovare di fronte a banner
        pubblicitari a sfondo pornografico che, molto spesso, vengono anche
        visualizzati se si accede a portali di carattere generalista.</p>

        <p>Cerchiamo ora di analizzare alcune delle motivazioni che
        spingono gli amministratori di rete a bloccare i sistemi AD, AD
        &egrave; l&#39;acronimo di Advertising:</p>

        <ul>
          <li>
            <p><em>Velocit&agrave;:</em> bloccando gli Advertising software
            la velocit&agrave; di connessione al WWW aumenta, il browser
            web non deve attendere inutilmente il caricamento dei banner
            pubblicitari</p>
          </li>

          <li>
            <p><em>Tranquillit&agrave;:</em> i banner pubblicitari sono
            disegnati appositamente per distrarre la nostra attenzione
            quindi sono in grado di distrarre l&#39;utente che naviga sul
            web</p>
          </li>

          <li>
            <p><em>Riservatezza:</em> il Cookies vengono utilizzati dalle
            AD Networks per tracciare e registrare il nostro movimento
            sulla rete internet, dunque vengono chiaramente utilizzati per
            invadere il campo della nostra privacy.</p>
          </li>
        </ul>

        <div class="SECT2">
          <hr />

          <h3 class="SECT2"><a name="SUBSEC-DEFINIZIONI-ED-ALBERO" id=
          "SUBSEC-DEFINIZIONI-ED-ALBERO"></a>15.3.1. Definizioni ed albero
          delle directory, file di configurazione</h3>

          <p><em>Junkbuster</em> &egrave; un proxy server che consente di
          <em>inibire la visualizzazione dei banners pubblicitari</em> e
          dei <em>cookies</em>, permette di anonimizzazione gli accessi
          provenienti dalla nostra LAN/WAN, l&#39;albero delle directory
          che portiamo come esempio &egrave; relativo ad un sistema
          <em>FreeBSD 4.9-STABLE</em></p>

          <ul>
            <li>
              <p><em>/usr/local/sbin/junkbuster</em></p>

              <p>&egrave; l&#39;eseguibile di internet Junkbuster</p>
            </li>

            <li>
              <p><em>/usr/local/etc/rc.d/junkbuster.sh</em></p>

              <p>&egrave; lo script di shell che consente di avviare il
              proxy server con l&#39;avviamento del sistema</p>
            </li>

            <li>
              <p><em>/usr/local/etc/junkbuster</em></p>

              <p>&egrave; la directory che contiene i files di
              configurazione</p>
            </li>
          </ul>

          <p>Provvediamo ad eseguire una configurazione ottimizzata del
          software editando i file di configurazione del di Junkbuster, che
          vengono generalmente forniti con la distribuzuine senza garanzia
          alcuna e sono:</p>

          <ul>
            <li>
              <p><em>/usr/local/etc/junkbuster/configfile</em></p>

              <p>&egrave; il file di configurazione principale che
              definisce i parametri di massima</p>
            </li>

            <li>
              <p><em>/usr/local/etc/junkbuster/blockfile</em></p>

              <p>&egrave; il file che contiene tutte le URL AD da
              bloccare</p>
            </li>

            <li>
              <p><em>/usr/local/etc/junkbuster/cookiefile</em></p>

              <p>&egrave; il file dove si inseriscono i siti fidati dai
              quali si accettano i cookies</p>
            </li>

            <li>
              <p><em>/usr/local/etc/junkbuster/forwardfile</em></p>

              <p>&egrave; il file dove si definisce il forward verso un
              proxy server esterno come squid</p>
            </li>
          </ul>

          <p>Nell&#39;area <a href="contrib" target="_top">/contrib</a>
          &egrave; possibile trovare alcuni esempi</p>
        </div>

        <div class="SECT2">
          <hr />

          <h3 class="SECT2"><a name="SUBSEC-VERIFICARE-IL-FUNZIONAMENTO"
          id="SUBSEC-VERIFICARE-IL-FUNZIONAMENTO"></a>15.3.2. Verificare il
          funzionamento di Junkbuster</h3>

          <p>Per avviare Junkbuster sar&agrave; sufficente eseguire il
          comando</p>

          <table border="0" bgcolor="#E0E0E0" width="100%">
            <tr>
              <td>
                <pre class="PROGRAMLISTING">
[root@portatilo root]# /usr/local/etc/rc.d/junkbuster.sh start<em> </em>
   
</pre>
              </td>
            </tr>
          </table>

          <p>ora potremmo configurare il nostro browser web preferito. Di
          seguito immaginiamo una configurazine tipica di chi naviga sul
          web utilizzando Mozilla.</p>

          <p>Avviare Mozilla, scegliere <em>edit</em>, <em>preference</em>,
          <em>advanced</em> e per finire utilizzare la sezione proxies
          procedendo alla configurazione manuale del proxy. Nei campi
          <em>HTTP-Proxy</em> e <em>Securiry Proxy</em> inserire il valore
          <em>127.0.0.1 porta 8000</em> (l&#39;impostazione di default di
          Junkbuster &egrave; quella di rimanere in ascolto di eventuali
          richieste sulla porta 8000).</p>

          <p>Per verificare la corretta installazione di Junkbuster
          utilizzare il browser web puntando al seguente indirizzo web
          <em>http://indirizzo-IP-Junkbuster/show-proxy-args</em>, se tutto
          &egrave; correttamente configurato potrete visualizzare le
          specifice di configurazione del prodotto.</p>

          <p>Per utilizzare il proxy Junkbuster con le funzionalit&agrave;
          di forwarding verso un&#39;altro proxy come Squid va solo editato
          il file <em>/usr/local/etc/junkbuster/forwardfile</em>, &egrave;
          anche possibile registrare in un file di log tutte le operazioni
          compiute da Junkbuster.</p>
        </div>
      </div>

      <div class="SECT1">
        <hr />

        <h2 class="SECT1"><a name="SEC-PRIVOXY" id="SEC-PRIVOXY"></a>15.4.
        Privoxy</h2>

        <p>Privoxy &egrave; un proxy server studiato per la navigazione sul
        web e fornisce delle funzionalit&agrave; avanzate per tutto quello
        che concerne il filtraggio dei contenuti e la gestione della
        privacy. Privoxy si occupa di verificare il contenuto delle pagine
        visitate, gestisce in maniera funzionale e manageriale i cookies,
        controlla gli accessi e rimuove ADS, banners, popups, pone rimedio
        anche ad altre tecniche utilizzate dai pubblicitari per fidelizzare
        utenti sulla rete internet.</p>

        <p>Privoxy &egrave; stato anche studiato per fornire la
        possibilit&agrave; di eseguire delle configurazioni molto
        flessibili, pu&ograve; essere utilizzato sia dagli utenti che dalle
        organizzazioni, questo proxy server &egrave; basato sul codice di
        Internet Junkbuster, di seguito vediamo alcune specifiche relative
        ad un sistema <em>FreeBSD 4.9-STABLE</em></p>

        <ul>
          <li>
            <p><em>/usr/local/sbin/privoxy</em></p>

            <p>&egrave; file eseguibile e pu&ograve; essere avviato con le
            seguenti opzioni</p>

            <ol type="1">
              <li>
                <p><em>privoxy --help</em> che consente di richiamare
                l&#39;help in linea</p>
              </li>

              <li>
                <p><em>privoxy --version</em> che consente di ottenere
                informazioni sulla versione in uso sul nostro sistema</p>
              </li>
            </ol>
          </li>
        </ul>

        <p>Se all&#39;avviamento del programma non viene specificato alcun
        file di configurazione, Privoxy tenta di avviare il file
        <em>config</em> che si trova nello stesso percorso del file
        eseguibile (nel nostro caso nella directory
        <em>/usr/local/sbin/</em>), nel caso si voglia utilizzare un
        percorso specifico per il file di configurazione, Privoxy
        dovr&agrave; essere avviato indicando il percorso specifico del
        file di configurazione.</p>

        <table border="0" bgcolor="#E0E0E0" width="100%">
          <tr>
            <td>
              <pre class="PROGRAMLISTING">
[root@battaglia root]# /usr/local/sbin/privoxy /usr/local/etc/privoxy/config 
May 12 09:50:45 Privoxy(134705152) Info: loading configuration file
&#39;/usr/local/etc/privoxy/config&#39;
  
</pre>
            </td>
          </tr>
        </table>

        <p>Per utilizzare le features di Privoxy il browser web necessita
        di una configurazione individuale che prevede l&#39;ascolto su
        localhost, porta <em>8180</em>, la configurazione di Privoxy
        pu&ograve; essere modificata editando alcuni dei files di
        configurazione.</p>

        <div class="SECT2">
          <hr />

          <h3 class="SECT2"><a name=
          "SUBSEC-FILES-DI-CONFIGURAZIONE-DI-PRIVOXY" id=
          "SUBSEC-FILES-DI-CONFIGURAZIONE-DI-PRIVOXY"></a>15.4.1. files di
          configurazione di Privoxy</h3>

          <p>Privoxy pu&ograve; essere configurato utilizzando diversi file
          di configurazione, di seguito proponiamo l&#39;elenco
          completo:</p>

          <table border="0" bgcolor="#E0E0E0" width="100%">
            <tr>
              <td>
                <pre class="PROGRAMLISTING">
[root@battaglia root]# ls -l /usr/local/etc/privoxy/ 
total 84 
-r--r--r--  1 root  wheel  30422 May  9 08:59 config 
-r--r--r--  1 root  wheel  28456 May  9 08:42 default.action 
-r--r--r--  1 root  wheel  20005 May  9 08:42 default.filter 
drwxr-xr-x  2 root  wheel   1024 May  9 08:42 templates 
-r--r--r--  1 root  wheel   2998 May  9 08:42 trust 
[root@battaglia root]# 
   
</pre>
              </td>
            </tr>
          </table>

          <p><em>config</em> &egrave; il file di configurazione principale,
          <em>default.filter</em> e <em>default.action</em> vengono
          utilizzati per definire le eccezioni alle regole principali che
          vengono utilizzate come regole base di Privoxy. Nel file
          <em>config</em> viene definita la directory che conterr&agrave; i
          files di configurazione, la directory che conterr&agrave; il file
          dei logs, vengono anche definiti gli <em>action.file</em>, il
          <em>filter.file</em>, il <em>jarfile</em> (per la gestione dei
          cookies).</p>

          <p>Oltre all&#39;indirizzo IP e alla porta sulla quale rimane in
          ascolto il proxy server, pu&ograve; anche essere definito il
          riferimento dell&#39;amministratore di sistema, il manuale utente
          e le informazioni a riguardo delle URL&#39;s che vengono
          filtrate. nel file <em>config</em> file viene anche definita la
          direttiva di forward, direttiva con la quale si redirigono le
          richieste, dopo averne filtrato il contenuto, verso il proxy
          server principale che di solito viene installato sulla stessa
          macchina.</p>

          <p>Nel file <em>default.action</em> viene inclusa una sezione
          denominata &quot;<em>sites suffer from a bug in PHP</em>&quot;,
          in questa sezione dovremo inserire i portali internet realizzati
          in phpNuke o con altri CMS che utilizzano il PHP come linguaggio
          di scripting.</p>
        </div>
      </div>

      <div class="SECT1">
        <hr />

        <h2 class="SECT1"><a name="SEC-ADZAPPING" id=
        "SEC-ADZAPPING"></a>15.5. Ad Zapping con Squid</h2>

        <p>Ad Zapping &egrave; un <a href="#SEC-REDIRECT">redirector</a>
        che intercetta e ridireziona gli advertising, i page counters e
        molti altri bugs propri del web. Questo redirector comporta anche
        dei benefici a riguardo del risparmio della banda ed inoltre
        &egrave; un programma piuttosto semplice da installare.</p>

        <p>Ad Zapper &egrave; fondamentalmente uno script che pu&ograve;
        essere integrato facilmente con il Squid, il suo funzionamento si
        basa su un algoritmo che contiene alcune espressioni regolari
        (<em>regex</em>), queste espressioni sono incluse all&#39;interno
        dello script stesso.</p>

        <div class="SECT2">
          <hr />

          <h3 class="SECT2"><a name="SUBSEC-DIFF-JUNKBUSTER-PRIVOXY" id=
          "SUBSEC-DIFF-JUNKBUSTER-PRIVOXY"></a>15.5.1. Differenze con
          Junkbuster e Privoxy</h3>

          <p>Come abbiamo visto in precedenza, Junkbuster e Privoxy sono
          dei proxy servers specializzati nel mediare il filtraggio, per
          funzionare questi proxy devono essere utilizzati nell&#39;ambito
          di una cache gerarchica, in questo ambito possono essere definiti
          come <em>parent</em> o <em>sibling</em>.</p>

          <p>Tutte le richieste effettuate da parte dei client vengono
          dirette a Junkbuster o a Privoxy, questo fatto comporta un
          discreto livello di complessit&agrave; della configurazione e un
          certo rallentamento sulla rete, in quanto la richiesta, dopo
          essere stata purgata dal proxy filtro, dovr&agrave; essere
          inoltrata dal sistema <em>parent</em> a Squid.</p>

          <p>Se Junkbuster e Privoxy sono in grado di filtrare anche i
          cookies e le pagine web che contengono gli advertising, Ad Zapper
          &egrave; solo in grado di eliminare gli advertising (ads).</p>
        </div>

        <div class="SECT2">
          <hr />

          <h3 class="SECT2"><a name="SUBSEC-VANTAGGI-RIDIREZIONE" id=
          "SUBSEC-VANTAGGI-RIDIREZIONE"></a>15.5.2. Vantaggi della
          ridirezione</h3>

          <p>Abbiamo gi&agrave; <a href="#SEC-REDIRECT">accennato</a> al
          fatto che una delle features pi&ugrave; interessanti offerte da
          Squid &egrave; il ricorso al sistema di ridirezione. I programmi
          esterni che eseguono materialmente la ridirezione, leggono le
          informazioni che vengono richieste dagli utenti e le riscrivono
          inviandole a un percorso diverso. Se viene attivata l&#39;opzione
          <em>redirect_program</em>, Squid consulter&agrave; il redirector
          che si far&agrave; carico di intercettare gli ads ridirezionando
          e sostituendo il codice vietato. Il TAG <em>redirect_program</em>
          &egrave; facilmente attivabile modificando il file di
          configurazione <em>squid.conf</em></p>

          <table border="0" bgcolor="#E0E0E0" width="100%">
            <tr>
              <td>
                <pre class="PROGRAMLISTING">
redirect_program /usr/local/libexec/squid_redirect
   
</pre>
              </td>
            </tr>
          </table>

          <p>Il path dovr&agrave; essere rimpiazzato con il percorso
          dell&#39;applicazione che utilizzeremo per la ridirezione delle
          richieste</p>
        </div>

        <div class="SECT2">
          <hr />

          <h3 class="SECT2"><a name="SUBSEC-PREREQUISITI-ADZAP" id=
          "SUBSEC-PREREQUISITI-ADZAP"></a>15.5.3. Prerequisiti di Ad
          Zapping</h3>

          <p>I prerequisiti di sistema richiesti da Ad Zapping sono</p>

          <ul>
            <li>
              <p>Linguaggio Perl (<a href="http://www.cpan.org/" target=
              "_top">http://www.cpan.org/</a>)</p>
            </li>
          </ul>

          <p>L&#39;installazione di Ad Zapping &egrave; piuttosto semplice
          in quanto si provvede all&#39;installazione dello script e si
          aggiunge nel file di configurazione di Squid il TAG
          <em>redirect_program</em>. Successivamente sar&agrave; necessario
          riavviare il proxy per attivare l&#39;Ad Zapping. Esistono
          diverse versioni gi&agrave; customizzate dello script Ad Zapping
          per diversi Sistemi Operativi</p>

          <ul>
            <li>
              <p>FreeBSD - &egrave; possibile installare il ports
              dell&#39;applicazione</p>

              <p>maggiori informazioni relative al ports alla URLs <a href=
              "http://www.freebsd.org/cgi/url.cgi?ports/www/adzap/pkg-descr"
                 target=
                 "_top">http://www.freebsd.org/cgi/url.cgi?ports/www/adzap/pkg-descr</a></p>
            </li>

            <li>
              <p>NetBSD - &egrave; possibile installare il package dello
              zapper</p>

              <p>maggiori informazioni relative al package alla URLs
              <a href=
              "ftp://ftp.netbsd.org/pub/NetBSD/packages/pkgsrc/www/adzap/README.html"
                 target=
                 "_top">ftp://ftp.netbsd.org/pub/NetBSD/packages/pkgsrc/www/adzap/README.html</a></p>
            </li>

            <li>
              <p>GNU Linux/Debian - &egrave; possibile installare il
              package <em>deb</em> dello zapper</p>
            </li>
          </ul>

          <p>Lo script originale pu&ograve; essere prelevato dalla URLs del
          progetto <a href="http://adzapper.sourceforge.net/#download"
          target="_top">http://adzapper.sourceforge.net/#download</a></p>
        </div>

        <div class="SECT2">
          <hr />

          <h3 class="SECT2"><a name="SUBSEC-INSTALLARE-AD-ZAPPING" id=
          "SUBSEC-INSTALLARE-AD-ZAPPING"></a>15.5.4. installare Ad
          Zapping</h3>

          <p>In questo caso di studio proponiamo l&#39;installazione dello
          script Ad Zapping sul Sistema Operativo FreeBSD, la procedura
          &egrave; piuttosto semplice. Digitiamo i seguenti comandi nella
          directory contenente il ports di adzap</p>

          <table border="0" bgcolor="#E0E0E0" width="100%">
            <tr>
              <td>
                <pre class="PROGRAMLISTING">
root@ns:/usr/ports/www/adzap&gt; make install clean
   
</pre>
              </td>
            </tr>
          </table>

          <p>Ad Zapping &egrave; ora installato, per attivare la
          ridirezione &egrave; necessario editare il file di configurazione
          <em>squid.conf</em> ed inserire lo script adzap utilizzando il
          TAG <em>redirect_program</em>. Di seguito vediamo gli script che
          ha provveduto ad installare la procedura di configurazione</p>

          <table border="0" bgcolor="#E0E0E0" width="100%">
            <tr>
              <td>
                <pre class="PROGRAMLISTING">
root@ns:/usr/ports/www/adzap&gt; cd /usr/local/libexec
root@ns:/usr/local/libexec&gt; ls
total -------
drwxr-xr-x 9 root wheel 512 Feb 11 11:29 ./
drwxr-xr-x 7 root wheel 512 Feb 5 06:27 ../
-r-xr-xr-x 1 root wheel 2551 Feb 11 11:29 adzap*
drwxr-xr-x 2 root wheel 512 Feb 3 06:14 squid/
-r-xr-xr-x 1 root wheel 113798 Feb 11 11:29 squid_redirect*
   
</pre>
              </td>
            </tr>
          </table>

          <p>Il programma di installazione e configurazione ha generato 2
          files, <em>adzap</em> e <em>squid_redirect</em>. Per avviare
          correttamente la procedura di ridirezione modificheremo il file
          di configurazione <em>squid.conf</em></p>

          <table border="0" bgcolor="#E0E0E0" width="100%">
            <tr>
              <td>
                <pre class="PROGRAMLISTING">
redirect_program /usr/local/libexec/squid_redirect
redirect_children 5
   
</pre>
              </td>
            </tr>
          </table>

          <p>per rendere operativa la modifica ed iniziare ad utilizzare il
          redirector</p>

          <table border="0" bgcolor="#E0E0E0" width="100%">
            <tr>
              <td>
                <pre class="PROGRAMLISTING">
root@ns:/root&gt; squid -k reconfigure
   
</pre>
              </td>
            </tr>
          </table>

          <p>da notare che il file</p>

          <table border="0" bgcolor="#E0E0E0" width="100%">
            <tr>
              <td>
                <pre class="PROGRAMLISTING">
/usr/local/libexec/adzap 
   
</pre>
              </td>
            </tr>
          </table>

          <p>contiene tutte le impostazioni necessarie al corretto
          funzionamento di Ad Zapper, tra le variabili citiamo</p>

          <table border="0" bgcolor="#E0E0E0" width="100%">
            <tr>
              <td>
                <pre class="PROGRAMLISTING">
ZAP_BASE=http://adzapper.sourceforge.net/zaps 
   
</pre>
              </td>
            </tr>
          </table>

          <p>con questa variabile &egrave; possibile definire un percorso
          di un server web, questo consente di visualizzare dei messaggi o
          delle immagini in sostituzione degli advertising. Se si esegue un
          web server sulla stessa macchina dove &egrave; in funzione Squid
          (consigliato), si proceder&agrave; a copiare i files
          <em>*.{html,js,gif}</em> dal percorso
          <em>${PREFIX}/share/examples/adzap</em> direttamente nella
          <em>DirectoryRoot</em> del webserver. Successivamente
          modificheremo la variabile <em>ZAP_BASE</em> contenuta nel file
          di configurazione <em>/usr/local/libexec/adzap</em></p>

          <table border="0" bgcolor="#E0E0E0" width="100%">
            <tr>
              <td>
                <pre class="PROGRAMLISTING">
root@ns:/usr/local/libexec&gt; cd /usr/local/www/data-dist/
root@ns:/usr/local/www/data-dist&gt; mkdir zaps
root@ns:/usr/local/www/data-dist&gt; cd /usr/local/share/examples/adzap/
root@ns:/usr/local/share/examples/adzap&gt; cp * /usr/local/www/data-dist/zaps/
   
</pre>
              </td>
            </tr>
          </table>

          <p>Ecco la variabile modificatata</p>

          <table border="0" bgcolor="#E0E0E0" width="100%">
            <tr>
              <td>
                <pre class="PROGRAMLISTING">
ZAP_BASE=http://127.0.0.1/zaps/
   
</pre>
              </td>
            </tr>
          </table>
        </div>
      </div>

      <div class="SECT1">
        <hr />

        <h2 class="SECT1"><a name="SEC-WEBCACHING-ANONIMO" id=
        "SEC-WEBCACHING-ANONIMO"></a>15.6. Fornire agli utenti un servizio
        di Web Caching anonimo</h2>

        <p>Sulla rete internet &egrave; anche possibile trovare dei sistemi
        di web cache che consentono agli utenti di rendere anonima la loro
        navigazione e questi sistemi naturalmente utilizzano Squid.
        Possiamo installare Squid con le funzionalit&agrave; di proxy
        &quot;anonimizzante&quot; impostando le seguenti righe nel file
        configurazione <em>squid.conf</em></p>

        <table border="0" bgcolor="#E0E0E0" width="100%">
          <tr>
            <td>
              <pre class="PROGRAMLISTING">
cache_store_log none            <em>#non loggare il contenuto della cache</em>
client_netmask 0.0.0.0          <em>#tutti gli ip eventualmente loggati</em> vengono messi a 0.0.0.0
http_access allow all           <em>#tutti possono accedere al proxy</em>
forwarded_for off               <em>#disabilita l&#39;identita&#39; del richiedente</em>
                                <em>#funzionalit&agrave; che abbiamo gi&agrave; trattato</em>
                                <em>#questo &egrave; l&#39;anonymizer</em>
client_db off                   <em>#disabilita le statistiche sulle</em> 
                                <em>#connessioni effettuate dai client</em>
  
</pre>
            </td>
          </tr>
        </table>

        <p>le impostazioni che abbiamo appena analizzato consentono a Squid
        Proxy Server di nascondere sia l&#39;indirizzo IP del sistema da
        cui parte la connessione HTTP, che il relativo logging delle
        connessioni dirette al nostro proxy server (tutti gli indirizzi IP
        che utilizzano Squid sono pari a <em>0.0.0.0</em>). Maggiori
        informazioni su come installare altri applicativi server side come
        lo <em>stunnel</em> che consentiranno ai nostri utenti
        un&#39;accesso sicuro e crittografato al proxy server Squid possono
        essere reperite direttamente alla URL: <a href=
        "http://www.autistici.org/faqomatic/fom-serve/cache/9.html" target=
        "_top">http://www.autistici.org/faqomatic/fom-serve/cache/9.html</a>.</p>
      </div>
    </div>

    <div class="CHAPTER">
      <hr />

      <h1><a name="CHA-COMUNICARE-CON-ALTRI-PROXY-SERVER" id=
      "CHA-COMUNICARE-CON-ALTRI-PROXY-SERVER"></a>Capitolo 16. Comunicare
      con altri proxy server</h1>

      <div class="SECT1">
        <h2 class="SECT1"><a name="SEC-PREAMBOLO-GERARCHIE" id=
        "SEC-PREAMBOLO-GERARCHIE"></a>16.1. Preambolo</h2>

        <p>Abbiamo gi&agrave; visto in precedenza che Squid fa suo il
        concetto di cache gerarchiche grazie al supporto per il protocollo
        <a href="#SEC-INTERNET-CACHE-PROTOCOL">ICP</a> (Internet Cache
        Protocol). Concettualmente sappiamo che l&#39;apparato di webcache,
        che non dispone delle pagine richieste, si collega direttamente con
        il server web di origine ove risiedono le pagine.</p>

        <p>Neighbours e Peer sono dei sinonimi che identificano diversi
        sistemi di webcache in relazione tra loro, i termini parent e
        sibling definiscono il livello di parentela tra le cache. In una
        cache gerarchica, il proxy pu&ograve; comunicare con altri proxy
        server, questa situazione pu&ograve; rendere pi&ugrave; veloce
        l&#39;accesso alle pagine web richieste dagli utenti, riducendo sia
        il traffico HTTP che il relativo tempo d&#39;attesa per
        l&#39;accesso alla rete da parte degli utenti.</p>
      </div>

      <div class="SECT1">
        <hr />

        <h2 class="SECT1"><a name="SEC-ESEMPI-RELAZIONI-WEBCACHE" id=
        "SEC-ESEMPI-RELAZIONI-WEBCACHE"></a>16.2. Esempi e relazioni tra
        webcache</h2>

        <p>Dei sistemi in relazione di sibling<a name="AEN4546" href=
        "#FTN.AEN4546" id="AEN4546">[24]</a> richiedono solamente gli
        oggetti presenti nella cache e non eseguono il forward delle cache
        MISS<a name="AEN4548" href="#FTN.AEN4548" id="AEN4548">[25]</a>. In
        questo esempio configureremo alcuni sistemi proxy in
        modalit&agrave; sibling, modalit&agrave; attraverso la quale uno
        dei proxy pu&ograve; essere configurato come fratello germano di un
        altro sistema di webcache. Organizzazioni che sono in stretto
        rapporto commerciale possono configurare i loro sistemi di webcache
        con questa modalit&agrave;. Il TAG <em>cache_peer</em> consente di
        specificare i proxy server con i quali ci si vuole mettere in
        relazione</p>

        <table border="0" bgcolor="#E0E0E0" width="100%">
          <tr>
            <td>
              <pre class="PROGRAMLISTING">
cache_peer proxy.dominio1.com parent 3128 3130 
  
</pre>
            </td>
          </tr>
        </table>

        <p>il TAG <em>cache_peer</em> indica che la nostra webcache
        interrogher&agrave; il server padre <em>proxy.dominio1.com</em>
        utilizzando il sistema di relazione parent (padre). Squid comunica
        con il proxy <em>parent</em> utilizzando la porta 3128 per il
        protocollo HTTP e le informazioni trasmesse con il protocollo ICP
        vengono scambiate tramite la porta 3130</p>

        <table border="0" bgcolor="#E0E0E0" width="100%">
          <tr>
            <td>
              <pre class="PROGRAMLISTING">
cache_peer proxy.dominio2.com sibling 8080 3130 
  
</pre>
            </td>
          </tr>
        </table>

        <p>In questo caso il TAG <em>cache_peer</em> si riferisce ad un
        tipo di configurazione che definisce l&#39;host
        <em>proxy.dominio2.com</em> come proxy in relazione sibling
        (fratello germano) che rimane in ascolto sulla porta 8080 per
        quello che concerne il protocollo HTTP e scambia le informazioni
        relative al protocollo ICP utilizzando la porta 3130.</p>

        <p>Il Proxy Server Squid pu&ograve; essere configurato per
        effettuare richieste contemporanee a diversi sistemi di webcache,
        siano esse in modalit&agrave; parent che sibling, nel caso non si
        desideri utilizzare alcuna cache in rapporto di peering con la
        nostra sar&agrave; necessario eliminare TAG
        <em>cache_peer</em>.</p>

        <p>Nella maggior parte dei casi la configurazione di una cache
        gerarchica &egrave; piuttosto difficoltosa e pu&ograve; anche
        divenire un punto critico, sopratutto se trattiamo gerarchie di
        livello nazionale o internazionale. In una WAN l&#39;utilizzo delle
        cache gerarchie e del protocollo ICP pu&ograve; divenire uno
        strumento potente e flessibile per la gestione delle ridondanze e
        della sicurezza. Nell&#39;esempio in calce, al fine di ottimizzare
        al massimo i tempi di risposta, Squid prima accede alla cache
        parent ed esegue una semplice query con la quale verifica
        l&#39;esistenza dell&#39;oggetto<a name="AEN4565" href=
        "#FTN.AEN4565" id="AEN4565">[26]</a> richiesto. Nel caso ottenga
        una HIT<a name="AEN4567" href="#FTN.AEN4567" id="AEN4567">[27]</a>
        preleva l&#39;oggetto dalla parent cache, se ottiene un MISS scarta
        la richiesta, il TAG <em>default no-query</em> consente di scartare
        una MISS lasciando al proxy il compito di recuperare l&#39;oggetto
        dal server web di origine.</p>

        <table border="0" bgcolor="#E0E0E0" width="100%">
          <tr>
            <td>
              <pre class="PROGRAMLISTING">
cache_peer proxy.domain.com parent 3128 3130 default no-query
prefer_direct off 
  
</pre>
            </td>
          </tr>
        </table>

        <p>nel caso si disponga di una cache installata presso il proprio
        ISP (Internet Service Provider) &egrave; anche possibile
        configurare Squid in modalit&agrave; <em>parent</em> per ridurre i
        tempi di consultazione. Nel caso si disponga di una linea dedicata
        con tariffazione a consumo sar&agrave; quindi possibile occupare
        una minore quantit&agrave; di banda e ridurre i costi.</p>

        <p>Per qualsiasi altra informazione sulle cache gerarchiche si
        faccia riferimento al documento <em>Configuring Hierarchical Squid
        Caches</em> di Duane Wessels disponibile alla URLs: <a href=
        "http://www.squid-cache.org/Doc/Hierarchy-Tutorial/" target=
        "_top">http://www.squid-cache.org/Doc/Hierarchy-Tutorial/</a>.</p>
      </div>

      <div class="SECT1">
        <hr />

        <h2 class="SECT1"><a name="SEC-INFO-IRCACHE" id=
        "SEC-INFO-IRCACHE"></a>16.3. Alcune informazioni su IRCACHE</h2>

        <p>IRCACHE &egrave; un progetto di NLANR WebCaching, il progetto
        &egrave; stato originalmente costituito con un fondo dal National
        Science Foundation (<a href="http://www.nsf.gov/" target=
        "_top">http://www.nsf.gov/</a>), la direzione del progetto &egrave;
        stata affidata a Computer and Information Sciences and Engineering
        (<a href="http://www.cise.nsf.gov/" target=
        "_top">http://www.cise.nsf.gov/</a>). A partire dal 1996 e sino al
        2000, il progetto IRCache &egrave; stato amministrato
        dall&#39;Universit&agrave; di California di San Diego (<a href=
        "http://www.ucsd.edu/" target="_top">http://www.ucsd.edu/</a>) in
        collaborazione con la San Diego Supercomputer Center (<a href=
        "http://www.sdsc.edu/" target="_top">http://www.sdsc.edu/</a>) ed
        il National Laboratory for Applied Network Research (<a href=
        "http://www.nlanr.net/" target="_top">http://www.nlanr.net/</a>).
        Le FAQ relative a questo progetto possono essere reperite alla URLs
        <a href="http://www.ircache.net/FAQ/" target=
        "_top">http://www.ircache.net/FAQ/</a>.</p>

        <p>Una gerarchia di web cache come quella di NLANR pu&ograve;
        fornire una fonte iniziale per relazionare il nostro Sistema di
        webcache con un&#39;altro proxy sia utilizzando la modalit&agrave;
        sibling che la modalit&agrave; parent. Unire il nostro Sistema di
        web cache con un Sistema globale di NLANR migliorer&agrave; le
        prestazioni generali del nostro proxy server Squid. Abilitando
        alcune opzioni nel file <em>squid.conf</em> potremo registrare la
        nostra cache all&#39;interno del servizio NLANR</p>

        <table border="0" bgcolor="#E0E0E0" width="100%">
          <tr>
            <td>
              <pre class="PROGRAMLISTING">
cache_announce 24
announce_to sd.cache.nlanr.net:3131
  
</pre>
            </td>
          </tr>
        </table>

        <p>annunciare la propria cache non &egrave; come unirsi ad una
        gerarchia NLANR, possiamo unirci ad una gerarchia senza registrarsi
        come servizio di cache NLANR. Per trovare le cache adiacenti alle
        nostre appartenenti ed appartenenti NLANR &egrave; stato istituito
        il database NLANR (<a href="http://www.ircache.net/Tracker/"
        target="_top">http://www.ircache.net/Tracker/</a>), il motore di
        ricerca pu&ograve; essere interrogato alla URLs <a href=
        "http://www.ircache.net/Tracker/search.html" target=
        "_top">http://www.ircache.net/Tracker/search.html</a>.</p>
      </div>

      <div class="SECT1">
        <hr />

        <h2 class="SECT1"><a name="SEC-GARR" id="SEC-GARR"></a>16.4. Alcune
        informazioni sul Servizio di Cache Nazionale GARR</h2>

        <p>La Rete GARR, il cui acronimo significa Gestione Amplimento Rete
        Ricerca &egrave; composta da tutte le entit&agrave; che
        rappresentano la comunit&agrave; accademica e della ricerca
        scientifica in Italia, le attivit&agrave; della Rete GARR sono
        gestite dal Consortium GARR e in modo operativo dalla Direzione del
        Consortium GARR, maggiori informazioni sui compiti istituzionali
        del Consortium GARR possono essere reperiti presso la URL <a href=
        "http://www.garr.it/checosa/garr-b-checosa.shtml" target=
        "_top">http://www.garr.it/checosa/garr-b-checosa.shtml</a>.</p>

        <p>Il GARR offre il servizio di Cache Nazionale GARR, questo tipo
        di servizio &egrave; rivolto unicamente ai gestori delle cache
        Dipartimentali o d&#39;Ente. L&#39;obiettivo &egrave; quello di
        aiutare gli amministratori dei sistemi di web cache, o anche di
        coloro che hanno intenzione di creare questo tipo di servizio, a
        partecipare alla gerarchia nazionale GARR configurando le proprie
        cache per l&#39;utilizzo dei server centrali messi a disposizione
        dal GARR presso i 4 punti del backbone nazionale. I server si
        trovano nella stessa sede del POP GARRB, e dunque di questi sono
        particolarmente vicini ai link nazionali ed internazionali. Sono
        disponibili al peering verso le cache Dipartimentali o d&#39;Ente 4
        server centrali, si tratta di sistemi NetCache C720 (<a href=
        "http://www.netapp.com/products/netcache/" target=
        "_top">http://www.netapp.com/products/netcache/</a>), con circa 72G
        utili per il caching. Per utilizzare i server del servizio
        nazionale &egrave; sufficiente aggiungere le seguenti righe nel
        file di configurazione <em>squid.conf</em></p>

        <table border="0" bgcolor="#E0E0E0" width="100%">
          <tr>
            <td>
              <pre class="PROGRAMLISTING">
cache_peer        <em>XX</em>.cache.garr.it parent 3128 3130 
cache_peer_domain <em>XX</em>.cache.garr.it !.garr.it !.akamai.net !.akamaitech.net
  
</pre>
            </td>
          </tr>
        </table>

        <p>dove <em>XX</em> sta ad indicare una delle seguenti sigle</p>

        <table border="0" bgcolor="#E0E0E0" width="100%">
          <tr>
            <td>
              <pre class="PROGRAMLISTING">
mi - Milano  (dedicata agli enti afferenti al POP di Milano)
bo - Bologna (dedicata agli enti afferenti al POP di Bologna)
na - Napoli  (dedicata agli enti afferenti al POP di Napoli)
rm - Roma    (dedicata agli enti afferenti al POP di Roma)
  
</pre>
            </td>
          </tr>
        </table>

        <p>il TAG <em>cache_peer_domain</em> prevede l&#39;esclusione (!)
        del ricorso alla gerarchia per il dominio <em>garr.it</em> a cui
        appartengono i server FTP dei mirror GARR, e per il dominio
        <em>akamai.net</em> (rete del gestore di CDN che ha dislocato i
        propri server in sede POP GARRB). Maggiori informazioni a riguardo
        alla URLs <a href="http://www.cache.garr.it/guida.html" target=
        "_top">http://www.cache.garr.it/guida.html</a>.</p>
      </div>
    </div>

    <div class="CHAPTER">
      <hr />

      <h1><a name="CHA-PROXY-TRASPARENTE" id=
      "CHA-PROXY-TRASPARENTE"></a>Capitolo 17. Proxy trasparente</h1>

      <div class="SECT1">
        <h2 class="SECT1"><a name="SEC-PREAMBOLO-TRANSPARENT-PROXY" id=
        "SEC-PREAMBOLO-TRANSPARENT-PROXY"></a>17.1. Preambolo</h2>

        <p>Prima di iniziare la trattazione di questo argomento, &egrave;
        nostra intenzione schematizzare il funzionamento del protocollo
        TCP/IP, lo schema che riportiamo di seguito aiuter&agrave; il
        lettore a comprendere gli stati di rete nei quali opera il proxy
        trasparente.</p>

        <p><img src="images/livelliosi.png" alt=
        "" /></p>L&#39;<em>interception caching</em> &egrave; un acronimo
        di proxy trasparente. L&#39;<em>interception caching</em> inizia a
        lavorare sul livello di trasporto di rete ove qualsiasi pacchetto
        IP viene routato fra i vari nodi. Un router o uno switch di livello
        quattro pu&ograve; riconoscere i pacchetti <em>HTTP</em> e deviarli
        verso Squid. Attualmente esistono quattro tipi di intercettamento
        <br />
        <br />

        <ol type="1">
          <li>
            <p>inline cache o switch di livello sette</p>
          </li>

          <li>
            <p>switch di livello quattro</p>
          </li>

          <li>
            <p>WCCP (Web Cache Coordination Protocol)</p>
          </li>

          <li>
            <p>politiche di routing</p>
          </li>
        </ol>

        <p>uno dei problemi pi&ugrave; importanti che oggi deve risolvere
        un amministratore di rete &egrave; quello di trovare un sistema
        automatico per la configurazione del proxy server sulle macchine
        degli utenti. L&#39;<em>interception caching</em> &egrave; una
        delle tecniche che viene maggiormente utilizzata unitamente con il
        protocollo <em>WPAD</em> <em>(</em>Web Proxy Autodiscovery
        Protocol) che tratteremo <a href=
        "#SEC-WPAD-PROTOCOL">dettagliatamente</a> nel seguito di questo
        libro. Intercettare le richieste dirette alla porta 80, solitamente
        utilizzata dai server <em>HTTP</em>, per redirigerle verso Squid,
        pu&ograve; aiutare l&#39;amministratore a tenere sotto controllo
        l&#39;utilizzo della risorse web prevendo eventuali abusi nel
        rispetto della policy e degli standard adottati all&#39;interno
        dell&#39;organizzazione. La tecnica del proxy trasparente comporta
        diversi benefici come il funzionamento automatico con qualsiasi
        tipo di browser web, ma introduce anche diversi livelli di
        complessit&agrave; ed alcuni <em>single point of failure</em>. Di
        seguito analizzeremo molto dettagliatamente le <em>inline</em>
        cache, il protocollo <em>WCCP</em> concludendo con le politiche di
        routing utilizzando i router della Cisco System, sar&agrave;
        compito del lettore valutare la soluzione migliore per risolvere le
        proprie esigenze.</p>
      </div>

      <div class="SECT1">
        <hr />

        <h2 class="SECT1"><a name="SEC-CONCETTO-IN-LINE-CACHE" id=
        "SEC-CONCETTO-IN-LINE-CACHE"></a>17.2. Concetto di inline
        cache</h2>

        <p>Una cache di questo tipo combina in un unico apparato sia il
        <em>webcaching</em> che le tecniche di routing e/o di bridging,
        questo apparato pu&ograve; essere configurato con due o pi&ugrave;
        interfaccie di rete, il classico esempio di <em>inline</em> cache
        &egrave; una macchina UNIX&reg; sulla quale viene eseguito Squid,
        questo tipo di device viene posizionato sul percorso di rete per
        consentirgli di catturare il traffico <em>HTTP</em> e
        ridirezionarlo verso Squid. Non sono molti gli apparati dedicati
        disegnati per svolgere questo compito perch&egrave; una
        <em>inline</em> cache pu&ograve; rappresentare un <em>single point
        of failure</em>. Molti produttori infatti raccomandano di
        utilizzare sistemi sviluppati da terze parti come gli switch di
        livello quattro che garantiscono un maggior livello di
        disponibilit&agrave; del servizio. Possiamo progettare una
        <em>inline</em> cache a basso costo utilizzando dei semplici PC che
        vengono equipaggiati con GNU Linux o FreeBSD e Squid proxy server.
        Qualsiasi sistema UNIX&reg; &egrave; in grado di eseguire il
        routing tra diverse interfaccie di rete cos&igrave; come la
        ridizione del traffico, ma se Squid va in errore ne
        risentir&agrave; tutto il traffico web che attraversa quel percorso
        della rete.</p>

        <p>In dettaglio possiamo affermare che il transparent proxying
        &egrave; un termine piuttosto comune che descrive una metodologia
        con la quale si posiziona un gateway tra la zona militarizzata (MZ)
        e la rete degli utenti o zona militarizzata di secondo livello
        (MZ-L2) per controllare, filtrare e redirezionare il traffico
        <em>HTTP</em>.</p>

        <p><img src="images/transparent.png" alt="" /></p>La rete IP
        pubblica &egrave; la rete di propriet&agrave; dell&#39;ISP
        (Internet Service Provider), il router &egrave; la porta di accesso
        che delimita la rete pubblica dal nostro segmento di rete pubblico.
        Nella <em>DMZ</em> vengono mappati gli indirizzi pubblici, nella
        <em>MZ</em> gli indirizzi IP sono quelli riservati alle reti
        private. Con questo sistema tutti gli accessi di tipo <em>www</em>
        verranno convogliati al gateway, il Transparent Proxy funziona
        unicamente per le richieste di tipo <em>HTTP</em>. E&#39; possibile
        paragonare la tecnica del transparent proxy ad uno switch di
        livello sette. Si tratta in effetti di una apparecchiatura molto
        sofisticata che opera al livello sette del modello OSI, quindi
        lavora sullo strato delle applicazioni. Per operare correttamente
        questo tipo di apparati hanno la necessit&agrave; di tradurre gli
        indirizzi internet e di interpretare il traffico IP. Il protocollo
        di trasporto TCP opera per&ograve; sul quarto livello del modello
        OSI. Uno switch di livello sette fornisce le stesse opzioni che uno
        switch di livello quattro offre solo addizionalmente. Nel caso
        della tecnica del transparent proxy, Squid si istalla su una
        macchina che opera da gateway, questo tipo di configurazione viene
        utilizzata nelle grandi LAN/WAN dove il numero dei PC client
        &egrave; molto elevato. I pacchetti inviati dai PC client che fanno
        richiesta del protocollo <em>HTTP</em> vengono ridirezionati dal
        gateway o dallo switch di livello quattro, che nel caso specifico
        &egrave; appunto incluso nella nostra macchina Linux o nel nostro
        sistema BSD dove viene eseguito Squid. Il processo di ridirezione
        dei pacchetti non viene effettuato direttamente dal proxy server ma
        viene processato da una applicazione che si occupa di gestire le
        regole del traffico IP, questo tipo di applicativo consente di
        filtrare e manipolare i pacchetti. Quando il Kernel del sistema
        operativo riceve i pacchetti diretti verso la porta 80 verifica le
        regole di ridirezione ed aggiusta il pacchetto ricevuto cambiandone
        la porta di destinazione. Se Squid &egrave; in ascolto sulla porta
        3128 il traffico IP verr&agrave; intercettato e rediretto verso la
        porta 3128 dove normalmente rimane in ascolto Squid. Per effettuare
        il setup del proxy trasparente &egrave; necessario effettuare due
        attivit&agrave;
        <br />
        <br />

        <ol type="1">
          <li>
            <p>configurare l&#39;applicazione che esegue il filtro dei
            pacchetti</p>
          </li>

          <li>
            <p>configurare Squid</p>
          </li>
        </ol>

        <p>mostriamo ora uno schema esplicativo con il quale illustreremo
        il funzionamento switch di livello sette</p>

        <p><img src="images/trasparente.png" alt="" /></p>tutte le
        richieste provenienti dalla rete <em>mz-l2</em> e dirette verso la
        porta 80 dei sistemi che sono oltre il segmento di rete
        <em>mz</em>, verranno manipolate dalla applicazione che esegue il
        filtro dei pacchetti e che lavora sia a livello tre che a livello
        quattro della pila OSI, questi pacchetti vengono ridirezionati ed
        inviati alla porta 3128 dove normalmente rimane in ascolto Squid
        che lavora invece al livello sette, ovvero al livello delle
        applicazioni della pila OSI.
        <br />
        <br />

        <div class="SECT2">
          <hr />

          <h3 class="SECT2"><a name="SUBSEC-APP-ESEGUE-FILTRO-PACCHETTI"
          id="SUBSEC-APP-ESEGUE-FILTRO-PACCHETTI"></a>17.2.1.
          L&#39;applicazione che esegue il filtro dei pacchetti</h3>

          <p>E&#39; necessario configurare l&#39;applicazione che esegue il
          filtro dei pacchetti IP per accettare il traffico proveniente da
          qualsiasi indirizzo e diretto verso la porta 80 e redigerlo verso
          la porta dove &egrave; in ascolto l&#39;applicazione di cache
          (nel nostro caso la 3128). Per effettuare questa attivit&agrave;
          sono necessarie delle applicazioni che consentono di gestire
          funzionalit&agrave; avanzate come <em>ipfiltering</em> e
          <em>ipforwarding</em>. In genere, questo tipo di applicazioni
          vengono fornite con il Kernel del sistema operativo. Facciamo ora
          una piccola panoramica dei sistemi GNU Linux o dei sistemi BSD e
          UNIX&reg; che consentono di gestire la tecnica del proxy
          trasparente in maniera efficiente.</p>
        </div>

        <div class="SECT2">
          <hr />

          <h3 class="SECT2"><a name="SUBSEC-TRANSPARENT-NOTE" id=
          "SUBSEC-TRANSPARENT-NOTE"></a>17.2.2. Alcune annotazioni</h3>

          <p>Prima di analizzare le varie applicazioni che eseguono il
          filtraggio dei pacchetti e di mostrare una serie di esempi
          pratici, si rammenta al lettore che alcune delle soluzioni
          proposte in questo capitolo sono state testate con</p>

          <ul>
            <li>
              <p>FreeBSD 4.9-STABLE, squid-2.5STABLE5 ed <em>ipfw</em>(8)
              per eseguire il filtraggio dei pacchetti</p>
            </li>

            <li>
              <p>Linux Red Hat 7.1, Kernel 2.4.20, Squid 2.3.STABLE4 ed
              <em>ipchains</em>(8) per eseguire il filtraggio dei
              pacchetti.</p>
            </li>
          </ul>
        </div>

        <div class="SECT2">
          <hr />

          <h3 class="SECT2"><a name="SUBSEC-FILTRAGGIO-CON-GNU-LINUX" id=
          "SUBSEC-FILTRAGGIO-CON-GNU-LINUX"></a>17.2.3. Filtraggio con GNU
          Linux</h3>

          <p>Come sappiamo GNU Linux &egrave; un Kernel che utilizza
          diverse applicazioni per il filtraggio dei pacchetti che sono in
          stretta relazione con il tipo di Kernel utilizzato, le
          applicazioni pi&ugrave; importanti sono</p>

          <ul>
            <li>
              <p><em>iptables</em> (netfilter) con il Kernel 2.4.x e
              2.6.x</p>
            </li>

            <li>
              <p><em>ipchains</em> con il Kernel 2.2.x e 2.4.x</p>
            </li>

            <li>
              <p><em>ipfwadm</em> con il Kernel 2.0.x</p>
            </li>
          </ul>
        </div>

        <div class="SECT2">
          <hr />

          <h3 class="SECT2"><a name="SUBSEC-FILTRAGGIO-CON-FREEBSD" id=
          "SUBSEC-FILTRAGGIO-CON-FREEBSD"></a>17.2.4. Filtraggio con
          FreeBSD</h3>

          <p>I sistemi BSD ed i sistemi UNIX&reg; utilizzano approcci
          differenti per eseguire il filtraggio dei pacchetti</p>

          <ul>
            <li>
              <p>FreeBSD utilizza <em>ipfw</em>(8) e <em>natd</em>(8)</p>
            </li>

            <li>
              <p>gli altri sistemi BSD e UNIX&reg; utilizzano
              <em>ipf(8)</em> congiuntamente con <em>ipnat</em>(8)</p>
            </li>
          </ul>

          <p>per abilitare la funzionalit&agrave; di proxy trasparente
          &egrave; necessario compilare (o ricompilare) il Kernel o
          aggiungere dei moduli che possono essere caricati dinamicamente.
          Ora vediamo come procedere per configurare un gateway FreeBSD con
          le funzionalit&agrave; di proxy trasparente, la FAQ &egrave; di
          <a href="mailto:stefano@merlinobbs.net" target="_top">Stefano
          Tagliaferri</a>.</p>

          <div class="SECT3">
            <hr />

            <h4 class="SECT3"><a name="SUBSUBSEC-IPFW" id=
            "SUBSUBSEC-IPFW"></a>17.2.4.1. utilizziamo <em>ipfw</em></h4>

            <p>La prima operazione da eseguire sar&agrave; quella di
            ricompilare il Kernel di FreeBSD utilizzando le opzioni
            <em>IPFIREWALL, IPFIREWALL_FORWARD</em> ed
            <em>IPDIVERT</em></p>

            <table border="0" bgcolor="#E0E0E0" width="100%">
              <tr>
                <td>
                  <pre class="PROGRAMLISTING">
# firewalling support
options         IPFIREWALL              # firewall
options         IPFIREWALL_VERBOSE      # abilita il logging
options         IPFIREWALL_FORWARD      # enable t. proxy support
options         IPDIVERT                # divert sockets
    
</pre>
                </td>
              </tr>
            </table>

            <p>ora utilizzeremo l&#39;<em>ipfw</em>(8) per eseguire il
            forward dei pacchetti diretti verso la porta 80 direttamente
            sulla porta 3128 della macchina FreeBSD dove Squid &egrave; in
            ascolto. La regola che dovremo applicare utilizzando il comando
            <em>ipfw</em>(8) &egrave; la seguente</p>

            <table border="0" bgcolor="#E0E0E0" width="100%">
              <tr>
                <td>
                  <pre class="PROGRAMLISTING">
ipfw add fwd 192.168.0.254,3128 tcp from 192.168.0.0/24 to any www
    
</pre>
                </td>
              </tr>
            </table>

            <p>per attivare le funzionalit&agrave; di proxy trasparente
            dovremmo abilitare le funzionalit&agrave; di firewalling ed il
            demone <em>natd</em>(8) di FreeBSD aggiungendo le seguenti
            linee al file di init <em>/etc/rc.conf</em></p>

            <table border="0" bgcolor="#E0E0E0" width="100%">
              <tr>
                <td>
                  <pre class="PROGRAMLISTING">
firewall_enable=&quot;YES&quot;
firewall_type=&quot;/usr/local/etc/ipfw.rules&quot;
natd_enable=&quot;YES&quot;          
natd_interface=&quot;xl0&quot;
natd_flags=&quot;-f /etc/natd.conf&quot;
    
</pre>
                </td>
              </tr>
            </table>

            <p>procederemo con la creazione del file
            <em>/etc/natd.conf</em> con il quale definiremo la
            configurazione del demone <em>natd</em>(8), nel nostro esempio
            trattiamo un sistema con una duplice interfaccia di rete
            (dual-homed host), dove l&#39;interfaccia <em>xl0</em> fa parte
            della rete pubblica internet (outside) mentre l&#39;interfaccia
            <em>rl0</em> fa parte di una rete privata (inside).
            L&#39;interfaccia pubblica (outside) &egrave; quella che
            traduce gli indirizzi e le porte eseguendo il NAT (Network
            Address Translation) o il PAT (Port Address Translation). Per
            definire le regole che verranno utilizzate dal demone
            <em>natd</em>(8) e per dare corso alla traduzione degli
            indirizzi e delle porte, dovremo necessariamente creare un file
            di configurazione del <em>natd</em>(8)
            <em>/etc/natd.conf</em></p>

            <table border="0" bgcolor="#E0E0E0" width="100%">
              <tr>
                <td>
                  <pre class="PROGRAMLISTING">
interface xl0
use_sockets yes
same_ports yes
    
</pre>
                </td>
              </tr>
            </table>

            <p>in questo file viene definita l&#39;interfaccia di rete che
            eseguir&agrave; il NAT (outside), le istruzioni <em>use_socket
            yes</em> e <em>same_ports yes</em> sono fondamentali per il
            corretto funzionamento di alcuni protocolli applicativi
            (livello sette) come l&#39;FTP (File Transfer Protocol) e
            l&#39;IRC (Internet relay chat). Ora dovremmo anche creare il
            file <em>/usr/local/etc/ipfw.rules</em> il cui contenuto
            dovr&agrave; essere adattato ad una macchina che opera da
            gateway tra la LAN (local area network) e la WAN (rete
            pubblica) abilitando il demone <em>natd</em>(8)</p>

            <table border="0" bgcolor="#E0E0E0" width="100%">
              <tr>
                <td>
                  <pre class="PROGRAMLISTING">
## ipfw - regole natd e transparent proxy
#  xl0  - interfaccia sulla rete WAN (esegue il NAT)
#  rl0  - interfaccia sulla rete LAN
#
add fwd 192.168.0.254,3128 tcp from 192.168.0.0/24 to any www
add divert natd all from any to any via xl0
add pass all from any to any via rl0
add pass all from any to any via xl0
    
</pre>
                </td>
              </tr>
            </table>

            <p>192.168.0.254 &egrave; l&#39;indirizzo IP della macchina che
            esegue Squid, rammentiamo al lettore che questo esempio non
            garantisce alcuna misura di sicurezza per la rete interna, per
            configurare correttamente il firewall &egrave; necessario
            consultare la man page di <em>ipfw</em>(8)</p>
          </div>
        </div>

        <div class="SECT2">
          <hr />

          <h3 class="SECT2"><a name="SUBSUBSEC-ALTRI-OS-UNIX" id=
          "SUBSUBSEC-ALTRI-OS-UNIX"></a>17.2.5. Filtraggio con altri
          sistemi UNIX&reg;</h3>

          <p>Il pacchetto <em>ipfilter</em> pu&ograve; essere eseguito su
          diversi sistemi UNIX&reg;, tra i pi&ugrave; importanti possiamo
          citare FreeBSD, NetBSD, OpenBSD, BSD/OS, GNU Linux, Irix, SunOS,
          Solaris e Solaris-x86. In questo caso di studio abbiamo
          utilizzato una macchina FreeBSD</p>

          <div class="SECT3">
            <hr />

            <h4 class="SECT3"><a name="SUBSUBSEC-UTILIZZIAMO-IPF" id=
            "SUBSUBSEC-UTILIZZIAMO-IPF"></a>17.2.5.1. utilizziamo
            <em>ipf</em></h4>

            <p>Per utilizzare <em>ipf</em>(8) (<a href=
            "http://coombs.anu.edu.au/ipfilter/" target=
            "_top">http://coombs.anu.edu.au/ipfilter/</a>) dovremmo
            compilare (o ricompilare) il Kernel abilitando le opzioni
            <em>IPFILTER e IPFILTER_LOG</em></p>

            <table border="0" bgcolor="#E0E0E0" width="100%">
              <tr>
                <td>
                  <pre class="PROGRAMLISTING">
# abilita il supporto ipfilter
options         IPFILTER
options         IPFILTER_LOG
    
</pre>
                </td>
              </tr>
            </table>

            <p>per utilizzare le funzionalit&agrave; di proxy trasparente
            con <em>ipfilter</em> &egrave; necessario compilare Squid con
            la seguente opzione di configurazione</p>

            <table border="0" bgcolor="#E0E0E0" width="100%">
              <tr>
                <td>
                  <pre class="PROGRAMLISTING">
# ./configure --enable-ipf-transparent
    
</pre>
                </td>
              </tr>
            </table>

            <p>dopo aver compilato (o ricompilato) Squid, dovremmo creare
            un file denominato <em>/etc/ipf.rules</em>, questo deve
            contenere le seguenti linee</p>

            <table border="0" bgcolor="#E0E0E0" width="100%">
              <tr>
                <td>
                  <pre class="PROGRAMLISTING">
pass in all
    
</pre>
                </td>
              </tr>
            </table>

            <p>a questo punto creeremo un nuovo file dal nome
            <em>/etc/ipnat.rules</em>, questo deve contenere le seguenti
            linee</p>

            <table border="0" bgcolor="#E0E0E0" width="100%">
              <tr>
                <td>
                  <pre class="PROGRAMLISTING">
# rl0 &egrave; in nome dell&#39;interfaccia di rete
rdr rl0 0.0.0.0/0 port 80 -&gt; 192.168.0.254 port 3128 tcp
    
</pre>
                </td>
              </tr>
            </table>

            <p>192.168.0.254 &egrave; l&#39;indirizzo IP della macchina che
            esegue Squid, ora posizioniamoci nella directory
            <em>/usr/local/etc/rc.d</em> per creare uno script che sia in
            grado di inizializzare le regole di firewalling che abbiamo
            appena definito</p>

            <table border="0" bgcolor="#E0E0E0" width="100%">
              <tr>
                <td>
                  <pre class="PROGRAMLISTING">
$ ee ipfilter.sh
#!/bin/sh
ipf -Fa -E -f /etc/ipf.rules
ipnat -CF -f /etc/ipnat.rules
$ chmod 755 ipfilter.sh
    
</pre>
                </td>
              </tr>
            </table>

            <p>dopo aver impostato il modo del file a <em>755</em> potremmo
            finalmente riavviare la macchina che al successivo reboot
            sar&agrave; pronta per funzionare come proxy trasparente.
            Rammentiamo al lettore che questo esempio non garantisce alcuna
            misura di sicurezza per la rete interna, per configurare
            correttamente il firewall &egrave; necessario consultare la man
            page di <em>ipf</em>(8).</p>
          </div>
        </div>

        <div class="SECT2">
          <hr />

          <h3 class="SECT2"><a name="SUBSEC-INLINE-CACHE-CON-LINUX" id=
          "SUBSEC-INLINE-CACHE-CON-LINUX"></a>17.2.6. Esempi di inline
          cache con Linux</h3>

          <p>In questa sezione possiamo analizzare alcuni esempi di
          configurazioni con GNU Linux , in particolare la tecnica del
          proxy trasparente utilizza un software che esegue il filtraggio
          dei pacchetti ed in alcuni casi la tecnica del Network Address
          Translation.</p>

          <div class="SECT3">
            <hr />

            <h4 class="SECT3"><a name=
            "SUBSUBSEC-CONF-TRANSPARENT-PROXY-LINUX20" id=
            "SUBSUBSEC-CONF-TRANSPARENT-PROXY-LINUX20"></a>17.2.6.1.
            Configurare il proxy trasparente con Linux kernel 2.0.x</h4>

            <p>Questa FAQ &egrave; stata realizzata da <a href=
            "mailto:Rodney.van.den.Oever@tip.nl" target="_top">Rodney van
            den Oever</a>.</p>

            <p>E&#39; necessario compilare il Kernel con il supporto per il
            firewalling e la ridirezione dei pacchetti, &egrave; necessario
            impostare dei parametri importanti in
            <em>/usr/src/linux/.config</em></p>

            <table border="0" bgcolor="#E0E0E0" width="100%">
              <tr>
                <td>
                  <pre class="PROGRAMLISTING">
#
# Code maturity level options
#
CONFIG_EXPERIMENTAL=y
#
# Networking options
#
CONFIG_FIREWALL=y
# CONFIG_NET_ALIAS is not set
CONFIG_INET=y
CONFIG_IP_FORWARD=y
# CONFIG_IP_MULTICAST is not set
CONFIG_IP_FIREWALL=y
# CONFIG_IP_FIREWALL_VERBOSE is not set
CONFIG_IP_MASQUERADE=y
CONFIG_IP_TRANSPARENT_PROXY=y
CONFIG_IP_ALWAYS_DEFRAG=y
# CONFIG_IP_ACCT is not set
CONFIG_IP_ROUTER=y
    
</pre>
                </td>
              </tr>
            </table>

            <p>&egrave; anche necessario abilitare l&#39;opzione di IP
            Forwarding, un sistema per attivare questa funzionalit&agrave;
            &egrave; quello di inserire una linea simile alla seguente
            negli script di init del sistema</p>

            <table border="0" bgcolor="#E0E0E0" width="100%">
              <tr>
                <td>
                  <pre class="PROGRAMLISTING">
echo 1 &gt; /proc/sys/net/ipv4/ip_forward
    
</pre>
                </td>
              </tr>
            </table>

            <p>a questo punto procuriamoci il software <em>ipfwadm</em>(8),
            per garantire il corretto funzionamento del sistema di
            filtraggio dei pacchetti &egrave; necessaria la versione 2.3.0.
            Con <em>ipfwadm</em>(8) &egrave; possibile ridirezionare il
            traffico verso Squid utilizzando il seguente comando</p>

            <table border="0" bgcolor="#E0E0E0" width="100%">
              <tr>
                <td>
                  <pre class="PROGRAMLISTING">
ipfwadm -I -a acc -P tcp -D default/0 80 -r 3128
    
</pre>
                </td>
              </tr>
            </table>

            <p>rammentiamo al lettore che questo esempio non garantisce
            alcuna misura di sicurezza per la rete interna, per configurare
            correttamente il firewall &egrave; necessario consultare la man
            page di <em>ipfwadm</em>(8).</p>
          </div>

          <div class="SECT3">
            <hr />

            <h4 class="SECT3"><a name=
            "SUBSUBSEC-CONF-TRANSPARENT-PROXY-LINUX22" id=
            "SUBSUBSEC-CONF-TRANSPARENT-PROXY-LINUX22"></a>17.2.6.2.
            Configurare il proxy trasparente con Linux kernel 2.2.x</h4>

            <p>FAQ scritta da <a href="mailto:Support@dnet.co.uk" target=
            "_top">Martin Lyons</a>.</p>

            <p>E&#39; necessario configurare il Kernel per utilizzare
            <em>ipchains</em>(8), la prima cosa da fare &egrave; quella di
            posizionarsi nella directory contenente i sorgenti di GNU
            Linux</p>

            <table border="0" bgcolor="#E0E0E0" width="100%">
              <tr>
                <td>
                  <pre class="PROGRAMLISTING">
$ cd /usr/src/linux
$ make menuconfig
    
</pre>
                </td>
              </tr>
            </table>

            <p>queste sono le opzioni pi&ugrave; importanti da includere
            nella configurazione del Kernel</p>

            <table border="0" bgcolor="#E0E0E0" width="100%">
              <tr>
                <td>
                  <pre class="PROGRAMLISTING">
[*] Network firewalls
[ ] Socket Filtering
[*] Unix domain sockets
[*] TCP/IP networking
[ ] IP: multicasting
[ ] IP: advanced router
[ ] IP: kernel level autoconfiguration
[*] IP: firewalling
[ ] IP: firewall packet netlink device
[*] IP: always defragment (required for masquerading)
[*] IP: transparent proxy support
    
</pre>
                </td>
              </tr>
            </table>

            <p>Il Kernel deve essere compilato con il supporto per il
            firewalling e devono essere inoltre abilitate le
            funzionalit&agrave; di <em>always defragment</em> che sono
            necessarie alla politica di masquerading, compileremo inoltre
            il supporto per il transparent proxy. E&#39; necessario
            abilitare la funzionalit&agrave; di <em>ipforwarding</em> ed
            installare il pacchetto software <em>ipchains</em>(8). Il
            comando da utilizzare per ridirezionare il traffico verso Squid
            &egrave; il seguente</p>

            <table border="0" bgcolor="#E0E0E0" width="100%">
              <tr>
                <td>
                  <pre class="PROGRAMLISTING">
ipchains -A input -p tcp -s 0/0 -d 0/0 80 -j REDIRECT 3128
    
</pre>
                </td>
              </tr>
            </table>

            <p>la regola <em>-A input</em> appende delle regole di entrata,
            l&#39;opzione <em>-p tcp</em> esprime una corrispondenza con il
            protocollo TCP, le opzioni <em>-s</em> e <em>-d</em>
            specificano l&#39;indirizzo sorgente e quello di destinazione,
            utilizzando l&#39;opzione <em>0/0</em> si esprime la
            corrispondenza con qualsiasi indirizzo IP. Rammentiamo al
            lettore che questo esempio non garantisce alcuna misura di
            sicurezza per la rete interna, per configurare correttamente il
            firewall &egrave; necessario consultare la man page di
            <em>ipchains</em>(8).</p>
          </div>

          <div class="SECT3">
            <hr />

            <h4 class="SECT3"><a name=
            "SUBSUBSEC-CONF-TRANSPARENT-PROXY-LINUX24" id=
            "SUBSUBSEC-CONF-TRANSPARENT-PROXY-LINUX24"></a>17.2.6.3.
            Configurare il proxy trasparente con Linux kernel 2.4.x e
            2.6.x</h4>

            <p>FAQ di Daniel Kiracofe, Il documento di riferimento
            &egrave;: Transparent Proxy with Linux and Squid mini-HOWTO
            disponibile alla URLs <a href=
            "http://www.linuxdoc.org/HOWTO/mini/TransparentProxy.html"
            target=
            "_top">http://www.linuxdoc.org/HOWTO/mini/TransparentProxy.html</a>.</p>

            <p>Il Kernel deve essere compilato con i seguenti
            prerequisiti</p>

            <ul>
              <li>
                <p>Networking support</p>
              </li>

              <li>
                <p>Sysctl support</p>
              </li>

              <li>
                <p>Network packet filtering</p>
              </li>

              <li>
                <p>TCP/IP networking</p>
              </li>

              <li>
                <p>Connection tracking (Under ``IP: Netfilter
                Configuration&#39;&#39; in menuconfig)</p>
              </li>

              <li>
                <p>IP tables support</p>
              </li>

              <li>
                <p>Full NAT</p>
              </li>

              <li>
                <p>REDIRECT target support</p>
              </li>

              <li>
                <p><em>/proc</em> filesystem support</p>
              </li>
            </ul>

            <p>l&#39;opzione &quot;Fast switching&quot; deve essere
            disabilitata ed inoltre dovremmo abilitare la
            funzionalit&agrave; del packet forwarding negli script di
            init</p>

            <table border="0" bgcolor="#E0E0E0" width="100%">
              <tr>
                <td>
                  <pre class="PROGRAMLISTING">
echo 1 &gt; /proc/sys/net/ipv4/ip_forward
    
</pre>
                </td>
              </tr>
            </table>

            <p>per un corretto funzionamento del proxy trasparente &egrave;
            necessario il pacchetto software <em>iptables</em>(8), il
            comando da utilizzare per configurare l&#39;applicazione che
            filtra i pacchetti e ridirezionare il traffico <em>www</em>
            verso Squid &egrave; il seguente</p>

            <table border="0" bgcolor="#E0E0E0" width="100%">
              <tr>
                <td>
                  <pre class="PROGRAMLISTING">
iptables -t nat -A PREROUTING -i eth0 -p tcp --dport 80 -j REDIRECT --to-port 3128
    
</pre>
                </td>
              </tr>
            </table>

            <p>rammentiamo al lettore che questo esempio non garantisce
            alcuna misura di sicurezza per la rete interna, per configurare
            correttamente il firewall &egrave; necessario consultare la man
            page di <em>iptables</em>(8), maggiori dettagli sono reperibili
            alla URL <a href=
            "http://www.squid-cache.org/Doc/FAQ/FAQ-17.html#ss17.4" target=
            "_top">http://www.squid-cache.org/Doc/FAQ/FAQ-17.html#ss17.4</a>.</p>
          </div>
        </div>

        <div class="SECT2">
          <hr />

          <h3 class="SECT2"><a name="SUBSEC-CONF-SQUID-TRANSPARENT" id=
          "SUBSEC-CONF-SQUID-TRANSPARENT"></a>17.2.7. Abilitare inline
          cache con Squid</h3>

          <p>Dopo aver configurato l&#39;applicazione che esegue il
          filtraggio dei pacchetti vediamo come definire correttamente la
          configurazione di Squid per eseguire in maniera efficente la
          tecnica del proxy trasparente. Di seguito mostriamo il TAG da
          inserire nel file <em>/etc/squid/squid.conf</em></p>

          <table border="0" bgcolor="#E0E0E0" width="100%">
            <tr>
              <td>
                <pre class="PROGRAMLISTING">
http_port 3128 
httpd_accel_host virtual 
httpd_accel_port 80 
httpd_accel_with_proxy on 
httpd_accel_uses_host_header on 
   
</pre>
              </td>
            </tr>
          </table>

          <p>naturalmente le regole impostate sino ad ora consentiranno
          solo l&#39;inoltro del traffico dei pacchetti IP diretti verso la
          sola porta 80. Nel caso ci si trovi in una LAN/WAN di medie o di
          grandi dimensioni &egrave; ipotizzabile supporre la
          necessit&agrave; di lasciar passare anche altri pacchetti IP. Per
          rendere possibile questo inoltro si utilizzano le
          funzionalit&agrave; offerte dal <em>NAT</em> (Network Address
          Translation), queste funzioni in ambiente Linux vengono
          supportate in parte dall&#39;ipmasquerade mentre con i sistemi
          BSD si utilizza <em>natd</em>(8) e <em>ipnat</em>(8).</p>
        </div>

        <div class="SECT2">
          <hr />

          <h3 class="SECT2"><a name="SUBSEC-CONF-IPMASQUERADE" id=
          "SUBSEC-CONF-IPMASQUERADE"></a>17.2.8.
          L&#39;<em>ipmasquerade</em> con LINUX kernel 2.2.x/2.4.x</h3>

          <p>Dopo aver mostrato come configurare i diversi Kernel di Linux
          siamo finalmente in grado di mostrare un esempio di tecnica di
          mascheramento che consentir&agrave; il passaggio dei pacchetti di
          qualsiasi tipo verso la subnet 192.168.1.0/24, rete sulla quale
          abbiamo attestato la rete dei server (MZ)</p>

          <table border="0" bgcolor="#E0E0E0" width="100%">
            <tr>
              <td>
                <pre class="PROGRAMLISTING">
ipchains -P forward DENY ipchains -A forward -p all -s 192.168.1.0/24 -d 0/0 -j MASQ 
   
</pre>
              </td>
            </tr>
          </table>

          <p>gli indirizzi sorgenti che vengono identificati
          dall&#39;opzione <em>-s</em>, vengono mascherati ricorrendo alla
          tecnica del Network Address Translation. Nell&#39;esempio
          successivo mostriamo come eseguire la tecnica del mascheramento
          consentendo il passaggio di alcuni pacchetti <em>TCP</em>
          relativi ad alcune applicazioni di livello sette come
          <em>ssh</em>, <em>telnet</em>, <em>ftp</em>, <em>smtp</em>,
          <em>pop3</em> ed <em>https</em> verso la subnet 192.168.2.0/24,
          rete sulla quale abbiamo attestato gli utenti finale(MZ-L2), la
          regola finale eseguir&agrave; il <em>forward</em> dei pacchetti
          dalla porta 80 alla 3128.</p>

          <table border="0" bgcolor="#E0E0E0" width="100%">
            <tr>
              <td>
                <pre class="PROGRAMLISTING">
ipchains -A forward -p tcp -s 192.168.2.0/24 -d 0/0 --dport ssh -j MASQ 
ipchains -A forward -p tcp -s 192.168.2.0/24 -d 0/0 --dport telnet -j MASQ
ipchains -A forward -p tcp -s 192.168.2.0/24 -d 0/0 --dport ftp -j MASQ 
ipchains -A forward -p tcp -s 192.168.2.0/24 -d 0/0 --dport smtp -j MASQ
ipchains -A forward -p tcp -s 192.168.2.0/24 -d 0/0 --dport 110 -j MASQ 
ipchains -A forward -p tcp -s 192.168.2.0/24 -d 0/0 --dport 443 -j MASQ
ipchains -A input -p tcp -s 0/0 -d 0/0 80 -j REDIRECT 3128
   
</pre>
              </td>
            </tr>
          </table>

          <p>gli indirizzi sorgente che vengono identificati
          dall&#39;opzione <em>-s</em>, vengono mascherati ricorrendo alla
          tecnica del Network Address Translation, i pacchetti <em>tcp</em>
          provenienti da qualsiasi indirizzo sorgente e diretti verso
          qualsiasi indirizzo di destinazione (<em>0/0</em>) vengono
          ridirezionati dalla porta 80 alla porta 3128. Ora rendiamo
          operativo Squid modificando il file
          <em>/etc/squid/squid.conf</em></p>

          <table border="0" bgcolor="#E0E0E0" width="100%">
            <tr>
              <td>
                <pre class="PROGRAMLISTING">
http_port 3128 
httpd_accel_host virtual 
httpd_accel_port 80 
httpd_accel_with_proxy on 
httpd_accel_uses_host_header on
   
</pre>
              </td>
            </tr>
          </table>

          <p>rammentiamo al lettore che questo esempio non garantisce
          alcuna misura di sicurezza per la rete interna, per configurare
          correttamente il firewall &egrave; necessario consultare la man
          page di <em>ipchains</em>(8)</p>
        </div>
      </div>

      <div class="SECT1">
        <hr />

        <h2 class="SECT1"><a name="SEC-SWITCH-DI-LIVELLO-QUATTRO" id=
        "SEC-SWITCH-DI-LIVELLO-QUATTRO"></a>17.3. Gli switch di livello
        quattro</h2>

        <p>Gli switch normalmente lavorano a livello due (livello di
        datalink), uno switch di livello quattro invece esegue il
        forwarding dei pacchetti basandosi sugli indirizzi IP o sulle porte
        TCP. uno switch di livello quattro pu&ograve; essere utilizzato per
        eseguire il bilanciamento tra server (load balancing) e nel caso in
        cui Squid dovesse andare in errore lo switch si occuper&agrave; di
        ridirezionare il traffico <em>HTTP</em> lasciandolo transitare per
        il suo naturale percorso. Gli switch di livello quattro possono
        essere tenuti sotto controllo utilizzando diversi sistemi e diversi
        protocolli, tra i pi&ugrave; importanti citiamo <em>ARP</em>,
        <em>ICMP</em>, <em>TCP</em>, <em>HTTP</em>, <em>SNMP</em> ed altri.
        Tra le soluzioni commerciali citiamo i Cisco Local Director
        (<a href=
        "http://www.cisco.com/en/US/products/hw/contnetw/ps1894/index.html"
        target=
        "_top">http://www.cisco.com/en/US/products/hw/contnetw/ps1894/index.html</a>),
        F5 Networks BIG-IP (<a href="http://www.f5.com/f5products/bigip/"
        target="_top">http://www.f5.com/f5products/bigip/</a>), ServerIron
        450-850 (<a href=
        "http://www.foundrynet.com/products/webswitches/serveriron/index.html"
           target=
           "_top">http://www.foundrynet.com/products/webswitches/serveriron/index.html</a>)
           e RadWare Cache Server Director (<a href=
           "http://www.radware.com/content/products/csd/default.asp" target=
           "_top">http://www.radware.com/content/products/csd/default.asp</a>).
           Tra le applicazioni a codice libero citiamo LVS<a name="AEN4887"
           href="#FTN.AEN4887" id="AEN4887">[28]</a> eseguito su una
           macchina GNU Linux (<a href="http://www.linuxvirtualserver.org/"
           target="_top">http://www.linuxvirtualserver.org/</a>).</p>
      </div>

      <div class="SECT1">
        <hr />

        <h2 class="SECT1"><a name="SEC-WCCP" id="SEC-WCCP"></a>17.4. WCCP
        (Web Cache Coordination Protocol)</h2>

        <p>Si tratta di un protocollo di incapsulamento che &egrave; stato
        sviluppato dalla Cisco Systems e che viene implementato nei routers
        e negli switch di livello quattro. <em>WCCPv1</em> viene supportato
        da diversi vendors e viene incluso come componente di serie in
        tutti i sistemi di webcache come Squid. Esistono due versioni del
        protocollo <em>WCCP</em> che &egrave; un protocollo aperto e viene
        documentato dalla RFC 3040 (<a href=
        "http://www.faqs.org/rfcs/rfc3040.html" target=
        "_top">http://www.faqs.org/rfcs/rfc3040.html</a>). Per utilizzare
        questo protocollo &egrave; comunque richiesta la licenza di
        utilizzo dalla Cisco Systems. Il protocollo WCCP si compone di due
        parti, il <em>protocollo di controllo</em> e la <em>ridirezione del
        traffico</em>, il protocollo di controllo utilizza tre tipi di
        messaggi</p>

        <table border="0" bgcolor="#E0E0E0" width="100%">
          <tr>
            <td>
              <pre class="PROGRAMLISTING">
HERE_I_AM
I_SEE_YOU
ASSIGN_BUCKETS
  
</pre>
            </td>
          </tr>
        </table>

        <p>l&#39;applicazione di cache avvisa della sua presenza lanciando
        un messaggio <em>I_SEE_YOU</em>, il router e Squid continuano a
        scambiare messaggi periodicamente per verificare il loro livello di
        interconnessione, grazie a questo sistema il router riconosce lo
        stato operativo di Squid e pu&ograve; quindi eseguire la deviazione
        del traffico <em>HTTP</em> verso la device di webcache.
        <em>WCCP</em> non necessita che il proxy server sia connesso
        direttamente con il router perch&egrave; i pacchetti deviati
        vengono incapsulati con il protocollo <em>GRE</em> che &egrave;
        l&#39;acronimo di <em>Generic Routing Incapsulation</em> - RFC 2784
        (<a href="http://www.faqs.org/rfcs/rfc2784.html" target=
        "_top">http://www.faqs.org/rfcs/rfc2784.html</a>) ed il sistema
        operativo che esegue Squid deve essere in grado di interpretare i
        pacchetti <em>GRE</em> che ricever&agrave; dal router. Il
        protocollo <em>WCCP</em> &egrave; stato codificato per deviare solo
        i pacchetti TCP che vengono identificati con la porta di
        destinazione 80 (ovvero quella solitamente utilizzata dai server
        <em>HTTP</em>). I pacchetti incapsulati vengono inviati a Squid che
        esegue la decodifica del protocollo <em>GRE</em> per interpretare
        correttamente i pacchetti TCP. Il protocollo <em>WCCP</em> supporta
        inoltre il clustering degli apparati di webcache e le tecniche di
        load balancing: un router sul quale viene abilitato il protocollo
        <em>WCCP</em> &egrave; in grado di deviare il traffico verso
        diversi sistemi Squid. Grazie al messaggio <em>I_SEE_YOU</em> il
        router notifica alle webcache la presenza di altri apparati, la
        macchina Squid configurata con l&#39;indirizzo IP pi&ugrave; basso
        viene automaticamente designata come cache master. Il protocollo
        <em>WCCP</em> supporta la rilevazione dei guasti, Squid invia un
        messaggio del tipo <em>HERE_I_AM</em> ogni 10 secondi, se il router
        non riceve questo messaggio per una durata massima di 30 secondi
        marca come indisponibile (bad) la cache designata come master, la
        richiesta non verra dunque deviata verso la macchina Squid al
        momento indisponibile.</p>

        <div class="SECT2">
          <hr />

          <h3 class="SECT2"><a name="SUBSEC-CONFIGURARE-WCCP-CON-IOS" id=
          "SUBSEC-CONFIGURARE-WCCP-CON-IOS"></a>17.4.1. Configurare WCCP
          con Cisco IOS</h3>

          <p><em>WCCPv1</em> &egrave; supportato dal sistema operativo
          Cisco IOS nelle sue versioni a partire dalla 11.1(19) e
          successive, il protocollo <em>WCCPv2</em> viene pienamente
          supportato dal sistema operativo Cisco IOS a partire dalla
          versione 12.0(4).</p>

          <p>In questo esempio possiamo vedere la configurazione del
          protocollo <em>WCCPv1</em> per il sistema operativo Cisco IOS
          11.x</p>

          <table border="0" bgcolor="#E0E0E0" width="100%">
            <tr>
              <td>
                <pre class="PROGRAMLISTING">
ip wccp enable
!
interface fastethernet0/0
ip wccp web-cache redirect
   
</pre>
              </td>
            </tr>
          </table>

          <p>In questo esempio invece vediamo la configurazione pi&ugrave;
          comune del protocollo <em>WCCPv1</em> per il sistema operativo
          Cisco IOS 12.x</p>

          <table border="0" bgcolor="#E0E0E0" width="100%">
            <tr>
              <td>
                <pre class="PROGRAMLISTING">
ip wccp version 1
ip wccp web-cache
!
interface fastethernet0/0
ip wccp web-cache redirect out
   
</pre>
              </td>
            </tr>
          </table>

          <p>il sistema operativo Cisco IOS Release 12.2 consente di
          abilitare le funzionalit&agrave; <em>WCCPv1</em> o
          <em>WCCPv2</em> utilizzando il comando <em>ip wccp version</em>.
          La configurazione automatica del protocollo <em>WCCPv1</em>
          &egrave; stata sostituita, l&#39;interfaccia del router
          utilizzata in questo esempio (fastethernet 0/0) pu&ograve; non
          essere adeguata alla Vostra installazione.</p>
        </div>

        <div class="SECT2">
          <hr />

          <h3 class="SECT2"><a name="SUBSEC-CONFIGURARE-WCCP-CON-SQUID" id=
          "SUBSEC-CONFIGURARE-WCCP-CON-SQUID"></a>17.4.2. Configurare WCCP
          con Squid</h3>

          <p>Dopo aver configurato il router analizziamo i TAG che
          consentono di attivare il protocollo <em>WCCPv1</em> con Squid,
          si rammenta che il protocollo WCCPv2 verr&agrave; implementato
          nelle future versioni di Squid (<a href=
          "http://devel.squid-cache.org/projects.html#visolve_wccpv2"
          target=
          "_top">http://devel.squid-cache.org/projects.html#visolve_wccpv2</a>)</p>

          <table border="0" bgcolor="#E0E0E0" width="100%">
            <tr>
              <td>
                <pre class="PROGRAMLISTING">
wccp_router 192.168.1.254
wccp_version 4
   
</pre>
              </td>
            </tr>
          </table>

          <p>il TAG <em>wccp_router</em> indica l&#39;indirizzo IP del
          router sul quale &egrave; stato abilitato il protocollo
          <em>WCCP</em>, il TAG <em>wccp_version</em> identifica il tipo di
          versione. Il sistema operativo Cisco IOS 11.2 supporta unicamente
          la versione 3, Squid viene normalmente compilato con il supporto
          al protocollo <em>WCCP</em> abilitato, non dimentichiamo che, se
          si decide di utilizzare il protocollo WCCP, non sar&agrave;
          possibile abilitare alcun modello di autenticazione.</p>
        </div>

        <div class="SECT2">
          <hr />

          <h3 class="SECT2"><a name="SEC-FREEBSD-GRE-TUNNEL" id=
          "SEC-FREEBSD-GRE-TUNNEL"></a>17.4.3. Abilitare l&#39;interfaccia
          GRE con FreeBSD</h3>

          <p>Se si intende utilizzare il protocollo <em>WCCP</em> con
          FreeBSD sar&agrave; necessario compilare il Kernel del sistema
          operativo abilitando il supporto <em>GRE</em>. A partire dalla
          versione 4.7 di FreeBSD, l&#39;istruzione che consentir&agrave;
          di abilitare il protocollo <em>GRE</em> nel file che definisce le
          impostazioni del Kernel (<em>/usr/src/sys/i386/conf/GENERIC</em>)
          sar&agrave;</p>

          <table border="0" bgcolor="#E0E0E0" width="100%">
            <tr>
              <td>
                <pre class="PROGRAMLISTING">
pseudo-device   gre                     #IP over IP tunneling
   
</pre>
              </td>
            </tr>
          </table>

          <p>a questo punto dovremmo configurare FreeBSD per stabilire un
          tunnel <em>GRE</em> tra il router e la macchina che esegue
          Squid</p>

          <table border="0" bgcolor="#E0E0E0" width="100%">
            <tr>
              <td>
                <pre class="PROGRAMLISTING">
# ifconfig gre0 create
# ifconfig gre0 &lt;Host-IP&gt; &lt;Router-IP&gt; netmask 255.255.255.255 up
# ifconfig gre0 tunnel &lt;Host-IP&gt; &lt;Router-IP&gt;
# route delete &lt;Router-IP&gt;
   
</pre>
              </td>
            </tr>
          </table>

          <p>dove <em>&lt;Host-IP&gt;</em> &egrave; l&#39;indirizzo IP
          della macchina che esegue Squid e <em>&lt;Router-IP&gt;</em>
          &egrave; l&#39;indirizzo IP del router che intercetta i pacchetti
          <em>HTTP</em>.</p>
        </div>

        <div class="SECT2">
          <hr />

          <h3 class="SECT2"><a name="SEC-LINUX-2.2-GRE-TUNNEL" id=
          "SEC-LINUX-2.2-GRE-TUNNEL"></a>17.4.4. Abilitare
          l&#39;interfaccia GRE con Linux</h3>

          <p>Il Kernel di Linux 2.2 supporta l&#39;incapsulamento
          <em>GRE</em> soltanto se il modulo relativo verr&agrave;
          compilato nel Kernel. Per assicurarsi che il codice <em>GRE</em>
          sia stato compilato staticamente oppure come modulo dinamico del
          Kernel &egrave; possibile utilizzare il seguente comando</p>

          <table border="0" bgcolor="#E0E0E0" width="100%">
            <tr>
              <td>
                <pre class="PROGRAMLISTING">
# modprobe ip_gre
   
</pre>
              </td>
            </tr>
          </table>

          <p>a questo punto dovremmo configurare Linux per stabilire un
          tunnel <em>GRE</em> tra il router e la macchina che esegue
          Squid</p>

          <table border="0" bgcolor="#E0E0E0" width="100%">
            <tr>
              <td>
                <pre class="PROGRAMLISTING">
iptunnel add gre1 mode gre remote &lt;Router-IP&gt; local &lt;Host-IP&gt; dev &lt;interface&gt;
ifconfig gre1 127.0.0.2 up
   
</pre>
              </td>
            </tr>
          </table>

          <p>dove <em>&lt;Router-IP&gt;</em> &egrave; l&#39;indirizzo IP
          del router che intercetta i pacchetti <em>HTTP</em>,
          <em>&lt;Host-IP&gt;</em> &egrave; l&#39;indirizzo IP della cache
          e <em>&lt;interface&gt;</em> &egrave; il nome
          dell&#39;interfaccia di rete che riceve questi pacchetti (molto
          probabilmente eth0).</p>
        </div>
      </div>

      <div class="SECT1">
        <hr />

        <h2 class="SECT1"><a name="SEC-I-ROUTER-CISCO" id=
        "SEC-I-ROUTER-CISCO"></a>17.5. Policy di routing con i router
        Cisco</h2>

        <p>Un router &egrave; in grado di eseguire delle operazioni di
        forwarding dei pacchetti basandosi su informazioni differenti dal
        semplice indirizzo IP di origine o di destinazione, una politica di
        routing pu&ograve; consentire di impostare dei percorsi differenti
        per alcuni pacchetti che rispondono a determinati requisiti, un
        router &egrave; dunque in grado di dirottare i pacchetti ragionando
        anche sulla porta di destinazione del pacchetto stesso. Questa
        funzionalit&agrave; pu&ograve; essere abilitata utilizzando le
        regole del sistema operativo Cisco IOS, &egrave; bene ricordare che
        alcune versioni di questo sistema operativo possono risultare
        incompatibili con questa opzione perch&eacute; troppo vecchie.</p>

        <p>La FAQ che stiamo per illustrare &egrave; stata realizzata da
        <a href="mailto:John.Saunders@scitec.com.au" target="_top">John
        Saunders</a>, la configurazione proposta lavora correttamente con
        il sistema operativo Cisco System IOS 11.1 e successivi. La prima
        attivit&agrave; da svolgere &egrave; procedere con la creazione di
        una <em>access-list</em> che consentir&agrave; al router di
        selezionare il traffico da deviare verso la macchina che esegue
        Squid</p>

        <table border="0" bgcolor="#E0E0E0" width="100%">
          <tr>
            <td>
              <pre class="PROGRAMLISTING">
access-list 110 deny   tcp host 192.168.102.3 any eq www
access-list 110 permit tcp any any eq www
  
</pre>
            </td>
          </tr>
        </table>

        <p>192.168.102.3 &egrave; l&#39;indirizzo IP della macchina che
        esegue Squid, la prima linea della ACL esclude i pacchetti con
        indirizzo sorgente 192.168.102.3 destinati alla porta 80
        (<em>www</em>), la seconda linea confronta con tutti gli altri
        pacchetti destinati alla porta 80. Dopo aver impostato una
        <em>access-list</em> possiamo definire una <em>route-map</em></p>

        <table border="0" bgcolor="#E0E0E0" width="100%">
          <tr>
            <td>
              <pre class="PROGRAMLISTING">
route-map proxy-squid permit 10
match ip address 110
set ip next-hop 192.168.102.3
  
</pre>
            </td>
          </tr>
        </table>

        <p>per rendere operativa la configurazione &egrave; necessario
        applicare la <em>route-map</em> sull&#39;interfaccia connessa con
        la LAN dove &egrave; stato installato Squid</p>

        <table border="0" bgcolor="#E0E0E0" width="100%">
          <tr>
            <td>
              <pre class="PROGRAMLISTING">
interface Ethernet0
ip policy route-map proxy-squid
  
</pre>
            </td>
          </tr>
        </table>

        <p>di seguito sottoponiamo al lettore un&#39;altro esempio
        completo, dove viene definita una <em>route-map</em> denominata
        <em>proxy-redirect</em>, quest&#39;ultima specifica come salto
        successivo la macchina dove &egrave; in esecuzione il proxy server
        Squid</p>

        <table border="0" bgcolor="#E0E0E0" width="100%">
          <tr>
            <td>
              <pre class="PROGRAMLISTING">
!
access-list 110 deny tcp any any neq www
access-list 110 deny tcp host 192.168.1.13 any
access-list 110 permit tcp any any
!
route-map proxy-redirect permit 10
match ip address 110
set ip next-hop 192.168.1.13
!
interface Ethernet0
ip policy route-map proxy-redirect
!
  
</pre>
            </td>
          </tr>
        </table>

        <p>in questo caso di studio la macchina che esegue Squid ha
        l&#39;indirizzo IP 192.168.1.13. Il router redirige il traffico
        destinato alla porta 80 (www) verso la porta dove rimane in ascolto
        Squid. Questo tipo di policy di routing degrada le prestazioni del
        router ed in molte versioni di Cisco IOS questo tipo di regola
        utilizza un tempo CPU piuttosto elevato.</p>
      </div>
    </div>

    <div class="CHAPTER">
      <hr />

      <h1><a name="CHA-REVERSE-PROXY" id="CHA-REVERSE-PROXY"></a>Capitolo
      18. Reverse proxy</h1>

      <div class="SECT1">
        <h2 class="SECT1"><a name="SEC-SERVER-HTTPD-E-CONTENT-CACHING" id=
        "SEC-SERVER-HTTPD-E-CONTENT-CACHING"></a>18.1. Server HTTPD e
        content caching</h2>

        <p>La funzionalit&agrave; di acceleratore o di Reverse Proxy
        consente agli amministratori di Sistema di utilizzare Squid come
        servizio HTTP o HTTPS dedicato, tale opzione di configurazione
        lascia inalterate le funzionalit&agrave; di proxy tradizionale di
        Squid. Nella fattispecie l&#39;acceleratore pu&ograve; essere
        fondamentale nelle piattaforme di security ispirate al modello TIER
        (2-TIER/3-TIER), inoltre un Reverse Proxy riduce l&#39;utilizzo e
        l&#39;overload di uno o pi&ugrave; server web di backend.</p>

        <p>Il modello TIER prevede il frazionamento dei servizi da offrire
        sul Web e viene implementato in quelle WAN interconnesse con la
        rete internet che prevedono una zona demilitarizzata (DMZ)
        posizionata a valle del firewall che la controlla e ne garantisce
        il livello di sicurezza.</p>

        <p><img src="images/reverse.png" alt="" /></p>Ecco un esempio per
        un modello TIER-3. l&#39;acceleratore si trova zona demilitarizzata
        (DMZ) e viene contattato dagli utenti che accedono dalla rete IP
        pubblica, il Reverse Proxy si occupa di contattare direttamente il
        web server che si trova all&#39;interno di una rete a maggior
        livello di protezione (MZ). Il Reverse Proxy installato nella DMZ
        ed il Proxy configurato nella MZ possono essere in peering tra loro
        grazie al protocollo ICP e alla modalit&agrave; <em>parent</em> o
        <em>sibling</em>. Nella DMZ sono posizionati gli host che offrono i
        servizi internet come HTTPD, DNS, SMTP e pop3. L&#39;acceleratore
        sostituisce il server web reale ed &egrave; l&#39;unico host
        autorizzato ad attraversare il firewall per contattare il server
        web situato all&#39;interno della rete a maggior livello di
        protezione (MZ). Il server web presente nella rete MZ viene
        consultato indirettamente dagli utenti internet tramite le
        funzionalit&agrave; del Reverse Proxy Squid.
      </div>
      <br />

      <div class="SECT1">
        <hr />

        <h2 class="SECT1"><a name="SEC-REVERSE-PROXY-SEMPLICE" id=
        "SEC-REVERSE-PROXY-SEMPLICE"></a>18.2. Reverse Proxy</h2>

        <p>Per configurare ed attivare le funzionalit&agrave; di reverse
        Proxy &egrave; necessario istruire Squid affinch&egrave; rimanga in
        ascolto di richieste sulla porta 80, per fare questo utilizzeremo
        il TAG <em>http_port [port]</em></p>

        <table border="0" bgcolor="#E0E0E0" width="100%">
          <tr>
            <td>
              <pre class="PROGRAMLISTING">
http_port 80 
  
</pre>
            </td>
          </tr>
        </table>

        <p>nel caso in cui Squid sia stato installato su un server che
        &egrave; stato configurato con diverse interfacce di rete &egrave;
        possibile configurare il proxy per rimanere in ascolto su uno
        specifico indirizzo IP, questa funzionalit&agrave; pu&ograve;
        essere attivata utilizzando il TAG <em>http_port
        [IP]:[port]</em></p>

        <table border="0" bgcolor="#E0E0E0" width="100%">
          <tr>
            <td>
              <pre class="PROGRAMLISTING">
http_port 192.168.1.1:80<em> </em>
  
</pre>
            </td>
          </tr>
        </table>

        <p>sullo stesso server &egrave; possibile configurare Squid come
        reverse Proxy ma &egrave; necessario installare anche un server
        web. Affinch&eacute; la soluzione di Reverse Proxy funzioni
        &egrave; necessario avviare il web server ma lo stesso deve
        rimanere in ascolto su una porta non standard, a tale scopo
        utilizzeremo la porta 81. Per configurare il web server si faccia
        riferimento alle istruzioni del prodotto specifico. Con il TAG
        <em>httpd_accel_host</em> ed il TAG <em>httpd_accel_port</em>
        indichiamo a Squid il server web da accelerare</p>

        <table border="0" bgcolor="#E0E0E0" width="100%">
          <tr>
            <td>
              <pre class="PROGRAMLISTING">
httpd_accel_host 127.0.0.1<em> </em>
httpd_accel_port 81<em> </em>
  
</pre>
            </td>
          </tr>
        </table>

        <p>possiamo anche utilizzare questa sintassi</p>

        <table border="0" bgcolor="#E0E0E0" width="100%">
          <tr>
            <td>
              <pre class="PROGRAMLISTING">
httpd_accel_host localhost 
httpd_accel_port 81 
  
</pre>
            </td>
          </tr>
        </table>

        <p>in genere il server web o i servers web, come impone una
        architettura ridondata, vengono installati su una o pi&ugrave;
        macchine diverse da quella sulla quale &egrave; in ascolto Squid.
        Se vogliamo accelerare una macchina diversa, Squid pu&ograve;
        essere configurato come Reverse Proxy e rimanere in ascolto sulla
        porta 80. Il contenuto visualizzato dai client http che
        contatteranno la porta 80 di Squid &egrave; quello presente sul
        server Web che fisicamente risiede su un&#39;altra macchina</p>

        <table border="0" bgcolor="#E0E0E0" width="100%">
          <tr>
            <td>
              <pre class="PROGRAMLISTING">
httpd_accel_host nomemacchina.nomedominio.it 
httpd_accel_port 80 
  
</pre>
            </td>
          </tr>
        </table>

        <p>Se si vuole utilizzare Squid sia come server web che come Proxy
        Server &egrave; necessario abilitare il TAG
        <em>httpd_accel_whit_proxy on</em></p>

        <table border="0" bgcolor="#E0E0E0" width="100%">
          <tr>
            <td>
              <pre class="PROGRAMLISTING">
httpd_accel_whit_proxy on
  
</pre>
            </td>
          </tr>
        </table>

        <p>riavviamo Squid e verifichiamo se la nuova configurazione stia
        funzionando correttamente</p>

        <table border="0" bgcolor="#E0E0E0" width="100%">
          <tr>
            <td>
              <pre class="PROGRAMLISTING">
[root@portatilo etc]# squid -k reconfigure
[root@portatilo etc]# netstat -t -l | grep http
tcp        0      0 *:http                  *:*                     LISTEN
  
</pre>
            </td>
          </tr>
        </table>

        <p>l&#39;output del comando <em>netstat</em>(8) dimostra che la
        configurazione di acceleratore http sta funzionando correttamente,
        a questo punto potremmo collegarci al Reverse Proxy.</p>
      </div>

      <div class="SECT1">
        <hr />

        <h2 class="SECT1"><a name="SEC-SSL-REVERSE-PROXY" id=
        "SEC-SSL-REVERSE-PROXY"></a>18.3. SSL Reverse Proxy</h2>

        <p>A partire da squid-2.5.STABLE1 &egrave; stato abilitato il
        supporto SSL<a name="AEN5030" href="#FTN.AEN5030" id=
        "AEN5030">[29]</a>, utilizzando il TAG <em>https_port</em> &egrave;
        possibile configurare Squid come acceleratore per un server HTTP di
        backend, questa opzione sar&agrave; disponibile solo se Squid
        verr&agrave; compilato con la seguente opzione di
        configurazione</p>

        <table border="0" bgcolor="#E0E0E0" width="100%">
          <tr>
            <td>
              <pre class="PROGRAMLISTING">
# ./configure --enable-ssl
  
</pre>
            </td>
          </tr>
        </table>

        <p>abbiamo gi&agrave; detto che questo tipo di opzione funziona
        solo quando Squid viene avviato nella modalit&agrave; di
        acceleratore, nel file di configurazione <em>squid.conf</em>
        possono essere definiti indirizzi di socket multipli inclusi i
        percorsi dei certificati digitali. Tali certificati devono
        necessariamente essere in formato PEM<a name="AEN5036" href=
        "#FTN.AEN5036" id="AEN5036">[30]</a>. Il TAG da utilizzare &egrave;
        <em>https_port [port] cert=path key=path</em></p>

        <table border="0" bgcolor="#E0E0E0" width="100%">
          <tr>
            <td>
              <pre class="PROGRAMLISTING">
https_port 443 cert=/usr/local/squid/etc/key.crt \
key=/usr/local/squid/etc/key.key
  
</pre>
            </td>
          </tr>
        </table>

        <p>prima di attivare Squid come acceleratore sulla porta 443
        dobbiamo necessariamente generare i certificati digitali in formato
        PEM</p>

        <table border="0" bgcolor="#E0E0E0" width="100%">
          <tr>
            <td>
              <pre class="PROGRAMLISTING">
[root@portatilo root]# openssl req -x509 -newkey rsa:2048 -keyout \
key.key -out key.crt -days 365 -nodes
Using configuration from /usr/share/ssl/openssl.cnf
Generating a 2048 bit RSA private key
................................................................................+++
......+++
writing new private key to &#39;key.key&#39;
-----
You are about to be asked to enter information that will be incorporated
into your certificate request.
What you are about to enter is what is called a Distinguished Name or a DN.
There are quite a few fields but you can leave some blank
For some fields there will be a default value,
If you enter &#39;.&#39;, the field will be left blank.
-----
Country Name (2 letter code) [GB]:IT
State or Province Name (full name) [Berkshire]:Italy
Locality Name (eg, city) [Newbury]:Mia_Citt&agrave;
Organization Name (eg, company) [My Company Ltd]:Organizzazione
Organizational Unit Name (eg, section) []:Networking
Common Name (eg, your name or your server&#39;s hostname) []:host.dominio.net
Email Address []:squid@dominio.net
  
</pre>
            </td>
          </tr>
        </table>

        <p>spostiamo i certificati digitali appena generati nella directory
        dove vengono memorizzati i file di configurazione di Squid</p>

        <table border="0" bgcolor="#E0E0E0" width="100%">
          <tr>
            <td>
              <pre class="PROGRAMLISTING">
[root@portatilo root]# mv key.* /usr/local/squid/etc/
  
</pre>
            </td>
          </tr>
        </table>

        <p>con il TAG <em>httpd_accel_host</em> impostiamo il server web
        che intendiamo accelerare, con il TAG <em>httpd_accel_port</em>
        definiamo la porta sulla quale rimane in ascolto
        <em>httpd_accel_host</em></p>

        <table border="0" bgcolor="#E0E0E0" width="100%">
          <tr>
            <td>
              <pre class="PROGRAMLISTING">
httpd_accel_host 10.251.10.254
httpd_accel_port 80
  
</pre>
            </td>
          </tr>
        </table>

        <p>se eseguiamo Squid come acceleratore e disponiamo di un singolo
        server di backend, impostiamo il TAG
        <em>httpd_accel_single_host</em> sul valore <em>on</em>. Questa
        impostazione determina che le richieste vengano ruotate
        direttamente all&#39;unico server di backend disponibile. Se invece
        abbiamo diversi server di backend, il valore del TAG
        <em>httpd_accel_single_host</em> deve essere impostato ad
        <em>off</em>, in questo caso dovremo utilizzare un sistema
        redirector per ruotare le richieste verso il server di backend
        appropriato</p>

        <table border="0" bgcolor="#E0E0E0" width="100%">
          <tr>
            <td>
              <pre class="PROGRAMLISTING">
httpd_accel_single_host off
  
</pre>
            </td>
          </tr>
        </table>

        <p>nel caso volessimo utilizzare Squid sia come httpd accelerator
        che come proxy server, dovremmo utilizzare il TAG
        <em>httpd_accel_whit_proxy on</em></p>

        <table border="0" bgcolor="#E0E0E0" width="100%">
          <tr>
            <td>
              <pre class="PROGRAMLISTING">
httpd_accel_with_proxy on
  
</pre>
            </td>
          </tr>
        </table>

        <p>le richieste HTTP/1.1 includono un header denominato host, in
        realt&agrave; si tratta del nome dell&#39;host che viene
        estrapolato dalla URL. l&#39;header host viene utilizzato per
        definire i virtualhost basati sul nome di dominio, se il nostro
        acceleratore fornisce un servizio di domain based virtual hosts
        utilizzando lo stesso indirizzo IP, allora dovremo utilizzare il
        TAG <em>httpd_accel_uses_host_header on</em>. E&#39; necessario
        utilizzare questa opzione se si vuole utilizzare Squid come
        transparent Proxy</p>

        <table border="0" bgcolor="#E0E0E0" width="100%">
          <tr>
            <td>
              <pre class="PROGRAMLISTING">
httpd_accel_uses_host_header off
  
</pre>
            </td>
          </tr>
        </table>

        <p>eseguiamo il reload di Squid e verifichiamo se la nuova
        configurazione funziona correttamente</p>

        <table border="0" bgcolor="#E0E0E0" width="100%">
          <tr>
            <td>
              <pre class="PROGRAMLISTING">
[root@portatilo etc]# squid -k reconfigure
[root@portatilo etc]# netstat -t -l | grep https
tcp        0      0 *:https                 *:*                     LISTEN
  
</pre>
            </td>
          </tr>
        </table>

        <p>come possiamo vedere dall&#39;output del comando
        <em>netstat</em>(8) ora disponiamo di un server web che rimane in
        ascolto sulla porta 443 (SSL).</p>
      </div>

      <div class="SECT1">
        <hr />

        <h2 class="SECT1"><a name="SEC-ESEMPI-E-SITUAZIONI-REALI" id=
        "SEC-ESEMPI-E-SITUAZIONI-REALI"></a>18.4. Esempi e situazioni
        reali</h2>

        <p>Ora proponiamo una interessante panoramica di esempi che possono
        essere implementati in situazioni reali, altri esempi sono
        reperibili presso la URL <a href="http://www.visolve.com/" target=
        "_top">http://www.visolve.com/</a> &egrave; particolare
        l&#39;attenzione che deve essere prestata nella implementazione
        delle ACL visto che in genere si pu&ograve; utilizzare
        l&#39;acceleratore anche come proxy server.</p>

        <div class="SECT2">
          <hr />

          <h3 class="SECT2"><a name="SUBSEC-REVERSE-NEWHOST" id=
          "SUBSEC-REVERSE-NEWHOST"></a>18.4.1. Reverse Proxy di Server web
          o cluster HA installati su una macchina differente</h3>

          <p>il reverse proxy Squid funziona come <em>acceleratore</em> per
          un server web che rimane in ascolto su una macchina differente da
          quella sulla quale opera Squid</p>

          <table border="0" bgcolor="#E0E0E0" width="100%">
            <tr>
              <td>
                <pre class="PROGRAMLISTING">
http_port 80 
acl allowed_hosts src 0.0.0.0/0.0.0.0 
http_access allow allowed_hosts 
httpd_accel_host 192.168.0.3 
httpd_accel_port 80<em> </em>
httpd_accel_single_host on 
httpd_accel_with_proxy on
httpd_accel_uses_host_header off 
   
</pre>
              </td>
            </tr>
          </table>
        </div>

        <div class="SECT2">
          <hr />

          <h3 class="SECT2"><a name="SUBSEC-REVERSE-LOCALHOST" id=
          "SUBSEC-REVERSE-LOCALHOST"></a>18.4.2. Reverse Proxy di server
          web installato sulla stessa macchina che esegue Squid</h3>

          <p>il reverse proxy Squid funziona come <em>acceleratore</em> per
          un server web installato sulla stessa macchina sulla quale viene
          eseguito Squid</p>

          <table border="0" bgcolor="#E0E0E0" width="100%">
            <tr>
              <td>
                <pre class="PROGRAMLISTING">
http_port 80 
acl allowed_hosts src 0.0.0.0/0.0.0.0 
http_access allow allowed_hosts 
httpd_accel_host 127.0.0.1 
httpd_accel_port 81 
httpd_accel_single_host on 
httpd_accel_with_proxy on 
httpd_accel_uses_host_header off 
   
</pre>
              </td>
            </tr>
          </table>
        </div>

        <div class="SECT2">
          <hr />

          <h3 class="SECT2"><a name="SUBSEC-REVERSE-MULTIDOM" id=
          "SUBSEC-REVERSE-MULTIDOM"></a>18.4.3. Reverse Proxy per domini
          multipli</h3>

          <p>il reverse proxy Squid funziona come <em>acceleratore</em> per
          domini multipli puntando a diversi server web che si trovano a
          valle dell&#39;acceleratore e che possono essere pi&ugrave; di
          uno, per far funzionare questo tipo di configurazione &egrave;
          necessario compilare Squid con il supporto per il DNS interno</p>

          <table border="0" bgcolor="#E0E0E0" width="100%">
            <tr>
              <td>
                <pre class="PROGRAMLISTING">
./configure --disable-internal-dns
   
</pre>
              </td>
            </tr>
          </table>

          <p>questa &egrave; l&#39;opzione di configurazione che installa
          l&#39;eseguibile dell&#39;<em>external dnsserver</em>, vediamo
          ora un&#39;esempio per questo tipo di configurazione</p>

          <table border="0" bgcolor="#E0E0E0" width="100%">
            <tr>
              <td>
                <pre class="PROGRAMLISTING">
http_port 80 
acl allowed_hosts src 0.0.0.0/0.0.0.0 
http_access allow allowed_hosts 
httpd_accel_host virtual 
httpd_accel_port 80 
httpd_accel_single_host off<em> </em>
httpd_accel_with_proxy on 
httpd_accel_uses_host_header off 
   
</pre>
              </td>
            </tr>
          </table>

          <p>ora grazie al sistema del domain name system (DNS) si
          seleziona e si definisce il reverse proxy per i rispettivi
          domini, ad un indirizzo IP sulla rete pubblica internet possono
          corrispondere diversi nomi di dominio</p>

          <table border="0" bgcolor="#E0E0E0" width="100%">
            <tr>
              <td>
                <pre class="PROGRAMLISTING">
www.merlinobbs.net 12.12.12.1
www.marsicalug.it  12.12.12.1 
www.plutonet.org   12.12.12.1 
   
</pre>
              </td>
            </tr>
          </table>

          <p>definiamo delle entry nel domain name system a cui fa
          riferimento diretto il reverse proxy server. Sar&agrave;
          necessario configurare un sistema DNS falso (fake DNS) che
          risolve i nomi per la rete interna nella quale sono installati i
          server web reali, &egrave; anche possibile inserire delle entry
          nel file <em>/etc/hosts</em>.</p>

          <table border="0" bgcolor="#E0E0E0" width="100%">
            <tr>
              <td>
                <pre class="PROGRAMLISTING">
www.merlinobbs.net 192.168.1.21 
www.marsicalug.it  192.168.1.30 
www.plutonet.org   192.168.1.7 
   
</pre>
              </td>
            </tr>
          </table>

          <p>Attenzione: utilizzando la funzione <em>httpd_accel_host</em>
          verr&agrave; disabilitato il proxy-caching e il protocollo
          <em>ICP</em>. Se volete abilitare anche queste
          funzionalit&agrave; si render&agrave; necessario abilitare
          l&#39;opzione <em>httpd_accel_with_proxy</em>.</p>
        </div>

        <div class="SECT2">
          <hr />

          <h3 class="SECT2"><a name="SUBSEC-SSL-REVERSE-PROXY" id=
          "SUBSEC-SSL-REVERSE-PROXY"></a>18.4.4. SSL Reverse Proxy di un
          server web o di un cluster HA installato su una macchina
          differente</h3>

          <p>il reverse proxy Squid funziona come <em>acceleratore SSL</em>
          per un server web che rimane in ascolto su una macchina
          differente da quella sulla quale opera Squid</p>

          <table border="0" bgcolor="#E0E0E0" width="100%">
            <tr>
              <td>
                <pre class="PROGRAMLISTING">
https_port 443 cert=/usr/local/squid/etc/key.crt \
key=/usr/local/squid/etc/key.key
httpd_accel_host 10.251.10.254
httpd_accel_port 80
httpd_accel_single_host off
httpd_accel_with_proxy on
httpd_accel_uses_host_header off
   
</pre>
              </td>
            </tr>
          </table>
        </div>
      </div>
    </div>

    <div class="CHAPTER">
      <hr />

      <h1><a name="CHA-PROXY-LOAD-BALANCER" id=
      "CHA-PROXY-LOAD-BALANCER"></a>Capitolo 19. Proxy load balancer</h1>

      <div class="SECT1">
        <h2 class="SECT1"><a name="SEC-PREAMBOLO-LOAD-BALANCER" id=
        "SEC-PREAMBOLO-LOAD-BALANCER"></a>19.1. Preambolo</h2>

        <p>Ipotizziamo ora di configurare una cache gerarchica nel contesto
        di una WAN di dimensioni ragguardevoli. Prima di fare questo
        analizziamo le fondamenta della configurazione automatica dei
        browser web pi&ugrave; comuni come Netscape ed Internet
        Explorer.</p>
      </div>

      <div class="SECT1">
        <hr />

        <h2 class="SECT1"><a name="SEC-WPAD-PROTOCOL" id=
        "SEC-WPAD-PROTOCOL"></a>19.2. WPAD protocol</h2>

        <p>Il <em>Web Proxy Autodiscovery Protocol</em> &egrave; un
        protocollo di livello 7 che &egrave; stato elaborato da un gruppo
        di produttori software (Microsoft, RealNetworks, Sun Microsystem ed
        InkTomi.....) che consente all&#39;utente finale di configurare il
        proprio browser web in maniera trasparente, ovvero senza fare
        ricorso ad alcuna configurazione manuale. In particolare, tramite
        la modalit&agrave; di autoconfigurazione, <em>&egrave; possibile
        definire automaticamente</em> l&#39;accesso al proxy server
        principale all&#39;interno di un dominio (FQDN).</p>

        <p>Il principio &egrave; molto semplice: il browser web, che
        implementa il protocollo <em>WPAD</em>, inizia la sua indagine
        interrogando il sistema di risoluzione dei nomi, il Domain Name
        System (ISC <a href="http://www.isc.org/products/BIND/" target=
        "_top">Bind</a>), alla ricerca del nome host <em>wpad.</em></p>

        <p>ecco un esempio di record <em>A - ADDRESS</em> (indirizzo
        IP)</p>

        <table border="0" bgcolor="#E0E0E0" width="100%">
          <tr>
            <td>
              <pre class="PROGRAMLISTING">
wpad    IN     A     192.168.1.200
  
</pre>
            </td>
          </tr>
        </table>

        <p>ecco un esempio di record <em>CNAME</em> (canonical name)</p>

        <table border="0" bgcolor="#E0E0E0" width="100%">
          <tr>
            <td>
              <pre class="PROGRAMLISTING">
proxy   IN     A     192.168.1.100
wpad    IN     CNAME proxy
  
</pre>
            </td>
          </tr>
        </table>

        <p>se esiste un <em>record A</em> (address) o un <em>record
        CNAME</em> (canonical name) corrispondente a tale nome host
        nell&#39;ambito di un dominio qualificato, il browser web
        cercher&agrave; di caricare il file di configurazione automatica
        direttamente dalla URLs</p>

        <table border="0" bgcolor="#E0E0E0" width="100%">
          <tr>
            <td>
              <pre class="PROGRAMLISTING">
http://wpad/wpad.dat
  
</pre>
            </td>
          </tr>
        </table>

        <p>Il server Web corrispondente al nome host <em>wpad</em> ha
        memorizzato nella sua <em>Document root</em> il file
        <em>wpad.dat</em>, Il browser web cercher&agrave; di leggere quella
        URLs per auto configurarsi. Il browser web esegue le direttive
        scritte in Java script che sono contenute in quel file.
        Naturalmente un browser web che non supporta Java o Java script non
        sar&agrave; in grado di autoconfigurarsi.</p>

        <p>In tutti i casi un file <em>wpad.dat</em> o il file
        <em>proxy.pac</em>, per poter essere utilizzato, deve essere messo
        in linea su un server web opportunamente configurato. Per far si
        che il browser web sia in grado di autoconfigurarsi &egrave;
        necessario aggiungere un particolare tipo di <em>mime-type</em> che
        consente il caricamento e l&#39;esecuzione del file
        <em>wpad.dat</em> come Javascript autoconfigurante.</p>

        <p>Nel caso si utilizzi come server Web il comunissimo e
        potentissimo Apache &egrave; sufficiente editare il file
        <em>/etc/mime.types</em> aggiungendo la seguente riga</p>

        <table border="0" bgcolor="#E0E0E0" width="100%">
          <tr>
            <td>
              <pre class="PROGRAMLISTING">
application/x-ns-proxy-autoconfig pac dat 
  
</pre>
            </td>
          </tr>
        </table>

        <p>vediamo di seguito un esempio concreto di file
        <em>proxy.pac</em> o <em>wpad.dat</em></p>

        <table border="0" bgcolor="#E0E0E0" width="100%">
          <tr>
            <td>
              <pre class="PROGRAMLISTING">
function FindProxyForURL( url, host ) 
{ 
  if( isPlainHostName( host ) ||          // no domain specification
      dnsDomainIs( host, &quot;mynet.com&quot; ) || // MyNet local domain
      shExpMatch( url, &quot;https*&quot; ) ||      // secure protocols 
      shExpMatch( url, &quot;snews*&quot; ) )
    return &quot;DIRECT&quot;; 
  else
    return &quot;PROXY calimero.mynet.com:3128; &quot; +
              &quot;PROXY rocco.mynet.com:3128; &quot; + 
      &quot;DIRECT&quot;;
} 
  
</pre>
            </td>
          </tr>
        </table>

        <p>il file di autoconfigurazione punta su 2 proxy server diversi,
        vediamo ancora un esempio per la configurazione del DNS (ISC
        Bind)</p>

        <table border="0" bgcolor="#E0E0E0" width="100%">
          <tr>
            <td>
              <pre class="PROGRAMLISTING">
www         IN     A       192.168.10.25
;
wpad        IN     CNAME   www
  
</pre>
            </td>
          </tr>
        </table>

        <p>l&#39;host www corrisponde all&#39;indirizzo IP 192.168.10.25 ed
        il suo nome canonico (o alias) &egrave; wpad.</p>

        <p>Attualmente, solo il browser Microsoft Internet Explorer
        supporta le funzionalit&agrave; WPAD e l&#39;<a href=
        "http://www.web-cache.com/Writings/Internet-Drafts/draft-ietf-wrec-wpad-01.txt"
           target="_top">Internet Draft</a> che ne descrive le
           carratteristiche &eacute; scaduto. Per maggiori dettagli sulla
           scrittura degli scripts riferirsi a <em>Navigator Proxy
           Auto-Config File Format</em> (<a href=
           "http://wp.netscape.com/eng/mozilla/2.0/relnotes/demo/proxy-live.html"
           target=
           "_top">http://wp.netscape.com/eng/mozilla/2.0/relnotes/demo/proxy-live.html</a>).</p>

        <p>Questi script di autoconfigurazione sono comunque supportati
        correttamente in modalit&agrave; manuale dalla maggior parte dei
        Browser Internet (Mozilla, Opera, Konqueror, etc.).</p>
      </div>

      <div class="SECT1">
        <hr />

        <h2 class="SECT1"><a name="SEC-DHCP-E-CONF" id=
        "SEC-DHCP-E-CONF"></a>19.3. DHCP e configurazione automatica del
        browser</h2>

        <p>E&#39; possibile utilizzare ISC DHCP (<a href=
        "http://www.isc.org/products/DHCP/" target=
        "_top">http://www.isc.org/products/DHCP/</a>) per configurare
        automaticamente i browser web al protocollo WPAD. Questa tecnica
        consente di configurare qualsiasi URL come PAC URL</p>

        <table border="0" bgcolor="#E0E0E0" width="100%">
          <tr>
            <td>
              <pre class="PROGRAMLISTING">
option wpad code 252 = text;
option wpad &quot;http://www.example.com/proxy.pac&quot;;
  
</pre>
            </td>
          </tr>
        </table>

        <p>la modalit&agrave; DHCP <em>non lavora correttamente</em> con
        diverse versioni di internet Explorer, la modalit&agrave; DNS
        rimane quella consigliata</p>
      </div>

      <div class="SECT1">
        <hr />

        <h2 class="SECT1"><a name="SEC-FAIL-OVER-E-LOAD-BALANCER" id=
        "SEC-FAIL-OVER-E-LOAD-BALANCER"></a>19.4. Fail over e load
        balancer</h2>

        <p>In una WAN di dimensioni ragguardevoli, per garantire
        continuit&agrave; del servizio ed affidabilit&agrave;, &egrave;
        sempre consigliato installare un sistema di Cluster in HA<a name=
        "AEN5171" href="#FTN.AEN5171" id="AEN5171">[31]</a>. Data la
        complessit&agrave; di questo tipo di configurazione o qualora non
        fosse possibile realizzare un sistema cos&igrave; complesso,
        pu&ograve; essere una buona idea configurare un ambiente di fail
        over con relativo load balancer. Questo tipo di configurazione
        garantir&agrave; agli utenti un corretto e costante utilizzo delle
        risorse della rete internet. Nel caso in cui il proxy 1 dovesse
        avere dei problemi i client andrebbero a recuperare le informazioni
        presenti nella cache di un&#39;altro proxy sulla base dello schema
        rappresentato nella seguente immagine</p>

        <p><img src="images/loadbalancer-0.png" alt="" /></p>Sfruttando le
        specifiche del protocollo <em>WPAD</em>, le richieste
        <em>HTTP</em>, <em>HTTPS</em> ed <em>FTP</em> effettuate dai
        browser web e provenienti dalla rete degli utenti (nuovola di rete
        celeste) verranno automaticamente instradate verso il server Web
        che &egrave; stato appunto predisposto alle specifiche del
        protocollo <em>WPAD</em>, questo web server detiene nella
        <em>Document root</em> il Java script di Super LoadBalancing che,
        come abbiamo visto in precedenza, consentir&agrave; ai browser web
        di utilizzare le funzionalit&agrave; di URL hashing ed eseguire il
        forward delle richieste http.
        <br />
        <br />

        <p>I due host che eseguono l&#39;appliance Squid effettuano il
        forward della richiesta verso la rete internet attraversando il
        firewall. Nel caso in cui uno dei due server proxy venisse a
        mancare (mancato funzionamento, manutenzione, upgrade software,
        upgrade hardware....) subentrerebbe l&#39;host 2.</p>

        <p>In genere i due proxy server eseguono la cache in
        modalit&agrave; gemella e comunicano tra loro tramite il protocollo
        ICP, le due o pi&ugrave; macchine che sono state adibite a fornire
        lo script di super Load Balancer dovranno eseguire delle
        configurazioni speculari. E&#39; fondamentale la configurazione del
        DNS ISC Bind (<a href="http://www.isc.org/products/BIND/" target=
        "_top">http://www.isc.org/products/BIND/</a>) che esegue la
        risoluzione dei nomi host</p>

        <table border="0" bgcolor="#E0E0E0" width="100%">
          <tr>
            <td>
              <pre class="PROGRAMLISTING">
proxy1     IN     A     192.168.10.4
proxy2     IN     A     192.168.10.14
;
wpad       IN     CNAME proxy1
           IN     CNAME proxy2
  
</pre>
            </td>
          </tr>
        </table>

        <p>il nome <em>wpad</em> &egrave; un <em>nome canonico</em> o
        <em>alias</em> per gli host <em>proxy1</em> e <em>proxy2</em> che,
        assieme al servizio Squid, eseguono anche una copia del server web
        <em>Apache</em>. Di seguito ecco le specifiche logiche del super
        proxy cache a due vie da realizzato in una rete geografica che
        pu&ograve; tranquillamente essere definita come WAN di medie
        dimensioni.</p>

        <p><img src="images/loadbalancer-1.png" alt="" /></p>Ecco un
        dettaglio delle specifiche hardware e software adottate
        <br />
        <br />

        <table border="0" bgcolor="#E0E0E0" width="100%">
          <tr>
            <td>
              <pre class="PROGRAMLISTING">
Pentium III 500 Mhz 256 Mb RAM      Pentium III 500 Mhz 384 Mb RAM
OS Linux (Kernel 2.4.x)             OS Linux (Kernel 2.4.x)
Squid appliance 2.4 St. 6 patched   Squid appliance 2.4 St. 6 patched
Supporto SNMP abilitato             Supporto SNMP abilitato
n. 1 Disco EIDE da 10 Gb 5000 RPM   n. 2 Dischi EIDE da 20 Gb 7200 RPM
64 Mb di cache_mem                  96 Mb di cache_mem
2524 Mb di cache su FS EXT3         2500 Mb di cache su FS EXT3
Server httpd on board               Server httpd on board
  
</pre>
            </td>
          </tr>
        </table>

        <p>Di seguito un esempio di file <em>proxy.pac</em> realizzato
        dalla <em>Sharp Corporation</em>, ottimizzato per la configurazione
        Super proxy server in modalit&agrave; load Balancer.</p>

        <table border="0" bgcolor="#E0E0E0" width="100%">
          <tr>
            <td>
              <pre class="PROGRAMLISTING">
<em>/*</em>
<em> * Super Proxy Script</em>
<em> *</em>
<em> * by SHARP Corp.</em>
<em> *</em>
<em> * Take a look at http://naragw.sharp.co.jp/sps/</em>
<em> * for theory and operation.</em>
<em> *  </em>
<em> */  </em>
function FindProxyForURL(url, host)  
{  
/* your original script here */   
 if( dnsDomainIs( host, &quot;dominio.com&quot; ) ||
     dnsDomainIs( host, &quot;love.dominio.com&quot; ) ||     
     dnsDomainIs( host, &quot;localhost&quot; ) ||       
     isPlainHostName( host ) ||       
     isInNet( host, &quot;127.0.0.1&quot;, &quot;255.255.255.255&quot; )  ||
     isInNet( host, &quot;192.168.0.0&quot;, &quot;255.255.0.0&quot; ) )    
  return &quot;DIRECT&quot;;   
 else  
/* end of your original script */   
 var n = URLhash2(url) % 2;   
 if (n &lt; 1)    
  return &quot;PROXY proxy2.dominio.com:3128;PROXY proxy.dominio.com:3128;DIRECT&quot;;   
 if (n &lt; 2)    
  return &quot;PROXY proxy.merlino.bbs:3128;PROXY proxy2.merlino.bbs:3128;DIRECT&quot;;  
}  
/* make check sum of URL string */  
/* v1.0 by SHARP Corp     Copyright 1996-1997 */  
function URLhash(name)  
{  
 var  cnt=0;   
 var str=name.toLowerCase(name);   
 if ( str.length ==0) {     
   return cnt;   
 }   
 for(var i=0;i &lt; str.length ; i++) {      
   var ch= atoi(str.substring(i,i + 1));    
   cnt = cnt + ch;   }   return cnt ;  
}  
<em>/*     </em>
<em>  URLhash2( ) for directory name hash computing version.</em>
<em>  written by SHARP Corp in Feb 1997 </em>
<em>  </em>
<em>  Objects in a same directory will be accessed via the same proxy.     </em>
<em>  Use URLhash2( ) instead of URLhash( ) if you prefer to use persistent</em>
<em>  connection in HTTP 1.1</em>
<em>  http://www.sharp.co.jp/sample/test/img/mebius.gif</em>
<em>  http://www.sharp.co.jp/sample/test/img/zaurus.gif</em>
<em>  http://www.sharp.co.jp/sample/test/img/wiz.gif</em>
<em>  &lt;-------------------------------------&gt;           </em>
<em>        directory name hashing here  </em>
<em>*/</em>
function URLhash2(name)  {  
  var  cnt=0;  
  var  dirptr=0;   
  var str=name.toLowerCase(name);   
  if ( str.length ==0) {     
    return cnt;   
  }  
/* skip filename in directory */   
  for(var i=str.length - 1;i &gt;=0 ; i--) {    
    if ( str.substring(i,i +1) == &#39;/&#39; ) {     
      dirptr = i+1 ;     break;    
    }   
  }   
  for(var i=0;i &lt; dirptr; i++) {      
    var ch= atoi(str.substring(i,i + 1));    
    cnt = cnt + ch;   
  }   return cnt ;  
}  
function atoi(charstring)  {   
  if ( charstring == &quot;a&quot; ) return 0x61; if ( charstring == &quot;b&quot; ) return 0x62;   
  if ( charstring == &quot;c&quot; ) return 0x63; if ( charstring == &quot;d&quot; ) return 0x64;   
  if ( charstring == &quot;e&quot; ) return 0x65; if ( charstring == &quot;f&quot; ) return 0x66;   
  if ( charstring == &quot;g&quot; ) return 0x67; if ( charstring == &quot;h&quot; ) return 0x68;   
  if ( charstring == &quot;i&quot; ) return 0x69; if ( charstring == &quot;j&quot; ) return 0x6a;   
  if ( charstring == &quot;k&quot; ) return 0x6b; if ( charstring == &quot;l&quot; ) return 0x6c;   
  if ( charstring == &quot;m&quot; ) return 0x6d; if ( charstring == &quot;n&quot; ) return 0x6e;   
  if ( charstring == &quot;o&quot; ) return 0x6f; if ( charstring == &quot;p&quot; ) return 0x70;   
  if ( charstring == &quot;q&quot; ) return 0x71; if ( charstring == &quot;r&quot; ) return 0x72;   
  if ( charstring == &quot;s&quot; ) return 0x73; if ( charstring == &quot;t&quot; ) return 0x74;   
  if ( charstring == &quot;u&quot; ) return 0x75; if ( charstring == &quot;v&quot; ) return 0x76;   
  if ( charstring == &quot;w&quot; ) return 0x77; if ( charstring == &quot;x&quot; ) return 0x78;   
  if ( charstring == &quot;y&quot; ) return 0x79; if ( charstring == &quot;z&quot; ) return 0x7a;   
  if ( charstring == &quot;0&quot; ) return 0x30; if ( charstring == &quot;1&quot; ) return 0x31;   
  if ( charstring == &quot;2&quot; ) return 0x32; if ( charstring == &quot;3&quot; ) return 0x33;   
  if ( charstring == &quot;4&quot; ) return 0x34; if ( charstring == &quot;5&quot; ) return 0x35;   
  if ( charstring == &quot;6&quot; ) return 0x36; if ( charstring == &quot;7&quot; ) return 0x37;   
  if ( charstring == &quot;8&quot; ) return 0x38; if ( charstring == &quot;9&quot; ) return 0x39;   
  if ( charstring == &quot;.&quot; ) return 0x2e; return 0x20;  
}
  
</pre>
            </td>
          </tr>
        </table>

        <p>E&#39; necessario sottolineare che questo tipo di configurazione
        non garantisce comunque alcuna ridondanza e non determina nessun
        fattore di alta disponibilit&agrave; del servizio.</p>
      </div>
    </div>

    <div class="CHAPTER">
      <hr />

      <h1><a name="CHA-LIMITAZIONE-DELLA-BANDA-PER-CLASSI" id=
      "CHA-LIMITAZIONE-DELLA-BANDA-PER-CLASSI"></a>Capitolo 20. Limitazione
      della banda per classi</h1>

      <div class="SECT1">
        <h2 class="SECT1"><a name="SEC-LIMITARE-LA-BANDA-DISPONIBILE" id=
        "SEC-LIMITARE-LA-BANDA-DISPONIBILE"></a>20.1. Preambolo</h2>

        <p>E&#39; possibile limitare i costi utilizzando al meglio le
        risorse di rete, una corretta gestione dell&#39;ampiezza della
        banda disponibile pu&ograve; essere la soluzione di molti problemi.
        Squid &egrave; anche in grado rispondere a questo tipo di esigenza
        in quanto pu&ograve; gestire la banda disponibile. Per controllare
        l&#39;ampiezza della banda Squid ricorre al TAG <em>delay
        pools</em>.</p>
      </div>

      <div class="SECT1">
        <hr />

        <h2 class="SECT1"><a name="SEC-SQUID-DELAY-POOLS" id=
        "SEC-SQUID-DELAY-POOLS"></a>20.2. Squid ed i Delay pools</h2>

        <p>L&#39;idea di realizzare questa interessante features &egrave;
        partita dalla <em>Western Australian University</em> che intendeva
        limitare i costi riducendo il traffico. Il codice sorgente di
        questo <em>hack</em> fu introdotto nella versione 1 Squid e
        prendeva il nome di <em>DELAY_HACK</em>. Nella versione 2 di Squid
        questa funzione ha preso il nome di <em>delay pools</em>. Nella
        versione 2.2 di Squid, il codice del <em>delay pools</em> &egrave;
        stato totalmente riscritto per offrire maggiori performance ed
        affidabilit&agrave;.</p>

        <p>Per utilizzare questa funzionalit&agrave; &egrave; necessario
        specificare la seguente opzione di configure</p>

        <table border="0" bgcolor="#E0E0E0" width="100%">
          <tr>
            <td>
              <pre class="PROGRAMLISTING">
./configure --enable-delay-pools
  
</pre>
            </td>
          </tr>
        </table>

        <p>e ricompilare Squid.</p>

        <p>Attenzione: molto spesso i package binari forniti con le
        distribuzioni non sono compilati con il supporto per Delay
        pools.</p>

        <p>Non &egrave; possibile limitare la velocit&agrave; di una
        singola connessione HTTP ma &egrave; invece possibile limitare la
        banda per singole workstation o di intere subnet. &Egrave; inoltre
        possibile limitare la banda per singoli utenti o gruppi di utenti.
        Per ridurre l&#39;utilizzo di bandwidth su una specifica subnet
        viene definita una ACL che identifica la subnet stessa. Per
        limitare il traffico di una specifica workstation si definisce una
        ACL che identifica quella macchina. Per limitare un gruppo di
        macchine &egrave; possibile utilizzare un <em>delay_pools</em> di
        classe 2 o 3. Infine, per limitare il traffico di singoli utenti o
        gruppi di utenti, &eacute; possibile definire delle ACL basate
        sull&#39;<a href="#CHA-AUTENTICAZIONE-UTENTI">autenticazione degli
        utenti</a> e su <a href="#SEC-EXTERNAL-ACL">ACL esterne</a>.</p>

        <div class="SECT2">
          <hr />

          <h3 class="SECT2"><a name="SUBSEC-LIMITARE-128K" id=
          "SUBSEC-LIMITARE-128K"></a>20.2.1. Limitare la banda per singole
          connessioni a 128 kbps</h3>

          <p>Un esempio che limita la banda a 128 Kbps per singole
          connessioni provenienti da 64 subnet (partendo dall&#39;indirizzo
          192.168.0.0 per finire all&#39;indirizzo 192.168.63.255),
          impostiamo le ACL che identificano il traffico da limitare</p>

          <table border="0" bgcolor="#E0E0E0" width="100%">
            <tr>
              <td>
                <pre class="PROGRAMLISTING">
acl only128kusers src 192.168.1.0/255.255.192.0 
acl all src 0.0.0.0/0.0.0.0 
   
</pre>
              </td>
            </tr>
          </table>

          <p>impostiamo il TAG <em>delay_pools</em></p>

          <table border="0" bgcolor="#E0E0E0" width="100%">
            <tr>
              <td>
                <pre class="PROGRAMLISTING">
delay_pools 1 
delay_class 1 3 
delay_access 1 allow only128kusers 
delay_access 1 deny all 
delay_parameters 1 64000/64000 -1/-1 16000/64000 
   
</pre>
              </td>
            </tr>
          </table>
        </div>

        <div class="SECT2">
          <hr />

          <h3 class="SECT2"><a name="SUBSEC-LIMITARE-512KBPS" id=
          "SUBSEC-LIMITARE-512KBPS"></a>20.2.2. Limitare la banda totale a
          512 kbps</h3>

          <p>Vediamo ora un esempio con il quale limitiamo la banda totale
          di Squid a 512 Kbps, anche in questo caso impostiamo la ACL che
          identifica il traffico da limitare</p>

          <table border="0" bgcolor="#E0E0E0" width="100%">
            <tr>
              <td>
                <pre class="PROGRAMLISTING">
acl all src 0.0.0.0/0.0.0.0
   
</pre>
              </td>
            </tr>
          </table>

          <p>impostiamo il TAG <em>delay_pools</em></p>

          <table border="0" bgcolor="#E0E0E0" width="100%">
            <tr>
              <td>
                <pre class="PROGRAMLISTING">
delay_pools 1
delay_class 1 1
delay_access 1 allow all
delay_parameters 1 64000/64000    # 512 kbits = 64 kbytes per second
   
</pre>
              </td>
            </tr>
          </table>
        </div>

        <div class="SECT2">
          <hr />

          <h3 class="SECT2"><a name="SUBSEC-LIMITARE-HDSL" id=
          "SUBSEC-LIMITARE-HDSL"></a>20.2.3. Limitare la banda con una
          linea a 2 Mbps</h3>

          <p>Ipotiziamo di avere a disposizione una connessione dedicata
          con una banda massima di 2 Mbps, definiamo ora alcune ACL che ci
          consentono di identificare il traffico da limitare</p>

          <table border="0" bgcolor="#E0E0E0" width="100%">
            <tr>
              <td>
                <pre class="PROGRAMLISTING">
acl outgoing src 192.168.100.2/255.255.255.255
acl student src 192.168.200.0/255.255.255.0
acl admin src 192.168.300.0/255.255.255.0
acl magic_words1 url_regex -i 192.168
acl magic_words2 url_regex -i ftp .exe .mp3 .vqf .tar.gz .gz .rpm \
.zip .rar .avi .mpeg .mpe .mpg .qt .ram .rm .iso .raw .wav .mov
   
</pre>
              </td>
            </tr>
          </table>

          <p>impostiamo il TAG <em>delay_pools</em></p>

          <table border="0" bgcolor="#E0E0E0" width="100%">
            <tr>
              <td>
                <pre class="PROGRAMLISTING">
delay_pools 2
   
</pre>
              </td>
            </tr>
          </table>

          <p>abbiamo detto che la linea dedicata &egrave; un link HDSL a
          2Mbits, il valore di 2 Mbits &egrave; pari a 256 Kbytes per
          secondo e 256 KB/s sono pari a 5 KB/s. Nell&#39;esempio seguente
          impostiamo 256 KB/s di bandwith per l&#39;intero network, ma solo
          5 KB/s verranno riservati ad ogni nodo</p>

          <table border="0" bgcolor="#E0E0E0" width="100%">
            <tr>
              <td>
                <pre class="PROGRAMLISTING">
delay_class 1 2
delay_parameters 1 256000/256000 5000/256000
delay_access 1 allow magic_words2
delay_access 1 allow student
delay_access 1 allow admin
   
</pre>
              </td>
            </tr>
          </table>

          <p>con il valore <em>-1/-1</em> indichiamo che non vi sono limiti
          di sorta per il traffico locale</p>

          <table border="0" bgcolor="#E0E0E0" width="100%">
            <tr>
              <td>
                <pre class="PROGRAMLISTING">
delay_class 2 2
delay_parameters 2 -1/-1 -1/-1
delay_access 2 allow magic_words1
   
</pre>
              </td>
            </tr>
          </table>

          <p>eliminiamo il download nel caso in cui il file sia pi&ugrave;
          grande di 1MB</p>

          <table border="0" bgcolor="#E0E0E0" width="100%">
            <tr>
              <td>
                <pre class="PROGRAMLISTING">
reply_body_max_size 1024 KB
   
</pre>
              </td>
            </tr>
          </table>
        </div>
      </div>

      <div class="SECT1">
        <hr />

        <h2 class="SECT1"><a name="SEC-LIMITAZIONE-DOWNLOAD-ALCUNI-FILES"
        id="SEC-LIMITAZIONE-DOWNLOAD-ALCUNI-FILES"></a>20.3. Limitare il
        download di alcuni files</h2>

        <p>E&#39; anche possibile limitare il download di alcuni files
        impostando delle ACL che identifichino il tipo di files da
        limitare</p>

        <table border="0" bgcolor="#E0E0E0" width="100%">
          <tr>
            <td>
              <pre class="PROGRAMLISTING">
acl ftpblock url_regex -i \.mp3$ \.asx$ \.avi$ \.mpeg$ \.mpg$ \
\.qt$ \.ram$ \.rm$ \.iso$ \.wav$
  
</pre>
            </td>
          </tr>
        </table>

        <p>applichiamo la ACL</p>

        <table border="0" bgcolor="#E0E0E0" width="100%">
          <tr>
            <td>
              <pre class="PROGRAMLISTING">
http_access deny ftpblock
  
</pre>
            </td>
          </tr>
        </table>
      </div>
    </div>

    <div class="CHAPTER">
      <hr />

      <h1><a name="CHA-SECURITY-ED-UTILIZZI-ESTREMI" id=
      "CHA-SECURITY-ED-UTILIZZI-ESTREMI"></a>Capitolo 21. Security ed
      utilizzi estremi</h1>

      <div class="SECT1">
        <h2 class="SECT1"><a name="SEC-PREAMBOLO-SECURITY" id=
        "SEC-PREAMBOLO-SECURITY"></a>21.1. Preambolo</h2>

        <p>In questi ultimi anni si parla molto, ed anche a sproposito di
        sicurezza. La continuit&agrave; del servizio definisce la
        stabilit&agrave; e la alta disponibilit&agrave;
        nell&#39;erograzione del servizio stesso e fa parte a pieno titolo
        del ramo informatico dedicato alla sicurezza dei sistemi. Questo
        capitolo nasce per ricordare la data dell&#39;11 Settembre 2001,
        giorno in cui un&#39;attacco terroristico ha causato pi&ugrave; di
        tremila vittime civili distruggendo le Twin Towers di New York.</p>
      </div>

      <div class="SECT1">
        <hr />

        <h2 class="SECT1"><a name="SEC-SQUID-COME-ULTIMA-RISORSA" id=
        "SEC-SQUID-COME-ULTIMA-RISORSA"></a>21.2. Squid come ultima
        risorsa</h2>

        <p>Nella vicenda dell&#39;attacco alle <em>Twin Towers</em> alcune
        delle pi&ugrave; importanti backbone della rete internet vanno
        gi&ugrave; e parte della rete GARR, <em>Rete
        dell&#39;Universit&agrave; e della Ricerca Scientifica
        Italiana</em> (<a href="http://www.garr.it" target=
        "_top">http://www.garr.it</a>) rimane isolata dagli USA. Per un
        breve periodo di tempo la connettivit&agrave; &egrave; stata
        ripristinata attraverso alcuni link di emergenza e grazie anche
        alla collaborazione di DANTE (<a href="http://www.dante.net/"
        target="_top">http://www.dante.net/</a>) con il quale venne
        configurato un circuito provvisorio che attraversava la rete
        europea per raggiungere appunto le reti USA.</p>

        <p>Le funzionalit&agrave; del link con DANTE si sono interrotte con
        l&#39;esaurimento del generatore autonomo ed il traffico HTTP ed
        FTP diretto verso gli Stati Uniti &egrave; stato dirottato
        attraverso un Link secondario non GARR a 34 Mbps, tutto questo
        &egrave; stato possibile grazie al supporto di CASPUR,
        <em>Consorzio interuniversitario per le Applicazioni di
        Supercalcolo per Universit&agrave; e Ricerca</em> (<a href=
        "http://www.caspur.it/" target="_top">http://www.caspur.it/</a>) e
        dal servizio nazionale GARR-CACHE, Servizio Web Cache Nazionale del
        GARR (<a href="http://www.cache.garr.it/" target=
        "_top">http://www.cache.garr.it/</a>).</p>
      </div>

      <div class="SECT1">
        <hr />

        <h2 class="SECT1"><a name="SEC-SQUID-E-LA-SICUREZZA" id=
        "SEC-SQUID-E-LA-SICUREZZA"></a>21.3. Squid e la sicurezza</h2>

        <p>L&#39;obiettivo di questo capitolo &egrave; quello di dare una
        panoramica delle possibili soluzioni relative alla sicurezza da
        implementare utilizzando Squid, divideremo quindi questo paragrafo
        in tre sezioni principali analizzando diverse aree di
        interesse:</p>

        <ul>
          <li>
            <p>sicurezza in quanto servizio</p>
          </li>

          <li>
            <p>sicurezza come interazione con il sistema operativo
            ospitante</p>
          </li>
        </ul>

        <p>Storicamente non si ricordano importanti problematiche di
        sicurezza inerenti l&#39;attivit&agrave; di sviluppo di Squid.</p>

        <p>Per i pignoli ricordiamo che tutti gli advisor possono essere
        controllati nell&#39;url <a href=
        "http://www.squid-cache.org/Advisories/" target=
        "_top">http://www.squid-cache.org/Advisories/</a>. Utilizzare
        l&#39;ultima versione di Squid da sempre la certezza di avere il
        codice allo stato dell&#39;arte, il codice dell&#39;ultima release
        stabile risolve tutti i problemi riscontrarti durante
        l&#39;utilizzo del proxy server, le ultime versioni considerate
        sicure alla data del 6 Aprile del 2004&#39; sono</p>

        <ul>
          <li>
            <p>Squid-2.4.STABLE7 (sconsigliata e non pi&ugrave; supportata
            tranne che da qualche specifico vendor)</p>
          </li>

          <li>
            <p>Squid-2.5.STABLE5</p>
          </li>
        </ul>

        <p>in questo paragrafo non &egrave; nostra intenzione dilungarci
        per disquisire sul controllo degli accessi, la questione &egrave;
        stata infatti approfonditamente affrontata in questo libro nei
        capitoli relativi alle <a href=
        "#SEC-LISTE-DI-CONTROLLO-ACL">ACL</a>, all&#39;<a href=
        "#CHA-AUTENTICAZIONE-UTENTI">autenticazione</a>, all&#39;<a href=
        "#SUBSEC-PAM">autenticazione con Linux</a>, all&#39;<a href=
        "#SUBSEC-MSNT">autenticazione con Windows</a> e relativamente al
        <a href="#SEC-CONTROLLO-ACCESSO-SUI-SITI-WEB">controllo
        accesso</a>. Considereremo come &quot;dato di fatto&quot; che
        l&#39;utente sia gi&agrave; a conoscenza del comportamento di Squid
        o di come Squid si configuri.</p>

        <p>Lo scopo ultimo di questa sezione &egrave; sensibilizzare
        <em>l&#39;admin</em> sui motivi per i quali le politiche di
        sicurezza proposte diventino un dovere e molto spesso una
        necessit&agrave;. Accade troppo spesso infatti che, per quanto
        cerchiamo di &quot;blindare&quot; i nostri servizi, non riusciamo
        mai a proteggerci dagli attacchi e dagli abusi d&#39;utilizzo.</p>

        <div class="SECT2">
          <hr />

          <h3 class="SECT2"><a name="SUBSEC-SICUREZZA-IN-QUANTO-SERVIZIO"
          id="SUBSEC-SICUREZZA-IN-QUANTO-SERVIZIO"></a>21.3.1. Sicurezza in
          quanto Servizio</h3>

          <p>Pi&ugrave; passa il tempo, pi&ugrave; si pu&ograve;
          felicimente notare un aumento dell&#39;utilizzo di Squid nelle
          realt&agrave; aziendali. Con la dilatazione del numero di utenze
          non pu&ograve; mancare un corretto rapporto tra l&#39;utilizzo
          del servizio stesso e le politiche di profilazione che si
          adottano per la sicurezza aziendale e non.</p>

          <p>La stesura di questa parte del documento nasce dalla presa di
          coscienza che, una volta creato un servizio e reso disponibile
          alla comunit&agrave; d&#39;utenza aziendale, automaticamente il
          fruitore (utente o chi per esso) si sentir&agrave; in diritto di
          utilizzare il servizio a proprio piacimento. Questo comportamento
          &quot;improprio&quot; in genere, si verifica genericamente in
          assenza di una regolamentazione scritta.</p>

          <p>Troppe volte infatti accade che i
          &quot;gestori/manutentori&quot; devono saper sopperire a
          questioni e problematiche che vengono causate dall&#39;utilizzo
          improprio di un servizio, questa problematica naturalmente si
          manifesta con molteplici sfaccettature che toccano sicuramente ed
          in maniera tangibile i seguenti argomenti:</p>

          <ul>
            <li>
              <p>efficacia</p>
            </li>

            <li>
              <p>efficienza</p>
            </li>

            <li>
              <p>sicurezza</p>
            </li>
          </ul>

          <p>Lasciando per ora da parte le implicazioni giuridiche legate
          alla sicurezza informatica, in questo contesto infatti indichiamo
          (per lo pi&ugrave;) la possibile corruzione del dato da parte di
          terzi o l&#39;accesso non autorizzato. Squid, oltre che avere un
          efficente sistema di web-cache pu&ograve; risolvere il problema
          di migliorare la sicurezza di un sistema informativo, ovvero
          quella di lasciare ad un <em>unico punto logico l&#39;accesso
          diretto a internet</em>.</p>

          <p>Questo fa si che il singolo pc dell&#39;utente finale debba
          demandare qualsiasi richiesta di accesso ad internet al nostro
          cache server. Non solo, Squid fa in modo che l&#39;utente possa
          essere <em>profilato</em> in modo da permettere la generazione
          demandata di alcune determinate connessioni (cfr. capitoli sul
          <a href="#SEC-CONTROLLO-ACCESSO-SUI-SITI-WEB">controllo
          accesso</a>, sulla <a href="#CHA-PRIVACY">privacy</a> e sulle
          <a href="#SEC-REGOLE-DI-DIMENSIONAMENTO-STORE">indicazioni sulle
          dimensioni della cache</a>) alle quali pu&ograve; sopperire (FTP,
          HTTP ed HTTPS). Il fine primo di questa azione &egrave; quello di
          risolvere le seguenti problematiche:</p>

          <ul>
            <li>
              <p>evitare abuso d&#39;utilizzo</p>
            </li>

            <li>
              <p>evitare l&#39;introduzione di materiale illegale e non
              direttamente legato all&#39;uso lavorativo all&#39;interno
              della rete interna.</p>
            </li>

            <li>
              <p>evitare l&#39;introduzione di Virus e Trojans
              all&#39;interno della rete aziendale</p>
            </li>

            <li>
              <p>evitare problematiche inerenti alla sicurezza informatica
              in generale.</p>
            </li>
          </ul>

          <p>Un esempio pratico per l&#39;attuazione di queste politiche di
          sicurezza si fonda sui seguenti divieti e sui controlli che
          possono essere definiti sul livello di accesso al sistema di
          web-cache:</p>

          <ul>
            <li>
              <p>discriminazione in base all&#39;utenza</p>
            </li>

            <li>
              <p>download e determinati mimetypes</p>
            </li>

            <li>
              <p>contenuto delle pagine</p>
            </li>

            <li>
              <p>access Lists temporizzate</p>
            </li>

            <li>
              <p>direct Connect</p>
            </li>
          </ul>

          <p>Il primo passo &egrave; la discriminazione d&#39;accesso sulla
          base alle credenziali dell&#39;utente, naturalmente ci saranno
          diverse profilazioni per l&#39;utilizzo della cache. Dopo aver
          impostato questo tipo di controllo &egrave; possibile lavorare
          sul tipo di download nonch&egrave; sui mimetypes: un esempio di
          desinenze per i file &quot;vietati&quot;, poich&egrave;
          potenzialmente pericolosi (veicolo per l&#39;introduzione dei
          virus) pu&ograve; essere la negazione per alcune estensioni di
          files come i file .exe, .com, .bat .vbs etc. etc. (cfr. capitolo
          sulle <a href=
          "#CHA-LIMITAZIONE-DELLA-BANDA-PER-CLASSI">limitazioni della banda
          per classi</a>, voce &quot;<em>acl ftp_block</em>&quot;)</p>

          <p>Possono essere inoltre vietate le pagine e le URLs che
          possiedono alcuni tipi di contenuti:</p>

          <ul>
            <li>
              <p>offensivi, discriminatori per razza, sesso e religione,
              pornografici</p>
            </li>

            <li>
              <p>non legati ad un&#39;utilizzo strettamente lavorativo</p>
            </li>
          </ul>

          <p>I criteri di &quot;scelta&quot; degli URLs e del loro
          contenuto viene affidato ad un algoritmo che effettua un
          controllo su parole chiave predefinite (cfr. capitoli sulla
          <a href="#CHA-CONFIGURAZIONE">configurazione</a>,
          sull&#39;<a href="#CHA-AUTENTICAZIONE-UTENTI">autenticazione in
          generale</a> e sul <a href=
          "#SEC-CONTROLLO-ACCESSO-SUI-SITI-WEB">controllo degli
          accessi</a>e sulle <a href=
          "#CHA-LIMITAZIONE-DELLA-BANDA-PER-CLASSI">limitazioni di
          banda</a>), altre possibili soluzioni per la gestione del content
          filtering possono essere reperite con l&#39;utilizzo dei seguenti
          applicativi:</p>

          <ul>
            <li>
              <p>Dansguardian <a href="http://www.dansguardian.org" target=
              "_top">http://www.dansguardian.org</a></p>
            </li>

            <li>
              <p>Squidguard <a href="http://www.squidguard.org" target=
              "_top">http://www.squidguard.org</a></p>
            </li>
          </ul>

          <p><em>Nota</em>: per quello che concerne la <em>profilazione
          degli utenti</em> ed il <em>content filering</em> bisogna fare
          attenzione alla <em>regolamentazione giuridica italiana in
          materia di data-privacy</em> nonch&egrave; da quanto <em>previsto
          dallo statuto dei lavoratori</em>.</p>

          <p>Vediamo ora una caso particolare per quanto riguarda il
          <em>DIRECT CONNECT</em>. Alcuni servizi di rete (come ad esempio
          l&#39;<em>https</em>) necessitano del metodo CONNECT per
          funzionare. Utilizzando questa modalit&agrave; Squid non fa altro
          che creare un vero e proprio TUNNEL tra il client richiedente ed
          il server. Una sbagliata configurazione potrebbe permette ad un
          utente malintenzionato di servirsi di questo metodo per creare
          delle vere e proprie connessioni da usare a proprio piacimento
          per qualsiasi servizio.</p>

          <p>E&#39; buona prassi quindi <em>negare il metodo CONNECT su
          tutte le porte ad eccezione di quelle SSL</em>. (cfr. capitolo
          sulle <a href=
          "#CHA-LIMITAZIONE-DELLA-BANDA-PER-CLASSI">limitazioni di
          banda</a> voce: &quot;<em>http_access deny CONNECT
          !SSL_ports</em>&quot;)</p>
        </div>
      </div>

      <div class="SECT1">
        <hr />

        <h2 class="SECT1"><a name="SEC-SQUID-ED-ANTIVIRUS" id=
        "SEC-SQUID-ED-ANTIVIRUS"></a>21.4. Squid ed Antivirus</h2>

        <p>Vale anche la pena citare, a proposito della sicurezza
        informatica, la possibile integrazione di Squid con i sistemi
        AntiVirus o viruswalling. E&#39; di grande importanza per tutti gli
        utenti avere la possibilit&agrave; di effettuare una navigazione
        internet &quot;protetta&quot; da possibili virus, trojans e worms.
        L&#39;inserimento di questa feature all&#39;interno di Squid,
        naturalmente, deve essere fatta attraverso l&#39;utilizzo di
        software di terze parti. Passiamo in rassegna alcune possibili
        configurazioni</p>

        <ul>
          <li>
            <p><em>Viralator</em> &egrave; un wrapper in perl che si
            propone di controllare tutti i file che passano attraverso la
            web-cache, ulteriori informazioni possono essere reperite alla
            URL <a href="http://viralator.loddington.com/" target=
            "_top">http://viralator.loddington.com/</a></p>
          </li>

          <li>
            <p><em>Squid-VScan</em> unica soluzione Free/GPL integra
            OpenAntivirus (scritto in Java) con squid <a href=
            "http://sourceforge.net/projects/openantivirus/" target=
            "_top">http://sourceforge.net/projects/openantivirus/</a></p>
          </li>

          <li>
            <p><em>DGVirus</em> &egrave; un&#39;integrazione di
            DansGuardian con con l&#39;utilizzo dell&#39;antivirus <a href=
            "http://www.pcxperience.org/dgvirus/" target=
            "_top">http://www.pcxperience.org/dgvirus/</a></p>
          </li>

          <li>
            <p><em>TrendMicro InterScan Web VirusWall</em> (ora Interscan
            Web Security Suite) che fa parte della suite per il
            viruswalling di TrendMicro, questo sistema pu&ograve; essere
            integrato con Squid <a href=
            "http://www.trendmicro.com/en/products/gateway/iwss/evaluate/overview.htm"
               target="_top">URL:
               http://www.trendmicro.com/en/products/gateway/iwss/evaluate/overview.htm</a></p>
          </li>
        </ul>

        <p>l&#39;unica soluzione documentabile &egrave; quella di <em>Trend
        Micro</em>, in merito alle altre soluzioni antivirus citate in
        alto, questo tomo per il momento non si propone di trattare queste
        configurazioni perch&egrave; gli autori non hanno ancora trovato
        una documentazione esaustiva a riguardo.</p>

        <div class="SECT2">
          <hr />

          <h3 class="SECT2"><a name="SUBSEC-INTERSCAN-WEB-SECURITY" id=
          "SUBSEC-INTERSCAN-WEB-SECURITY"></a>21.4.1. InterScan Web
          Security Suite</h3>

          <p>In questo paragrafo analizzeremo come utilizzare questo
          prodotto della TrenMicro assieme a Squid Proxy Server per
          consentire una efficace scansione del traffico HTTP
          salvaguardando l&#39;introduzione di virus sulle macchine client,
          gli esempi fanno riferimento al prodotto ISVW (Inter Scan Web
          VirusWall) e Squid. Per la sua natura tutto il traffico HTTPS non
          viene naturalmente trattato, pertanto ISVW esegue il
          &quot;forward&quot; delle richieste HTTPS in maniera totalmente
          trasparente. il proxy server a monte della catena dei sistemi che
          concateneremo in questo esempio non loggher&agrave; nessuna
          attivit&agrave; a rigurdo del traffico HTTPS.</p>

          <p>Configureremo ISVW per rispondere sulla porta 8080 di una
          qualsiasi macchina, sia Windows che UNIX&reg;, non &egrave; un
          fattore determinante. ISVW per funzionare deve concatenarsi con
          un proxy Server che si trova a valle quindi che &egrave;
          direttamente collegato con la rete internet</p>

          <table border="0" bgcolor="#E0E0E0" width="100%">
            <tr>
              <td>
                <pre class="PROGRAMLISTING">
---------------------------------------------------
       |                 |                 |
 ------------       ------------      -------------
 |proxy:3128|&lt;------| ISVW:8080|&lt;-----|proxy1:3128|
 ------------       ------------      -------------
   content            antivirus        proxy_users
   
</pre>
              </td>
            </tr>
          </table>

          <p>Nello schema sopracitato vediamo 3 sistemi Proxy concatenati
          tra loro, dove la macchina con ISVW, in ascolto sulla porta 8080
          contatta il proxy server Squid a valle che &egrave; in ascolto
          sulla porta 3128 ottenendo le pagine web. Il proxy1, sempre in
          ascolto sulla porta 3128, contatta il proxy server ISVW, in
          ascolto sulla porta 8080, per ottenere tutte le pagine web
          filtrate e pulite da possibili virus. Gli utenti della nostra
          rete accedono ad internet senza rischio contattando il sistema
          proxy1, che rimane in ascolto sulla porta 3128.</p>

          <p>Ora vediamo come configurare la macchina proxy1 per
          consentirgli di legarsi con il server ISVW. Modificheremo il file
          <em>squid.conf</em> inserendo queste 2 righe nei punti
          opportuni</p>

          <table border="0" bgcolor="#E0E0E0" width="100%">
            <tr>
              <td>
                <pre class="PROGRAMLISTING">
cache_peer localhost parent 8080 0 no-query no-digest
never_direct allow all
   
</pre>
              </td>
            </tr>
          </table>

          <p>La configurazione appena trattata &egrave; stata testata sia
          con Squid 2.4 che con Squid 2.5, per rendere operativo il
          concatenamento dei due proxy server sar&agrave; necessario
          riavviare Squid Proxy Server</p>

          <table border="0" bgcolor="#E0E0E0" width="100%">
            <tr>
              <td>
                <pre class="PROGRAMLISTING">
[root@portatilo root]# /usr/local/etc/rc.d/squid.sh stop
[root@portatilo root]# /usr/local/etc/rc.d/squid.sh start
   
</pre>
              </td>
            </tr>
          </table>

          <p>oppure</p>

          <table border="0" bgcolor="#E0E0E0" width="100%">
            <tr>
              <td>
                <pre class="PROGRAMLISTING">
[root@portatilo root]# squid -k reconfigure
   
</pre>
              </td>
            </tr>
          </table>

          <p>Il riavvio del server render&agrave; immediatamente
          funzionante ed operativa la nuova configurazione</p>
        </div>
      </div>

      <div class="SECT1">
        <hr />

        <h2 class="SECT1"><a name="SEC-SICUREZZA-CON-OS-OSPITANTE" id=
        "SEC-SICUREZZA-CON-OS-OSPITANTE"></a>21.5. Sicurezza come
        interazione con il sistema operativo ospitante</h2>

        <p>Squid &egrave; un server di tipo &quot;demone&quot; che viene
        eseguito in ambito LAN o WAN e, in quanto tale, naturalmente
        pu&ograve; essere potenzialmente soggetto a connessioni anche da
        parte di utenti malintenzionati. E&#39; quindi buona prassi fare
        una corretta configurazione del sistema ospitante al fine di
        evitare eventuali problematiche di sicurezza.</p>

        <div class="SECT2">
          <hr />

          <h3 class="SECT2"><a name="SUBSEC-SISTEMI-UNIX-CLONI-BSD" id=
          "SUBSEC-SISTEMI-UNIX-CLONI-BSD"></a>21.5.1. Sistemi UNIX&reg;,
          cloni e BSD</h3>

          <p>Nei sistemi UNIX&reg; la prima semplice ed immediata procedura
          per proteggere il sistema &egrave; una corretta gestione dei
          permessi; a riguardo la user guide di Squid &egrave; alquanto
          chiara (cfr. <a href=
          "http://squid-docs.sourceforge.net/latest/html/c911.html#AEN913"
          target=
          "_top">http://squid-docs.sourceforge.net/latest/html/c911.html#AEN913</a>),
          noi ci limiteremo a riportare solo le voci principali. Prima di
          tutto puntualizziamo sul fatto che Squid accede alla cache
          utilizzando un utente che fa parte un gruppo ben definito, vale
          la pena quindi creare un utente e un gruppo che abbiano le
          credenziali necessarie che garantiscano la sicurezza del corretto
          funzionamento, i TAG da indicare nel file di configurazione
          <em>squid.conf</em> sono i seguenti</p>

          <table border="0" bgcolor="#E0E0E0" width="100%">
            <tr>
              <td>
                <pre class="PROGRAMLISTING">
cache_effective_user squid 
cache_effective_group squidadm 
   
</pre>
              </td>
            </tr>
          </table>

          <p>Impostato l&#39;utente ed il gruppo, sar&agrave; necessario
          propagare le credenziali a tutta la struttura di directory in cui
          squid &quot;vive&quot;, tale pratica &egrave; necessaria per il
          corretto funzionamento del sistema. Nell&#39;esempio che vi
          sottoponiamo abbiamo creato un gruppo
          <em>&quot;squidadm</em>&quot;, l&#39;utente che fa parte di
          questo gruppo &egrave; <em>&quot;squid</em>&quot;, il proxy
          server Squid &egrave; stato installato nel prefix
          <em>/usr/squid/</em>, quindi dovremo necessariamente impostare i
          seguenti permessi</p>

          <table border="0" bgcolor="#E0E0E0" width="100%">
            <tr>
              <td>
                <pre class="PROGRAMLISTING">
[root@klingon root]# chown squid:squidadm /usr/squid 
[root@klingon root]# chmod 755 /usr/squid 
[root@klingon root]# chown squid:squidadm /usr/squid/bin/. 
[root@klingon root]# chown squid:squidadm /usr/squid/bin/* 
[root@klingon root]# chmod 755 /usr/squid/bin/. 
[root@klingon root]# chmod 755 /usr/squid/bin/* 
[root@klingon root]# chmod 2775 /usr/squid/etc/. 
[root@klingon root]# chown squid:squidadm /usr/squid/etc/* 
[root@klingon root]# chown squid:squidadm /usr/squid/etc/. 
[root@klingon root]# chown squid:squidadm /usr/squid/var/logs/ 
[root@klingon root]# chmod 770 /usr/squid/var/logs/ 
[root@klingon root]# chown squid:squidadm /usr/squid/var/cache 
[root@klingon root]# chmod 770 /usr/squid/var/cache 
   
</pre>
              </td>
            </tr>
          </table>

          <p>Una volta impostati i permessi, facciamo partire squid
          ricordandosi di generare le sottodirectory di gestione della
          cache (comando <em>squid -z</em> per il dettaglio cfr. capitolo
          sull&#39;<a href="#CHA-AVVIARE-SQUID">avvio di Squid</a>)
          utilizzando un utente non privilegiato (non utilizziamo
          l&#39;utente <em>root</em> per capirci) eseguendo il comando</p>

          <table border="0" bgcolor="#E0E0E0" width="100%">
            <tr>
              <td>
                <pre class="PROGRAMLISTING">
[root@klingon root]# /usr/local/bin/setuidgid squid /usr/squid/sbin/squid -D -N -d 10 
   
</pre>
              </td>
            </tr>
          </table>

          <p>Nota: <em>setuidgid</em> &egrave; una applicazione inclusa nel
          pacchetto <em>daemontools</em> realizzato da d.j. Bernstein.</p>

          <p>Nell&#39;esempio abbiamo deciso di far partire Squid con
          utente non privilegiato poich&egrave; ogni demone di rete che
          gira come <em>root</em> rappresenta comunque una problematica per
          la sicurezza, l&#39;operazione &egrave; stata eseguita nonostante
          il server Squid abbia una struttura per la quale il processo
          child, che usa comunque un utente non privilegiato
          (<em>squid</em>), si occuper&agrave; di servire le richieste.</p>
        </div>

        <div class="SECT2">
          <hr />

          <h3 class="SECT2"><a name="SUBSEC-LA-MODALITA-CHROOT" id=
          "SUBSEC-LA-MODALITA-CHROOT"></a>21.5.2. La modalit&agrave;
          <em>chroot()</em> nei sistemi UNIX&reg; cloni o BSD</h3>

          <p>Analizziamo ora un&#39;altra possibilit&agrave; che ci viene
          offerta dai sistemi UNIX&reg; per corazzare il servizio Squid.
          Tale possibilit&agrave; viene offerta dalla funzione
          <em>chroot()</em><a name="AEN5461" href="#FTN.AEN5461" id=
          "AEN5461">[32]</a>. Questa funzione consente a un comando (nel
          nostro caso proprio Squid) di essere <em>confinato in un
          environment (o gabbia) per l&#39;occasione da noi predisposto
          all&#39;interno</em> del sistema stesso.</p>

          <p>Nel malaugurato caso in cui un malintenzionato riesca ad
          ottenere una &quot;shell&quot; sul sistema, sfruttando un
          improbabile bug di Squid, grazie alla funzione <em>chroot()</em>,
          lo stesso rimarr&agrave; <em>chiuso nella gabbia</em> da noi
          preparata, grazie alla gabbia il malintenzionato non potr&agrave;
          effettuare danni.</p>

          <p>E&#39; necessario rammentare che esistono alcuni metodi per
          irrompere fuori dalla gabbia di <em>chroot()</em> (cfr. <a href=
          "http://www.bpfh.net/simes/computing/chroot-break.html" target=
          "_top">http://www.bpfh.net/simes/computing/chroot-break.html</a>)
          ma se stiamo un p&ograve; attenti, possiamo rendere anche questo
          raggiro molto difficile.</p>

          <p>Sinceramente l&#39;autore di questo paragrafo, pensa che non
          sia strettamente necessario porre Squid in un ambiente
          <em>chrootato</em>, ma visto che la sicurezza non &egrave; mai
          troppa e la paranoia regna sovrana porremo il nostro Squid in una
          gabbia blindata.</p>

          <p>Nota: la sicurezza paranoica &egrave; un temine che &egrave;
          stato coniato dall&#39;autore del libro nel momento in cui si
          teorizzava sull&#39;inserimento di questo paragrafo.</p>

          <p>Passando alla parte operativa prima di tutto dobbiamo creare
          il nostro sistema &quot;gabbia&quot; dove andremo a chiudere il
          processo Squid, quindi avremo bisogno di creare una directory per
          metterci dentro tutto quello che serve a Squid per funzionare</p>

          <table border="0" bgcolor="#E0E0E0" width="100%">
            <tr>
              <td>
                <pre class="PROGRAMLISTING">
root@norad:~# mkdir /chroot 
root@norad:~# cd /chroot 
   
</pre>
              </td>
            </tr>
          </table>

          <p>creazione delle directory di sistema</p>

          <table border="0" bgcolor="#E0E0E0" width="100%">
            <tr>
              <td>
                <pre class="PROGRAMLISTING">
root@norad:/chroot# mkdir -p usr/bin usr/lib lib squidhome etc 
root@norad:/chroot# ln -s usr/bin/ bin 
   
</pre>
              </td>
            </tr>
          </table>

          <p>copiamo le librerie necessarie nell&#39;environment (la
          questione &egrave; variabile a secondo dei Sistemi
          utilizzati)</p>

          <table border="0" bgcolor="#E0E0E0" width="100%">
            <tr>
              <td>
                <pre class="PROGRAMLISTING">
root@norad:/chroot# cp -pi /lib/lib/libtermcap* /lib/ld-linux.so.2 /lib/libc.so.6 lib/ 
root@norad:/chroot# cp -pi /lib/libnss* lib/ 
   
</pre>
              </td>
            </tr>
          </table>

          <p>mettiamoci dentro un p&ograve; di binaries necessari</p>

          <table border="0" bgcolor="#E0E0E0" width="100%">
            <tr>
              <td>
                <pre class="PROGRAMLISTING">
root@norad:/chroot# cp -pi /bin/cat /bin/sh bin/ 
   
</pre>
              </td>
            </tr>
          </table>

          <p>proviamo la nostra <em>chroot()</em></p>

          <table border="0" bgcolor="#E0E0E0" width="100%">
            <tr>
              <td>
                <pre class="PROGRAMLISTING">
root@norad:~# chroot /chroot /bin/cat --help 
   
</pre>
              </td>
            </tr>
          </table>

          <p>Creiamo adesso un utente ed un gruppo che esisteranno solo
          all&#39;interno del nostro ambiente</p>

          <table border="0" bgcolor="#E0E0E0" width="100%">
            <tr>
              <td>
                <pre class="PROGRAMLISTING">
root@norad:~# cd /chroot 
root@norad:/chroot# touch etc/passwd etc/shadow etc/group 
root@norad:/chroot# chmod 400 etc/shadow 
root@norad:/chroot# echo &#39;squidadm:x:888:&#39; &gt; etc/group 
root@norad:/chroot# echo &#39;squid:*:10882:-1:99999:-1:-1:-1:134537804&#39; &gt; etc/shadow 
root@norad:/chroot# echo &#39;squid:x:888:888:Web Account:/squidhome:/usr/bin/False&#39; \
&gt; etc/passwd 
   
</pre>
              </td>
            </tr>
          </table>

          <p>creiamo una shell fittizia</p>

          <table border="0" bgcolor="#E0E0E0" width="100%">
            <tr>
              <td>
                <pre class="PROGRAMLISTING">
root@norad:/chroot# echo &#39;int main(int argc, char *argv[]) {return(1);}&#39; \
&gt; /tmp/False.c &amp;&amp; gcc -O3 /tmp/False.c -o /chroot/usr/bin/False 
   
</pre>
              </td>
            </tr>
          </table>

          <p>Facciamo in modo che i binaries siano SOLO eseguibili</p>

          <table border="0" bgcolor="#E0E0E0" width="100%">
            <tr>
              <td>
                <pre class="PROGRAMLISTING">
root@norad:/chroot# chmod 111 usr/bin/* 
   
</pre>
              </td>
            </tr>
          </table>

          <p>Creiamo i file per le risoluzioni (<em>N.B.</em> se usiamo
          l&#39;auth winbindd conviene inserire anche nss_winbind)</p>

          <table border="0" bgcolor="#E0E0E0" width="100%">
            <tr>
              <td>
                <pre class="PROGRAMLISTING">
----/chroot/etc/nsswitch.conf ---------------- 
passwd: files 
shadow: files 
group: files 
hosts: files dns 
---------------------------------------------- 
----/chroot/etc/resolv.conf ------------------ 
domain mydomain.com 
nameserver dnsaddress 
---------------------------------------------- 
----/chroot/etc/hosts ------------------------ 
127.0.0.1 localhost loopback my.add.re.ss nomemio hostname.mydomain.com 
---------------------------------------------- 
   
</pre>
              </td>
            </tr>
          </table>

          <p>Compiliamo ed installiamo Squid</p>

          <table border="0" bgcolor="#E0E0E0" width="100%">
            <tr>
              <td>
                <pre class="PROGRAMLISTING">
root@norad:/chroot# mkdir /chroot/squid 
root@norad:/chroot# ln -s /chroot/squid /squid 
root@norad:/squid-2.5STABLE1/# ./configure --prefix=/squid \
--enable-storeio=&quot;diskd ufs&quot; \
--enable-snmp --enable-underscores
.
root@norad:/squid-2.5STABLE1/# gmake all &amp;&amp; gmake install &amp;&amp; ldconfig &amp;&amp; sync 
   
</pre>
              </td>
            </tr>
          </table>

          <p>Una volta fatto questo dovremo essere quasi pronti per far
          funzionare squid, ci dobbiamo soltanto armare delle utility
          <em>strace</em> ed <em>ldd</em> per vedere COSA serve a squid per
          funzionare correttamente, quindi</p>

          <table border="0" bgcolor="#E0E0E0" width="100%">
            <tr>
              <td>
                <pre class="PROGRAMLISTING">
root@norad:/chroot# ldd /squid/bin/squid 
        libcrypt.so.1 =&gt; /lib/libcrypt.so.1 (0x00136000) 
        libpthread.so.0 =&gt; /lib/libpthread.so.0 (0x00163000) 
        libm.so.6 =&gt; /lib/libm.so.6 (0x00179000) 
        libresolv.so.2 =&gt; /lib/libresolv.so.2 (0x0019b000) 
        libnsl.so.1 =&gt; /lib/libnsl.so.1 (0x001ac000) 
        libc.so.6 =&gt; /lib/libc.so.6 (0x001c1000) 
        /lib/ld-linux.so.2 =&gt; /lib/ld-linux.so.2 (0x00110000)
#
root@norad:/chroot# ldd /squid/bin/client 
        libm.so.6 =&gt; /lib/libm.so.6 (0x00136000) 
        libresolv.so.2 =&gt; /lib/libresolv.so.2 (0x00158000) 
        libnsl.so.1 =&gt; /lib/libnsl.so.1 (0x00169000) 
        libc.so.6 =&gt; /lib/libc.so.6 (0x0017e000) 
        /lib/ld-linux.so.2 =&gt; /lib/ld-linux.so.2 (0x00110000) 
#
root@norad:/chroot# ldd /squid/libexec/squid/diskd 
        libm.so.6 =&gt; /lib/libm.so.6 (0x00136000) 
        libc.so.6 =&gt; /lib/libc.so.6 (0x00158000) 
        /lib/ld-linux.so.2 =&gt; /lib/ld-linux.so.2 (0x00110000) 
#
root@norad:/chroot# ldd /squid/libexec/squid/unlinkd 
        libc.so.6 =&gt; /lib/libc.so.6 (0x00136000) 
        /lib/ld-linux.so.2 =&gt; /lib/ld-linux.so.2 (0x00110000) 
   
</pre>
              </td>
            </tr>
          </table>

          <p>Questo output ci mostra dove Squid (ed altri programmi vitali)
          cercheranno le librerie (shared objects) necessarie. A questo
          punto noi dobbiamo ricreare lo stesso path nel nostro ambiente e
          copiarvi la libreria. Un esempio semplice</p>

          <table border="0" bgcolor="#E0E0E0" width="100%">
            <tr>
              <td>
                <pre class="PROGRAMLISTING">
libpthread.so.0 =&gt; /lib/libpthread.so.0 
   
</pre>
              </td>
            </tr>
          </table>

          <p>Questo vuol dire che Squid prover&agrave; a linkare
          libpthread.so.0 cercandola dentro <em>/lib</em>. Quindi, noi
          abbiamo chrootato dentro <em>/chroot</em>, non dovremo far altro
          che copiare la libreria dove Squid la cercher&agrave;</p>

          <table border="0" bgcolor="#E0E0E0" width="100%">
            <tr>
              <td>
                <pre class="PROGRAMLISTING">
/chroot/lib/libpthread.so.0 
root@norad:/chroot# cp -pi /lib/libpthread.so.0 /chroot/lib/ 
   
</pre>
              </td>
            </tr>
          </table>

          <p>Continuamo cos&igrave; per tutto il resto dell&#39;output
          degli <em>ldd</em>. Ora, se abbiamo configurato tutto
          correttamente permessi directory etc. (cfr. l&#39;inizio del
          paragrafo) tutto dovrebbe funzionare, possiamo far partire Squid
          con il comando</p>

          <table border="0" bgcolor="#E0E0E0" width="100%">
            <tr>
              <td>
                <pre class="PROGRAMLISTING">
/usr/local/bin/setuidgid squid &#39;/usr/sbin/chroot/chroot /squid/bin/squid -D -d 1&#39; 
   
</pre>
              </td>
            </tr>
          </table>

          <p>Se dovessero venir fuori problemi o errori provare prima a far
          partire Squid normalmente <em>senza chroot()</em>. Poi
          ricontrollare tutto con <em>ldd</em>, al massimo utilizzare
          l&#39;utility &quot;strace&quot; per un miglior debugging.</p>
        </div>
      </div>

      <div class="SECT1">
        <hr />

        <h2 class="SECT1"><a name="SEC-SQUID-E-DAEMONTOOLS" id=
        "SEC-SQUID-E-DAEMONTOOLS"></a>21.6. Squid e Daemontools</h2>

        <p>Squid &egrave; un software decisamente stabile, a memoria non si
        ricordano problematiche gravi relative a crash in produzione
        direttamente dipendenti il demone. Storicamente lo si &egrave;
        visto <em>&quot;morire</em>&quot; esclusivamente per problematiche
        legate all&#39;hardware o a configurazioni sbagliate. Naturalmente
        la prudenza non &egrave; mai troppa, specialmente se utilizziamo
        Squid in scenari mission-critical.</p>

        <p>Per migliorare l&#39;affidabilit&agrave; e la
        raggiungibilit&agrave; del servizio di Squid ci viene incontro il
        pacchetto di software scritto dall&#39;integerrimo DJ Bernstein,
        ovvero <em>Daemontools</em>, che possiamo facilmente reperire su:
        <a href="http://cr.yp.to/daemontools/daemontools-0.76.tar.gz"
        target=
        "_top">http://cr.yp.to/daemontools/daemontools-0.76.tar.gz</a></p>

        <p>Il funzionamento di questo supporto &egrave; semplice, con la
        sua struttura <em>daemontools</em> fa partire in modalit&agrave;
        &quot;respawn&quot; direttamente dall&#39;inittab l&#39;applicativo
        svscanboot il quale lancia e controlla continuamente il programma
        svscan sulla directory <em>/service</em> dopodich&egrave;
        <em>supervise</em> avr&agrave; il compito di controllare il
        processo che abbiamo deciso di monitorare e lo rilancer&agrave; nel
        caso in cui questo dovesse interrompersi per un qualsiasi
        motivo.</p>

        <p>Passiamo ora alla configurazione: dopo aver installato Squid con
        un determinato prefix (Es. <em>/usr/squid</em>) ed aver
        correttamente reso funzionante <em>daemontools</em>, andiamo a
        creare lo script run necessario per il corretto funzionamento della
        struttura di controllo</p>

        <table border="0" bgcolor="#E0E0E0" width="100%">
          <tr>
            <td>
              <pre class="PROGRAMLISTING">
#!/bin/sh
exec ./bin/squid -d 1 -N -D \
-f ./etc/squid.conf \
2&gt;&amp;1 | /usr/local/bin/multilog t s10000000000 n20 ./log 
  
</pre>
            </td>
          </tr>
        </table>

        <p>idealmente, ovvero come dice lo stesso <em>DjB</em>, questa
        tipologia di file non dovrebbe contenere dei &quot;|&quot; (pipe)
        al loro interno, ma dato che non abbiamo bisogno diretto del log,
        questo pu&ograve; anche andare. C&#39;&egrave; da puntualizzare
        anche che all&#39;interno del file, possono essere messe e tolte
        tutte le opzioni ad eccezione di &quot;-N&quot;, per un corretto
        funzionamento infatti, Squid non deve entrare in daemon mode. Una
        volta terminato questo step, baster&agrave; dare i seguenti
        comandi</p>

        <table border="0" bgcolor="#E0E0E0" width="100%">
          <tr>
            <td>
              <pre class="PROGRAMLISTING">
root@norad:~# chmod 755 /usr/squid/run 
root@norad:~# ln -s /usr/squid /service 
  
</pre>
            </td>
          </tr>
        </table>

        <p>aspettiamo qualche secondo e, come per magia, Squid
        partir&agrave; da solo, correttamente funzionante, e sar&agrave;
        virtualmente invulnerabile! naturalmente possiamo controllare se
        Squid funziona con il comando</p>

        <table border="0" bgcolor="#E0E0E0" width="100%">
          <tr>
            <td>
              <pre class="PROGRAMLISTING">
root@norad:~# svstat /service/squid 
  
</pre>
            </td>
          </tr>
        </table>

        <p>altra cosa importante, non servir&agrave; inserire nessuno
        script di boot nell&#39;<em>init.d</em> in quanto penser&agrave;
        <em>svscanboot</em> stesso a farlo partire. Se proprio lo
        volessimo, eccone uno fatto ad hoc su schema RedHat</p>

        <table border="0" bgcolor="#E0E0E0" width="100%">
          <tr>
            <td>
              <pre class="PROGRAMLISTING">
#!/bin/sh 
# Start/stop/restart squid-daemontools. 
# Start acpid: 
squid_start() { 
 if [ -x /usr/squid/bin/squid ]; then 
  echo &quot;Starting Squid daemon: /usr/squid/bin/squid&quot;
  /usr/local/bin/svc -u /service/squid
 fi
} 
#
# Stop squid:
squid_stop() {
 echo &quot;Shutting down Squid daemon: /usr/squid/bin/squid&quot;
 /usr/local/bin/svc -dk /service/squid
 /bin/killall squid # non necessario di solito, server per uccidere anche i child 
}
#
# Restart acpid: 
squid_restart() { 
 /usr/local/bin/svc -dk /service/squid
 /bin/killall squid
 /usr/local/bin/svc -u /service/squid
} 
case &quot;$1&quot; in 
&#39;start&#39;) squid_start 
 if [ -x /usr/squid/bin/squid ]; then 
  echo &quot;Starting Squid daemon: /usr/squid/bin/squid&quot; 
  /usr/local/bin/svc -u /service/squid24
 fi 
}
#
# Stop Squid: 
squid_stop() {
 echo &quot;Shutting down Squid daemon: /usr/squid/bin/squid&quot; 
 /usr/local/bin/svc -dk /service/squid24
 /bin/killall squid 
}
#
# Restart Squid:
squid_restart() {
 squid_stop
 sleep 1
 squid_start
}
#
case &quot;$1&quot; in
&#39;start&#39;)
squid_start
;;
&#39;stop&#39;)
squid_stop
;;
&#39;restart&#39;)
squid_restart
;;
*)
echo &quot;usage $0 start|stop|restart&quot;
esac 
  
</pre>
            </td>
          </tr>
        </table>
      </div>

      <div class="SECT1">
        <hr />

        <h2 class="SECT1"><a name="SEC-SISTEMI-WINDOWS" id=
        "SEC-SISTEMI-WINDOWS"></a>21.7. Sistemi Windows</h2>

        <p>Squid, come ben sappiamo &egrave; stato &quot;portato&quot; per
        funzionare anche sotto archiettura Microsoft Windows (utilizzando
        Cygwin o MinGW). Le politiche di sicurezza possono essere le stesse
        utilizzate sotto UNIX&reg; (ad eccezione della chroot()) ovvero la
        corretta configurazione dei permessi del directory tree e il far
        partire il processo da utente non privilegiato.</p>
      </div>

      <div class="SECT1">
        <hr />

        <h2 class="SECT1"><a name="SEC-SISTEMI-OS2" id=
        "SEC-SISTEMI-OS2"></a>21.8. Sistemi OS/2</h2>

        <p>Anche in questo caso si tratta di un porting realizzato grazie
        all&#39;EMX runtime. OS/2 non prevede l&#39;esecuzione di un
        processo ad un livello inferiore o con privilegi minimi di
        conseguenza, il demone verr&agrave; eseguito sempre con i privilegi
        di amministratore del sistema.</p>
      </div>
    </div>

    <div class="CHAPTER">
      <hr />

      <h1><a name="CHA-I-LOG-DI-SQUID-E-LA-LORO-ANALISI" id=
      "CHA-I-LOG-DI-SQUID-E-LA-LORO-ANALISI"></a>Capitolo 22. La analisi
      dei log di Squid</h1>

      <div class="SECT1">
        <h2 class="SECT1"><a name="SEC-PREAMBOLO-LOG-ANALISI" id=
        "SEC-PREAMBOLO-LOG-ANALISI"></a>22.1. Preambolo</h2>

        <p>Anche se pu&ograve; apparire strano, la funzione pi&ugrave;
        importante nell&#39;amministrazione dei servizi di rete &egrave;
        proprio l&#39;analisi dei file di log, controllando l&#39;andamento
        e la tipologia degli accessi &egrave; possibile prevenire per
        evitare possibili abusi e migliorare anche la qualit&agrave; del
        servizio offerto.</p>

        <p>Non &egrave; nostro obiettivo trattare eventuali problematiche
        inerenti <em>l&#39;aspetto legale</em> che l&#39;analisi di un file
        di log pu&ograve; determinare, sopratutto per quello che concerne
        la relativa legge sulla privacy nonch&egrave; lo statuto dei
        lavoratori in vigore nello stato d&#39;utilizzazione.</p>

        <p>Questo capitolo ha l&#39;obiettivo di proporre delle metodologie
        di analisi dei log di accesso generati da Squid, ricordiamo a tale
        proposito che una lista ben fornita di applicazioni per
        l&#39;analisi dei log &egrave; disponibile presso la URL&#39;s:
        <a href="http://www.squid-cache.org/Scripts/" target=
        "_top">http://www.squid-cache.org/Scripts/</a></p>
      </div>

      <div class="SECT1">
        <hr />

        <h2 class="SECT1"><a name="SEC-I-LOG-NATIVI" id=
        "SEC-I-LOG-NATIVI"></a>22.2. I log nativi</h2>

        <p>Abbiamo gi&agrave; visto che Squid utilizza diversi files di
        logs di cui quattro sono i file di log principali, questi vengono
        definiti dai seguenti TAG</p>

        <p>il TAG <em>cache_access_log</em></p>

        <table border="0" bgcolor="#E0E0E0" width="100%">
          <tr>
            <td>
              <pre class="PROGRAMLISTING">
cache_access_log /usr/local/squid/var/logs/access.log
  
</pre>
            </td>
          </tr>
        </table>

        <p>nel file <em>access.log</em> vengono registrate tutte le
        transazioni effettuate dai client</p>

        <p>il TAG <em>cache_log</em></p>

        <table border="0" bgcolor="#E0E0E0" width="100%">
          <tr>
            <td>
              <pre class="PROGRAMLISTING">
cache_log /usr/local/squid/var/logs/cache.log
  
</pre>
            </td>
          </tr>
        </table>

        <p>nel file <em>cache.log</em> vengono registrate tutte le
        informazioni sullo stato della cache, ne analizzeremo i dettagli in
        <a href="#SEC-IL-FILE-CACHE.LOG">seguito</a></p>

        <p>il TAG <em>cache_store_log</em></p>

        <table border="0" bgcolor="#E0E0E0" width="100%">
          <tr>
            <td>
              <pre class="PROGRAMLISTING">
cache_store_log /usr/local/squid/var/logs/store.log 
  
</pre>
            </td>
          </tr>
        </table>

        <p>nel file <em>store.log</em> vengono registrate tutte le
        attivit&agrave; eseguite dallo storage manager di Squid</p>

        <p>il TAG <em>cache_swap_log</em></p>

        <table border="0" bgcolor="#E0E0E0" width="100%">
          <tr>
            <td>
              <pre class="PROGRAMLISTING">
cache_swap_log /usr/local/squid/var/cache/swap.state
  
</pre>
            </td>
          </tr>
        </table>

        <p>nel file <em>swap.state</em> viene memorizzato il file di log
        dello swap, si tratta di un file binario che include un checksum
        MD5 e che contiene i campi dello store entry. Non &egrave;
        necessario indicarlo in <em>squid.conf</em> in quanto verr&agrave;
        scritto automaticamente nella top level directory della
        <em>cache_dir</em>.</p>

        <p>Possiamo anche definire il formato dei files di logs che
        pu&ograve; essere suddiviso in file di <em>log nativi</em> ed in
        file di log che emulano lo schema transazionale di un server web.
        Naturalmente le informazioni pi&ugrave; importanti sullo stato di
        servizio della cache vengono memorizzate nel file
        <em>cache.log</em>, mentre il file dal quale riusciremo ad
        estrapolare il maggior numero di informazioni sul funzionamento del
        servizio di web cache &egrave; senza dubbio il file
        <em>access.log</em>. Ora analizziamo nel dettaglio il formato del
        file <em>access.log</em></p>

        <table border="0" bgcolor="#E0E0E0" width="100%">
          <tr>
            <td>
              <pre class="PROGRAMLISTING">
<em>(1)</em>1049790275.517<em>(2)</em>880<em>(3)</em>192.168.5.12<em>(4)</em>TCP_MISS \
<em>(5)</em>20012689<em>(6)</em>GET <em>(7)</em>ftp://it.samba.org/pub/samba \
<em>(8)</em>Federico DIRECT/<em>(9)</em>217.56.103.6 <em>(10)</em> text/html 
  
</pre>
            </td>
          </tr>
        </table>

        <p>come possiamo notare vi sono ben 10 campi, questi campi vengono
        identificati utilizzando dei valori numerici, nello specifico di
        seguito ne forniamo il dettaglio</p>

        <ol type="1">
          <li>
            <p><em>TimeStamp</em></p>

            <p>&egrave; il momento in cui la richiesta diretta verso il
            sistema di cache &egrave; stata processata, da notare che il
            formato &egrave; &quot;UNIX&reg; Time&quot; con la risoluzione
            in millisecondi</p>
          </li>

          <li>
            <p><em>Elapsed Time</em></p>

            <p>il tempo necessario per processare la richiesta, il tempo
            viene espresso in millisecondi</p>
          </li>

          <li>
            <p><em>Client Address</em></p>

            <p>determina l&#39;indirizzo IP sorgente della richiesta</p>
          </li>

          <li>
            <p><em>Log Tag/HTTP Code</em></p>

            <p>si tratta dell&#39;azione intrapresa da Squid in base alla
            richiesta (hit, miss, denied)</p>
          </li>

          <li>
            <p><em>Size</em></p>

            <p>la quantit&agrave; di byte inviati al Client</p>
          </li>

          <li>
            <p><em>Request Method</em></p>

            <p>determina il metodo HTTP che viene utilizzato per soddisfare
            la richiesta (GET, POST)</p>
          </li>

          <li>
            <p><em>URL</em></p>

            <p>l&#39;indirizzo internet del sito web richiesto dal
            client</p>
          </li>

          <li>
            <p><em>Ident</em></p>

            <p>determina l&#39;utente o l&#39;identificativo del client che
            ha richiesto il servizio</p>
          </li>

          <li>
            <p><em>Hierarchy Data / Hostname</em></p>

            <p>identifica come e dove la richiesta &egrave; stata
            processata</p>
          </li>

          <li>
            <p><em>Content Type</em></p>

            <p>come da RFC viene riportato il campo Content-Type
            dell&#39;header HTTP</p>
          </li>
        </ol>

        <p>Naturalmente appare chiaro che con un p&ograve; di comandi shell
        UNIX&reg; o perl scripting si pu&ograve; tirar fuori molto
        pi&ugrave; di quello di cui abbiamo bisogno da questo file di
        log.</p>
      </div>

      <div class="SECT1">
        <hr />

        <h2 class="SECT1"><a name="SEC-LOG-IN-ALTRI-FORMATI" id=
        "SEC-LOG-IN-ALTRI-FORMATI"></a>22.3. Log in altri formati</h2>

        <p>Un&#39;interessante features offerta da Squid &egrave; quella di
        cambiare il formato di output del log, vale la pena citare due
        metodologie molto interessanti ai fini dell&#39;amministrazione di
        sistema</p>

        <ol type="1">
          <li>
            <p>la prima opzione a nostra disposizione &egrave; la
            compatibilit&agrave; con il log di un server <em>httpd</em></p>
          </li>

          <li>
            <p>la seconda opzione a nostra disposizione &egrave; la
            possibilit&agrave; di disporre di un file di log il cui output
            &egrave; nel formato <em>custom log format</em></p>
          </li>
        </ol>

        <p>la prima opzione &egrave; facilmente realizzabile introducendo
        il seguente TAG nel file di configurazione <em>squid.conf</em></p>

        <table border="0" bgcolor="#E0E0E0" width="100%">
          <tr>
            <td>
              <pre class="PROGRAMLISTING">
emulate_httpd_log on 
  
</pre>
            </td>
          </tr>
        </table>

        <p>per quanto concerne la seconda opzione, &egrave; necessario
        applicare una <em>patch</em> al codice sorgente di Squid e
        compilarlo nuovamente, ulteriori informazioni possono essere
        reperite sull&#39;URLs <a href=
        "http://devel.squid-cache.org/customlog/" target=
        "_top">http://devel.squid-cache.org/customlog/</a>, la patch in
        questione &egrave; invece scaricabile dalla URLs <a href=
        "http://devel.squid-cache.org/cgi-bin/diff2/customlog.patch"
        target="_top">http://devel.squid-cache.org/cgi-bin/diff2/customlog.patch</a>.
        E&#39; anche possibile processare il file <em>access.log</em> con
        uno script perl appositamente realizzato e reperibile presso la
        URL&#39;s <a href="http://cord.de/tools/squid/Welcome.html.en"
        target="_top">http://cord.de/tools/squid/Welcome.html.en</a>.
        E&#39; previsto l&#39;inserimento del <em>custom log Format</em>
        nella futura versione Squid-3.</p>
      </div>

      <div class="SECT1">
        <hr />

        <h2 class="SECT1"><a name="SEC-IL-FILE-CACHE.LOG" id=
        "SEC-IL-FILE-CACHE.LOG"></a>22.4. Troubleshooting con il file
        <em>cache.log</em></h2>

        <p>Quando si implementa un nuovo sistema Squid &egrave; buona norma
        tenere sempre sotto controllo il file di log <em>cache.log</em>,
        verificare il contenuto di questo file di log &egrave; un ottimo
        sistema per eseguire il debug e il troubleshooting ed ottenere una
        configurazione ottimale per una nuova installazione di Squid.</p>

        <div class="SECT2">
          <hr />

          <h3 class="SECT2"><a name="SUBSEC-CACHE-LOG-TAIL" id=
          "SUBSEC-CACHE-LOG-TAIL"></a>22.4.1. Utilizzare <em>tail</em>(8)
          ed <em>xterm</em>(8)</h3>

          <p>Per verificare il funzionamento di Squid in tempo reale
          utilizzeremo il comando <em>tail</em>(8) che, se utilizzato con
          l&#39;opzione <em>-f</em> continuer&agrave; a leggere tutti i
          caratteri prodotti dal file di log assumendo che il file stesso
          sia in continua crescita. Per lavorare correttamente utilizzeremo
          pi&ugrave; finestre <em>xterm(8).</em> Questo programma, che
          fornisce l&#39;emulazione terminale per un sistema X Window, ci
          consentir&agrave; di utilizzare diverse sessioni terminale per
          impartire comandi e tenere sotto controllo il file di log.
          Nell&#39;esempio seguente eseguiremo il reload della
          configurazione di Squid con il comando <em>squid -k
          reconfigure</em></p>

          <table border="0" bgcolor="#E0E0E0" width="100%">
            <tr>
              <td>
                <pre class="PROGRAMLISTING">
[root@portatilo root]# squid -k reconfigure
2004/04/13 12:34:39| Cache dir &#39;/usr/local/squid/var/cache&#39; size changed to 102400 KB
2004/04/13 12:34:39| Initialising SSL.
2004/04/13 12:34:39| Error error setting CA certificate locations: error:00000000:lib(0):func(0):reason(0)
2004/04/13 12:34:39| continuing anyway...
   
</pre>
              </td>
            </tr>
          </table>

          <p>contemporaneamente utilizziamo il comando <em>tail</em>(8)</p>

          <table border="0" bgcolor="#E0E0E0" width="100%">
            <tr>
              <td>
                <pre class="PROGRAMLISTING">
[root@portatilo root]# tail -f /usr/local/squid/var/logs/cache.log
2004/04/13 12:21:14| Reconfiguring Squid Cache (version 3.0-PRE3)...
2004/04/13 12:21:14| FD 11 Closing HTTP connection
2004/04/13 12:21:14| FD 12 Closing ICP connection
2004/04/13 12:21:14| FD 13 Closing HTCP socket
2004/04/13 12:21:14| FD 14 Closing SNMP socket
2004/04/13 12:21:14| Cache dir &#39;/usr/local/squid/var/cache&#39; size remains unchanged at 102400 KB
2004/04/13 12:21:14| Initialising SSL.
2004/04/13 12:21:14| Error error setting CA certificate locations: error:00000000:lib(0):func(0):reason(0)
2004/04/13 12:21:14| continuing anyway...
2004/04/13 12:21:14| User-Agent logging is disabled.
2004/04/13 12:21:14| DNS Socket created at 0.0.0.0, port 32793, FD 7
2004/04/13 12:21:14| Adding nameserver 192.168.10.4 from /etc/resolv.conf
2004/04/13 12:21:14| Adding nameserver 192.168.10.254 from /etc/resolv.conf
2004/04/13 12:21:14| Accepting HTTP connections at 0.0.0.0, port 3128, FD 8.
2004/04/13 12:21:14| Accepting ICP messages at 0.0.0.0, port 3130, FD 10.
2004/04/13 12:21:14| Accepting HTCP messages on port 4827, FD 11.
2004/04/13 12:21:14| Accepting SNMP messages on port 3401, FD 12.
2004/04/13 12:21:14| WCCP Disabled.
2004/04/13 12:21:15| Loaded Icons.
2004/04/13 12:21:15| Ready to serve requests.
   
</pre>
              </td>
            </tr>
          </table>

          <p>nel caso specifico viene segnalato un errore relativo alla
          impostazione del percorso della CA<a name="AEN5681" href=
          "#FTN.AEN5681" id="AEN5681">[33]</a>, vengono riconosciuti due
          name server e Squid rimarr&agrave; in ascolto delle connessioni
          HTTP sulla porta 3128, dei messaggi ICP sulla porta 3130, dei
          messaggi HTCP<a name="AEN5683" href="#FTN.AEN5683" id=
          "AEN5683">[34]</a> sulla porta 4827. Per finire Squid accetta le
          connessioni SNMP sulla porta 3401. Nonostante l&#39;errore
          segnalato, Squid si &egrave; avviato correttamente, il messaggio
          <em>Ready to serve requests</em> &egrave; fondamentale per
          definire lo stato attuale di Squid.</p>

          <p>Il File <em>cache.log</em> dunque continene le informazioni
          relative alla configurazione di avviamento di Squid, fornisce
          dunque un insieme di informazioni relative agli errori che
          possono verificarsi durante le operazioni che vengono svolte da
          Squid e non solo in fase di avviamento. Per proseguire con il
          nostro esempio, abilitiamo l&#39;acceleratore HTTP e confrontiamo
          nuovamente l&#39;output del file <em>cache.log</em></p>

          <table border="0" bgcolor="#E0E0E0" width="100%">
            <tr>
              <td>
                <pre class="PROGRAMLISTING">
[root@portatilo root]# squid -k reconfigure
2004/04/13 12:34:39| Initialising SSL.
2004/04/13 12:34:39| Using certificate in /usr/local/squid/etc/key.crt
2004/04/13 12:34:39| Using private key in /usr/local/squid/etc/key.key
2004/04/13 12:34:39| Error error setting CA certificate locations: error:00000000:lib(0):func(0):reason(0)
2004/04/13 12:34:39| continuing anyway...
2004/04/13 12:34:39| Cache dir &#39;/usr/local/squid/var/cache&#39; size changed to 102400 KB
2004/04/13 12:34:39| Initialising SSL.
2004/04/13 12:34:39| Error error setting CA certificate locations: error:00000000:lib(0):func(0):reason(0)
2004/04/13 12:34:39| continuing anyway...
   
</pre>
              </td>
            </tr>
          </table>

          <p>contemporaneamente utilizziamo il comando <em>tail</em>(8)</p>

          <table border="0" bgcolor="#E0E0E0" width="100%">
            <tr>
              <td>
                <pre class="PROGRAMLISTING">
[root@portatilo root]# tail -f /usr/local/squid/var/logs/cache.log
2004/04/13 12:34:39| Reconfiguring Squid Cache (version 3.0-PRE3)...
2004/04/13 12:34:39| FD 8 Closing HTTP connection
2004/04/13 12:34:39| FD 10 Closing ICP connection
2004/04/13 12:34:39| FD 11 Closing HTCP socket
2004/04/13 12:34:39| FD 12 Closing SNMP socket
2004/04/13 12:34:39| Initialising SSL.
2004/04/13 12:34:39| Using certificate in /usr/local/squid/etc/key.crt
2004/04/13 12:34:39| Using private key in /usr/local/squid/etc/key.key
2004/04/13 12:34:39| Error error setting CA certificate locations: error:00000000:lib(0):func(0):reason(0)
2004/04/13 12:34:39| continuing anyway...
2004/04/13 12:34:39| Cache dir &#39;/usr/local/squid/var/cache&#39; size remains unchanged at 102400 KB
2004/04/13 12:34:39| Initialising SSL.
2004/04/13 12:34:39| Error error setting CA certificate locations: error:00000000:lib(0):func(0):reason(0)
2004/04/13 12:34:39| continuing anyway...
2004/04/13 12:34:39| User-Agent logging is disabled.
2004/04/13 12:34:39| DNS Socket created at 0.0.0.0, port 32796, FD 7
2004/04/13 12:34:39| Adding nameserver 192.168.10.4 from /etc/resolv.conf
2004/04/13 12:34:39| Adding nameserver 192.168.10.254 from /etc/resolv.conf
2004/04/13 12:34:39| Accepting HTTP connections at 0.0.0.0, port 3128, FD 8.
2004/04/13 12:34:39| Accepting HTTPS connections at 0.0.0.0, port 443, FD 10.
2004/04/13 12:34:39| Accepting ICP messages at 0.0.0.0, port 3130, FD 11.
2004/04/13 12:34:39| Accepting HTCP messages on port 4827, FD 12.
2004/04/13 12:34:39| Accepting SNMP messages on port 3401, FD 13.
2004/04/13 12:34:39| WCCP Disabled.
2004/04/13 12:34:39| Loaded Icons.
2004/04/13 12:34:39| Ready to serve requests.
2004/04/13 12:34:39| Configuring Parent www1.dominio.com/80/0
   
</pre>
              </td>
            </tr>
          </table>

          <p>come potete ben vedere, &egrave; stata inizializzata la porta
          443 che rimane in ascolto delle connessioni HTTPS. Possiamo
          concludere dicendo che il controllo del file <em>cache.log</em>
          &egrave; fondamentale per risolvere diversi problemi di
          configurazione e per tenere sotto costante controllo lo stato di
          funzionamento di Squid.</p>
        </div>

        <div class="SECT2">
          <hr />

          <h3 class="SECT2"><a name="SUBSEC-LIVELLI-DI-DEBUG" id=
          "SUBSEC-LIVELLI-DI-DEBUG"></a>22.4.2. Livelli di debug</h3>

          <p>E&#39; possibile aumentare il numero delle informazioni di
          debug che vengono registrate nel file di cache logging
          <em>cache.log</em> utilizzando il TAG <em>debug_options</em>.
          Normalmente l&#39;output di questo file di log &egrave; impostato
          con un valore di debug molto basso, come default Squid imposta il
          TAG <em>debug_options</em> con il valore</p>

          <table border="0" bgcolor="#E0E0E0" width="100%">
            <tr>
              <td>
                <pre class="PROGRAMLISTING">
debug_options ALL,1
   
</pre>
              </td>
            </tr>
          </table>

          <p>se abbiamo la necessit&agrave; di effettuare un tuning molto
          accurato della nostra web cache, possiamo impostare un valore di
          debug pi&ugrave; alto</p>

          <table border="0" bgcolor="#E0E0E0" width="100%">
            <tr>
              <td>
                <pre class="PROGRAMLISTING">
debug_options ALL,5
   
</pre>
              </td>
            </tr>
          </table>

          <p>il full debugging viene rappresentato dal livello 9, questa
          impostazione determina la scrittura di file di log molto grandi.
          L&#39;impostazione <em>ALL</em> determina il livello di debugging
          per tutte le sezioni, &egrave; raccomandabile eseguire il debug
          con l&#39;impostazione <em>ALL,1</em>.</p>
        </div>
      </div>

      <div class="SECT1">
        <hr />

        <h2 class="SECT1"><a name="SEC-CODICI-DI-STATO" id=
        "SEC-CODICI-DI-STATO"></a>22.5. I codici di stato di Squid</h2>

        <p>Per comprendere al meglio i log di Squid dobbiamo saper
        interpretare i codici di stato, i codici <em>TCP_</em> si
        riferiscono alle richieste dirette verso la porta HTTP
        (generalmente la 3128), i codici <em>UDP_</em> invece si
        riferiscono alle richieste dirette verso la porta ICP (generalmente
        la 3130). Ecco una serie di statistiche relative ai codici di stato
        di Squid in una condizione di lavoro lavoro normale</p>

        <table border="0" bgcolor="#E0E0E0" width="100%">
          <tr>
            <td>
              <pre class="PROGRAMLISTING">
n. hits  valore %  codice di stato
---------------------------------------------------
1 14630    39.58%  TCP_MISS:DIRECT
2  5528    14.96%  TCP_REFRESH_HIT:DIRECT
3  4576    12.38%  TCP_HIT:NONE
4  4566    12.35%  TCP_CLIENT_REFRESH_MISS:DIRECT
5  4159    11.25%  TCP_IMS_HIT:NONE
  
</pre>
            </td>
          </tr>
        </table>

        <p>una statistica come questa basata appunto sui codici di stato,
        consente di tenere sotto controllo lo stato delle richieste dirette
        verso Squid e consente anche di redigere delle statistiche
        relativamente al risparmio di banda internet all&#39;interno della
        nostra LAN. Ricordiamo al lettore che &egrave; possibile
        disabilitare la registazione del log per le richieste del tipo ICP,
        utilizzando il TAG <em>log_icp_queries</em> non verr&agrave;
        registrato nessun codice di stato ICP.</p>

        <p>Squid supporta i seguenti codici di stato</p>

        <ul>
          <li>
            <p><em>TCP_HIT</em></p>

            <p>&egrave; stata trovata una copia valida dell&#39;oggetto
            nella cache di Squid</p>
          </li>

          <li>
            <p><em>TCP_MISS</em></p>

            <p>l&#39;oggetto richiesto non &egrave; presente nella cache di
            Squid</p>
          </li>

          <li>
            <p><em>TCP_REFRESH_HIT</em></p>

            <p>l&#39;oggetto &egrave; presente nella cache di Squid ma si
            tratta di un&#39;oggetto vecchio (STALE). La query IMS relativa
            all&#39;oggetto &egrave; &quot;304 not modified&quot;.</p>
          </li>

          <li>
            <p><em>TCP_REF_FAIL_HIT</em></p>

            <p>l&#39;oggetto &egrave; presente nella cache ma si tratta di
            una copia vecchia. La query IMS fallisce se l&#39;oggetto viene
            trasportato</p>
          </li>

          <li>
            <p><em>TCP_REFRESH_MISS</em></p>

            <p>l&#39;oggetto &egrave; presente nella cache ma si tratta di
            una copia vecchia. la query IMS ritorna un nuovo oggetto</p>
          </li>

          <li>
            <p><em>TCP_CLIENT_REFRESH_MISS</em></p>

            <p>Il client annuncia un messaggio &quot;no-cache&quot; pragma,
            la richiesta dell&#39;oggetto visualizza dei messaggi di
            controllo della cache, la cache deve aggiornare
            l&#39;oggetto</p>
          </li>

          <li>
            <p><em>TCP_IMS_HIT</em></p>

            <p>Il client annuncia una richiesta IMS per un oggetto che
            &egrave; presente nella cache e non &egrave; scaduto</p>
          </li>

          <li>
            <p><em>TCP_SWAPFAIL_MISS</em></p>

            <p>L&#39;oggetto era nella cache ma non &egrave; pi&ugrave;
            accessibile</p>
          </li>

          <li>
            <p><em>TCP_NEGATIVE_HIT</em></p>

            <p>si tratta di una richiesta per un oggetto non presente nella
            cache, il messaggio &egrave; &quot;404 not found&quot;, la
            cache pensa che questo oggetto sia inaccessibile. Riferirsi
            alle spiegazioni relative al TAG <em>negative_ttl</em> che sono
            contenute nel file <em>squid.conf</em></p>
          </li>

          <li>
            <p><em>TCP_MEM_HIT</em></p>

            <p>una copia valida dell&#39;oggetto richiesto &egrave; sia
            nella cache che nella memoria, con questo messaggio Squid
            indica che l&#39;accesso al disco &egrave; stato evitato</p>
          </li>

          <li>
            <p><em>TCP_DENIED</em></p>

            <p>l&#39;accesso viene bloccato per questo ripo di
            richiesta</p>
          </li>

          <li>
            <p><em>TCP_OFFLINE_HIT</em></p>

            <p>l&#39;oggetto richiesto &egrave; stato reperito direttamente
            dalla cache durante la modalit&agrave; off-line di Squid.
            Questo tipo di modalit&agrave; non valida nessun oggetto,
            riferirsi al TAG <em>offline_mode</em> contenuto nel file
            <em>squid.conf</em></p>
          </li>

          <li>
            <p><em>UDP_HIT</em></p>

            <p>esiste una copia valida dell&#39;oggetto nella cache di
            Squid</p>
          </li>

          <li>
            <p><em>UDP_MISS</em></p>

            <p>l&#39;oggetto richiesto non &egrave; nella cache</p>
          </li>

          <li>
            <p><em>UDP_DENIED</em></p>

            <p>per questo tipo di richiesta l&#39;accesso &egrave; stato
            negato</p>
          </li>

          <li>
            <p><em>UDP_INVALID</em></p>

            <p>&egrave; stata ricevuta una richiesta non valida</p>
          </li>

          <li>
            <p><em>UDP_MISS_NOFETCH</em></p>

            <p>se l&#39;avviamento di Squid viene richiamato con il comando
            <em>squid -Y</em> (se la vostra cache &egrave; di tipo child ed
            usa il protocollo ICP, questa opzione consente una
            rigenerazione veloce della cache), nel caso si dovessero
            verificare degli errori frequenti, la cache ritorner&agrave;
            questo codice o dei codici UDP_HIT.</p>
          </li>

          <li>
            <p><em>NONE</em></p>

            <p>Si verifica con gli errori sulle richieste effettuate dal
            cache manager</p>
          </li>
        </ul>
      </div>

      <div class="SECT1">
        <hr />

        <h2 class="SECT1"><a name="SEC-CODICI-DI-STATO-HTTP" id=
        "SEC-CODICI-DI-STATO-HTTP"></a>22.6. Codici di Stato HTTP</h2>

        <p>Squid utilizza quasi tutti i codici di stato HTTP di cui alla
        RFC 2616 (<a href=
        "http://www.w3.org/Protocols/rfc2616/rfc2616.html" target=
        "_top">http://www.w3.org/Protocols/rfc2616/rfc2616.html</a>) -
        Hypertext Transfer Protocol -- HTTP/1.1. Squid-2 utilizza molti dei
        codici descritti in questa RFC ad eccezione dei codici 307
        (Temporary Redirect), 416 (Request Range Not Satisfiable) e 417
        (Expectation Failed). Squid utilizza anche dei codici aggiuntivi
        come lo 0 (result code being unavailable) e 600 (segnalare un
        header non valido o un errore del proxy). Molte definizioni sono
        state aggiunte nella RFC 2518 (<a href=
        "http://www.ietf.org/rfc/rfc2518.txt" target=
        "_top">http://www.ietf.org/rfc/rfc2518.txt</a>) - HTTP Extensions
        for Distributed Authoring -- WEBDAV.</p>

        <table border="0" bgcolor="#E0E0E0" width="100%">
          <tr>
            <td>
              <pre class="PROGRAMLISTING">
&quot;000&quot; ; Used mostly with UDP traffic (Squid)
&quot;100&quot; ; Section 10.1.1: Continue
&quot;101&quot; ; Section 10.1.2: Switching Protocols
&quot;200&quot; ; Section 10.2.1: OK
&quot;201&quot; ; Section 10.2.2: Created
&quot;202&quot; ; Section 10.2.3: Accepted
&quot;203&quot; ; Section 10.2.4: Non-Authoritative Information
&quot;204&quot; ; Section 10.2.5: No Content
&quot;205&quot; ; Section 10.2.6: Reset Content
&quot;206&quot; ; Section 10.2.7: Partial Content
&quot;300&quot; ; Section 10.3.1: Multiple Choices
&quot;301&quot; ; Section 10.3.2: Moved Permanently
&quot;302&quot; ; Section 10.3.3: Found
&quot;303&quot; ; Section 10.3.4: See Other
&quot;304&quot; ; Section 10.3.5: Not Modified
&quot;305&quot; ; Section 10.3.6: Use Proxy
&quot;307&quot; ; Squid unsupported
&quot;400&quot; ; Section 10.4.1: Bad Request
&quot;401&quot; ; Section 10.4.2: Unauthorized
&quot;402&quot; ; Section 10.4.3: Payment Required
&quot;403&quot; ; Section 10.4.4: Forbidden
&quot;404&quot; ; Section 10.4.5: Not Found
&quot;405&quot; ; Section 10.4.6: Method Not Allowed
&quot;406&quot; ; Section 10.4.7: Not Acceptable
&quot;407&quot; ; Section 10.4.8: Proxy Authentication Required
&quot;408&quot; ; Section 10.4.9: Request Time-out
&quot;409&quot; ; Section 10.4.10: Conflict
&quot;410&quot; ; Section 10.4.11: Gone
&quot;411&quot; ; Section 10.4.12: Length Required
&quot;412&quot; ; Section 10.4.13: Precondition Failed
&quot;413&quot; ; Section 10.4.14: Request Entity Too Large
&quot;414&quot; ; Section 10.4.15: Request-URI Too Large
&quot;415&quot; ; Section 10.4.16: Unsupported Media Type
&quot;416&quot; ; Squid unsupported
&quot;417&quot; ; Squid unsupported
&quot;500&quot; ; Section 10.5.1: Internal Server Error
&quot;501&quot; ; Section 10.5.2: Not Implemented
&quot;502&quot; ; Section 10.5.3: Bad Gateway
&quot;503&quot; ; Section 10.5.4: Service Unavailable
&quot;504&quot; ; Section 10.5.5: Gateway Time-out
&quot;505&quot; ; Section 10.5.6: HTTP Version not supported 
&quot;600&quot; ; Squid header parsing error (Squid)
  
</pre>
            </td>
          </tr>
        </table>
      </div>

      <div class="SECT1">
        <hr />

        <h2 class="SECT1"><a name="SEC-METODI-DI-RICHIESTA" id=
        "SEC-METODI-DI-RICHIESTA"></a>22.7. Metodi di richiesta
        supportati</h2>

        <p>Squid riconosce diversi metodi di richiesta HTTP che vengono
        definiti nella RFC 2616 (<a href=
        "http://www.w3.org/Protocols/rfc2616/rfc2616.html" target=
        "_top">http://www.w3.org/Protocols/rfc2616/rfc2616.html</a>) -
        Hypertext Transfer Protocol -- HTTP/1.1. Le nuove versioni di
        Squid, in particolare a partire da squid-2.2.STABLE5 e versioni
        successive, riconoscono anche i metodi di richiesta che sono
        descritti nella RFC 2518 (<a href=
        "http://www.faqs.org/rfcs/rfc2518.html" target=
        "_top">http://www.faqs.org/rfcs/rfc2518.html</a>) - HTTP Extensions
        for Distributed Authoring -- WEBDAV. La lista che alleghiamo di
        seguito &egrave; disponibile alla URLs <a href=
        "http://www.squid-cache.org/Doc/FAQ/FAQ-6.html#ss6.9" target=
        "_top">http://www.squid-cache.org/Doc/FAQ/FAQ-6.html#ss6.9</a></p>

        <table border="0" bgcolor="#E0E0E0" width="100%">
          <tr>
            <td>
              <pre class="PROGRAMLISTING">
method    defined    cachabil meaning
--------- ---------- ---------- ----------------------------------
GET       HTTP/0.9   possibly object retrieval and simple searches
HEAD      HTTP/1.0   possibly metadata retrieval
POST      HTTP/1.0   CC or Exp. submit data (to a program)
PUT       HTTP/1.1   never upload data (e.g. to a file)
DELETE    HTTP/1.1   never remove resource (e.g. file)
TRACE     HTTP/1.1   never appl. layer trace of request route
OPTIONS   HTTP/1.1   never request available comm. options
CONNECT   HTTP/1.1r3 never tunnel SSL connection
ICP_QUERY            Squid never used for ICP based exchanges
PURGE                Squid never remove object from cache
PROPFIND  rfc2518    ? retrieve properties of an object
PROPATCH  rfc2518    ? change properties of an object
MKCOL     rfc2518    never create a new collection
COPY      rfc2518    never create a duplicate of src in dst
MOVE      rfc2518    never atomically move src to dst
LOCK      rfc2518    never lock an object against modifications
UNLOCK    rfc2518    never unlock an object
  
</pre>
            </td>
          </tr>
        </table>
      </div>

      <div class="SECT1">
        <hr />

        <h2 class="SECT1"><a name="SEC-CODICI-GERARCHICI-PER-PEERING" id=
        "SEC-CODICI-GERARCHICI-PER-PEERING"></a>22.8. Codici gerarchici per
        il peering con altre webcache</h2>

        <p>Nel caso si utilizzi Squid all&#39;interno di una cache
        gerarchica, nei files di log potremmo trovare i seguenti codici
        gerarchici</p>

        <ul>
          <li>
            <p><em>NONE</em></p>

            <p>per un TCP HIT o una richiesta TCP fallita o una richiesta
            effettuata dal <em>cachemgr</em> e per tutte le richieste UDP
            nelle quali non sono presenti informazioni sulla gerarchia</p>
          </li>

          <li>
            <p><em>DIRECT</em></p>

            <p>l&#39;oggetto viene prelevato direttamente dal server di
            origine</p>
          </li>

          <li>
            <p><em>SIBLING_HIT</em></p>

            <p>l&#39;oggetto viene prelevato da una cache <em>sibling</em>
            che risponde con un messaggio UDP_HIT</p>
          </li>

          <li>
            <p><em>PARENT_HIT</em></p>

            <p>l&#39;oggetto viene prelevato da una cache <em>parent</em>
            che risponde con un messaggio UDP_HIT.</p>
          </li>

          <li>
            <p><em>DEFAULT_PARENT</em></p>

            <p>nessuna query ICP &egrave; stata trasmessa, la cache
            <em>parent</em> viene scelta da Squid perch&egrave; &egrave;
            marcata come default nel file <em>squid.conf</em></p>
          </li>

          <li>
            <p><em>SINGLE_PARENT</em></p>

            <p>l&#39;oggetto &egrave; stato richiesto all&#39;unico sistema
            cache <em>parent</em> adatto per soddisfare la URL
            richiesta</p>
          </li>

          <li>
            <p><em>FIRST_UP_PARENT</em></p>

            <p>l&#39;oggetto &egrave; stato prelevato dal primo sistema
            cache <em>parent</em> inserito nella lista dei sistemi che sono
            in relazione parent</p>
          </li>

          <li>
            <p><em>NO_PARENT_DIRECT</em></p>

            <p>l&#39;oggetto &egrave; stato prelevato dal server di
            origine, non esiste alcun sistema parent per la URL
            richiesta</p>
          </li>

          <li>
            <p><em>FIRST_PARENT_MISS</em></p>

            <p>l&#39;oggetto &egrave; stato prelevato dal sistema cache
            <em>parent</em> che si presenta con il miglior RTT<a name=
            "AEN5855" href="#FTN.AEN5855" id="AEN5855">[35]</a></p>
          </li>

          <li>
            <p><em>CLOSEST_PARENT_MISS</em></p>

            <p>Questo cache <em>parent</em> &egrave; stato scelto
            perch&egrave; &egrave; incluso nel pi&ugrave; basso RTT se
            paragonato con quello del server di origine</p>
          </li>

          <li>
            <p><em>CLOSEST_PARENT</em></p>

            <p>la selezione della cache <em>parent</em> &egrave; basata
            sulla nostra misurazione del RTT</p>
          </li>

          <li>
            <p><em>CLOSEST_DIRECT</em></p>

            <p>la nostra misurazione RTT ritorna un tempo pi&ugrave; corto
            rispetto a qualsiasi cache <em>parent</em></p>
          </li>

          <li>
            <p><em>NO_DIRECT_FAIL</em></p>

            <p>l&#39;oggetto non pu&ograve; essere richiesto, controllare
            il TAG <em>never_direct</em> oppure non ci sono sistemi cache
            <em>parent</em> disponibili</p>
          </li>

          <li>
            <p><em>SOURCE_FASTEST</em></p>

            <p>il sito di origine &egrave; stato scelto perch&egrave; il
            ping sorgente &egrave; arrivato velocemente</p>
          </li>

          <li>
            <p><em>ROUNDROBIN_PARENT</em></p>

            <p>dai sistemi cache <em>parent</em> sono arrivate le risposte.
            Il sistema cache <em>parent</em> &egrave; stato scelto
            perch&egrave; &egrave; stato marcato come sistema in
            modalit&agrave; di round robin nel file di configurazione
            <em>squid.conf</em></p>
          </li>

          <li>
            <p><em>CACHE_DIGEST_HIT</em></p>

            <p>Il sistema peer &egrave; stato selezionato perch&egrave; il
            cache digest ha predetto un hit</p>
          </li>

          <li>
            <p><em>CD_PARENT_HIT</em></p>

            <p>Il sistema parent &egrave; stato scelto perch&egrave; il
            cache digest ha predetto un hit</p>
          </li>

          <li>
            <p><em>CD_SIBLING_HIT</em></p>

            <p>il sistema di cache <em>sibling</em> &egrave; stato scelto
            perch&egrave; il cache digest ha predetto un hit</p>
          </li>

          <li>
            <p><em>CARP</em></p>

            <p>Il peer &egrave; stato selezionato dal protocollo CARP</p>
          </li>
        </ul>

        <p>molti di questi codici sono preceduti dal valore
        <em>TIMEOUT_</em>, questo accade se intercorre un timeout maggiore
        a due secondi nel momento in cui tutte le risposte ICP arrivano
        dalle neighbors, per maggiori informazioni controllare il TAG
        <em>icp_query_timeout</em> nel file <em>squid.conf</em></p>

        <table border="0" bgcolor="#E0E0E0" width="100%">
          <tr>
            <td>
              <pre class="PROGRAMLISTING">
code                 meaning
-------------------- -------------------------------------------------
PARENT_UDP_HIT_OBJ   hit objects are not longer available
SIBLING_UDP_HIT_OBJ  hit objects are not longer available
SSL_PARENT_MISS SSL  can now be handled by squid
FIREWALL_IP_DIRECT   No special logging for hosts inside the firewall
LOCAL_IP_DIRECT No   special logging for local networks
  
</pre>
            </td>
          </tr>
        </table>
      </div>

      <div class="SECT1">
        <hr />

        <h2 class="SECT1"><a name="SEC-STRUMENTI-DI-ANALISI-DEI-LOG" id=
        "SEC-STRUMENTI-DI-ANALISI-DEI-LOG"></a>22.9. Strumenti di analisi
        dei Log</h2>

        <p>Passiamo ora alla discussione inerente gli strumenti e delle
        metodologie che utilizzeremo per effettuare l&#39;analisi dei file
        di log. Appare chiaro, anche sulla base di quanto scritto in
        precedenza, che la registrazione delle attivit&agrave; pi&ugrave;
        importanti viene memorizzata nel file <em>access.log</em>. In
        questo file troviamo sia le informazioni inerenti gli accessi, sia
        le informazioni relative alle prestazioni della nostra cache.</p>

        <p>Introduciamo il discorso dell&#39;analisi dei log dicendo che, i
        file di log stessi devono essere necessariamente gestiti in base
        alla loro grandezza. In uno scenario dove pi&ugrave; di 500 utenti
        accedono ad internet attraverso la delega di Squid, il file
        <em>access.log</em> pu&ograve; anche raggiungere dimensioni vicine
        al gigabyte per una sola settimana d&#39;utilizzo. Per questo
        motivo la prima cosa da fare &egrave; utilizzare il nostro sistema
        di schedulazione dei processi (crond) in maniera appropriata, nella
        fattispecie ci serviremo del comando apposito offerto da Squid per
        ruotare i file di log, ovvero:</p>

        <table border="0" bgcolor="#E0E0E0" width="100%">
          <tr>
            <td>
              <pre class="PROGRAMLISTING">
squid -k rotate 
  
</pre>
            </td>
          </tr>
        </table>

        <p>Il comando di cui sopra generer&agrave; un file
        <em>access.log</em>.N dove &quot;N&quot; indica un numero
        incrementale a partire da 0 sino a 9 che indica il numero di
        rotazione del file di log, tale procedura consente:</p>

        <ul>
          <li>
            <p>di evitare che il log diventi un file di grandezza
            incontrollata</p>
          </li>

          <li>
            <p>di dividere i report di analisi per periodi di tempo ben
            determinati</p>
          </li>

          <li>
            <p>di avere uno storico dei log in formato file.</p>
          </li>
        </ul>

        <p>Nei paragrafi successivi prenderemo in considerazione il file
        <em>access.log.0</em>, che differisce dal file di log
        &quot;normale&quot; in quanto si tratta del file di log
        direttamente successivo all&#39;originale routato, questa scelta
        permette di agire su un file di log senza dover fermare il processo
        di squid e/o di utilizzare il file di log in un lasso di tempo ben
        definito.</p>

        <p>Ricordiamo al lettore che, nell&#39;area <a href="contrib"
        target="_top">/contrib</a> &egrave; possibile trovare una tabella
        crontab correttamente configurata nella quale sono censiti tutti i
        comandi di rotating e log parsing.</p>

        <p>Non &egrave; nostro scopo consigliare un programma per la
        gestione dei log di Squid, per noi &egrave; fondamentale descrivere
        quelle applicazioni di largo utilizzo che consentiranno al lettore
        di scegliere il sistema di analisi che pi&ugrave; si addice alle
        sue esigenze. Ora passiamo in rassegna diverse soluzioni per le
        quali forniremo anche un breve commento.</p>

        <div class="SECT2">
          <hr />

          <h3 class="SECT2"><a name="SUBSEC-CALAMARIS" id=
          "SUBSEC-CALAMARIS"></a>22.9.1. Calamaris</h3>

          <p>Calamaris &egrave; sicuramente il pi&ugrave; famoso tra i log
          analyzer realizzati per Squid.</p>

          <p>Si tratta di tool scritto in perl, &egrave; una delle uniche
          applicazioni in grado di creare una statistica d&#39;utilizzo
          completa che non riguarda solamente gli accessi al sistema ed il
          livello di utilizzo ma gestisce anche le cache vicine (protocollo
          ICMP / parent e sibling) e la dislocazione degli oggetti nelle
          cache stesse, calamaris supporta la creazione di report sia in
          formato testo che in formato html che contengono le seguenti
          informazioni:</p>

          <ul>
            <li>
              <p>Status-report per richieste UDP e TCP</p>
            </li>

            <li>
              <p>Request-Method (GET, HEAD etc. etc.)</p>
            </li>

            <li>
              <p>Estensione dei file</p>
            </li>

            <li>
              <p>Performance della cache in un tempo determinato</p>
            </li>
          </ul>

          <p>Calamaris &egrave; anche utile per capire il livello di
          utilizzo della cache rispetto alle richieste, infatti viene anche
          gestita la percentuale di HIT rispetto ai MISS, l&#39;utilizzo di
          calamaris pu&ograve; anche essere un &quot;must&quot; ai fini
          della creazione di reportistica relativa alle performance del
          sistema. Ora vediamo un comando di esempio per la generazione di
          un report:</p>

          <table border="0" bgcolor="#E0E0E0" width="100%">
            <tr>
              <td>
                <pre class="PROGRAMLISTING">
[root@Norad root]# cat /dove/squid/logs/access.log.0 | calamaris -F html -u \
&gt;/web_server_root/calamaris/index.html 
   
</pre>
              </td>
            </tr>
          </table>

          <p>Calamaris &egrave; reperibile presso la URL&#39;s <a href=
          "http://cord.de/tools/squid/calamaris/Welcome.html.en" target=
          "_top">http://cord.de/tools/squid/calamaris/Welcome.html.en</a>.</p>
        </div>

        <div class="SECT2">
          <hr />

          <h3 class="SECT2"><a name="SUBSEC-WEBALIZER" id=
          "SUBSEC-WEBALIZER"></a>22.9.2. Webalizer</h3>

          <p>Questo software nato per la preparazione di reports per i log
          dei server web, pu&ograve; funzionare egregiamente anche per la
          gestione dei log di Squid. Webalizer &egrave; particolarmente
          indicato per i file di grosse dimensioni poich&egrave;, essendo
          scritto in C, &egrave; molto veloce nell&#39;elaborazione del
          file di log. Ricordiamo che la visione dei report prodotti da
          Webalizer necessita di un web server, il software consente anche
          la configurazione per la generazione di un&#39;archivio storico
          che terr&agrave; conto delle analisi effettuate in precedenza, in
          questo modo potremmo ottenere della reportistica
          incrementale.</p>

          <p>Per quello che riguarda le informazioni reperibili
          dall&#39;analisi del file di log, Webalizer gestisce le seguenti
          statistiche mensili:</p>

          <ul>
            <li>
              <p>Istogramma accessi giornalieri</p>
            </li>

            <li>
              <p>Istogramma accessi per ora</p>
            </li>

            <li>
              <p>Statistiche mensili, giornaliere ed orarie per: Pagina,
              File, Kbytes,Contatti</p>
            </li>

            <li>
              <p>Statistiche delle Top per quello che riguarda: Utenza, URL
              e Kbytes</p>
            </li>
          </ul>

          <p>Webalizer &egrave; sicuramente uno dei migliori log parsers
          disponibili oggi in circolazione, l&#39;unica pecca &egrave;
          quella di non consentire una analisi approfondita dei file di log
          visto che la sua prerogativa &egrave; quella di fornire dei
          risultati statistici di massima.</p>

          <p>La configurazione di webalizer &egrave; piuttosto semplice,
          basta configurare correttamente le principali variabili
          quali:</p>

          <table border="0" bgcolor="#E0E0E0" width="100%">
            <tr>
              <td>
                <pre class="PROGRAMLISTING">
LogFile /dir/del/log/access.log.0 
LogType squid 
OutputDir /dove/voglio/apache/webalizer 
   
</pre>
              </td>
            </tr>
          </table>

          <p>Ulteriori informazioni circa gli altri parametri di
          configurazione possono essere reperite all&#39;interno del file
          di configurazione commentato.</p>

          <p>Una volta decise le variabili nel file di conf, sar&agrave;
          necessario lanciare il comando:</p>

          <table border="0" bgcolor="#E0E0E0" width="100%">
            <tr>
              <td>
                <pre class="PROGRAMLISTING">
[root@Norad root]# webalizer -Q 
   
</pre>
              </td>
            </tr>
          </table>

          <p>Per tutte le altre informazioni su Webalizer consigliamo
          all&#39;utente di consultare la documentazione
          dell&#39;applicazione direttamente sul <a href=
          "http://www.mrunix.net/webalizer/" target="_top">sito Internet di
          Webalizer</a>.</p>
        </div>

        <div class="SECT2">
          <hr />

          <h3 class="SECT2"><a name="SUBSEC-SARG" id=
          "SUBSEC-SARG"></a>22.9.3. Sarg</h3>

          <p>Sarg (<em>Squid Analysis Report Generator</em>) &egrave; un
          altro ottimo analizzatore per i log di Squid, la sua
          peculiarit&agrave; &egrave; quella di essere orientato alla
          creazione di reportistica in base all&#39;utenza. Essendo
          anch&#39;esso scritto in linguaggio C &egrave; particolarmente
          indicato per file di grosse dimensioni.</p>

          <p>Lo storico d&#39;utilizzo &egrave; dato dal periodo di tempo a
          cui il log fa riferimento. Molto importante ai fini di una
          reportistica coerente &egrave; il susseguirsi dei log tramite il
          rotating degli stessi, a tal proposito consigliamo all&#39;utente
          di lanciare il comando sarg con l&#39;obbligo di analizzare un
          file <em>access.log.N</em> appena ruotato. Anche questo log
          analyzer necessita di un web server per la pubblicazione dei dati
          analizzati.</p>

          <p>Le informazioni reperibili sono le seguenti:</p>

          <ul>
            <li>
              <p>Reportistica in base all&#39;utenza con informazioni
              correlate in base a data, dati movimentati e siti
              richiesti</p>
            </li>

            <li>
              <p>Statistica dei siti pi&ugrave; accessi.</p>
            </li>

            <li>
              <p>Informazioni circa i tentativi negati.</p>
            </li>

            <li>
              <p>Reportistica per integrazione con SquidGuard.</p>
            </li>
          </ul>

          <p>La configurazione &egrave; alquanto semplice, come abbiamo
          gi&agrave; fatto con Webalizer sar&agrave; necessario editare il
          file di configurazione per definire le variabili principali
          quali:</p>

          <table border="0" bgcolor="#E0E0E0" width="100%">
            <tr>
              <td>
                <pre class="PROGRAMLISTING">
access_log /path/verso/access.log.0 
resolve_ip yes 
output_dir /path/del/web/server/sarg 
   
</pre>
              </td>
            </tr>
          </table>

          <p>A questo punto per creare i report sar&agrave; necessario
          lanciare l&#39;eseguibile del programma:</p>

          <table border="0" bgcolor="#E0E0E0" width="100%">
            <tr>
              <td>
                <pre class="PROGRAMLISTING">
[root@Norad root]# sarg 
   
</pre>
              </td>
            </tr>
          </table>

          <p>Ulteriori informazioni e documentazioni possono essere
          reperite sul <a href="http://web.onda.com.br/orso/sarg.html"
          target="_top">sito Internet</a> del programma.</p>
        </div>

        <div class="SECT2">
          <hr />

          <h3 class="SECT2"><a name="SUBSEC-SQUEEZER2" id=
          "SUBSEC-SQUEEZER2"></a>22.9.4. Squeezer2</h3>

          <p>Squeezer2 &egrave; il diretto successore del famoso script
          Squeezer. Si tratta di una applicazione scritta in perl che
          permette di avere ottima visione sullo stato della cache in
          termini di prestazioni, accessi e metodi http. Anche questo
          analizzatore di log fornisce la reportistica in formato html,
          possiamo generare tre tipologie di report in formato html:</p>

          <ul>
            <li>
              <p>Minima, fornisce una visione dello stato attuale della
              cache e delle sue prestazioni</p>
            </li>

            <li>
              <p>Media, fornisce una visione pi&ugrave; completa ampliando
              la visione minima con i report gli &quot;status&quot; ed i
              &quot;result&quot; sullo stato della cache che contengono
              anche i riferimenti temporali</p>
            </li>

            <li>
              <p>Massima, verr&agrave; generato un report totale (per tutte
              le opzioni consigliamo il lettore di confrontare la
              documentazione del sito) del file di log elaborato, questo
              tipo di report non &egrave; consigliabile dato che pu&ograve;
              creare pagine html di dimensioni considerevoli.</p>
            </li>
          </ul>

          <p>L&#39;utilizzo di Squeezer2 &egrave; alquanto semplice anche
          per un profano del linguaggio perl, baster&agrave; editare il
          file squeezer2.pl e configurare correttamente le seguenti
          variabili:</p>

          <table border="0" bgcolor="#E0E0E0" width="100%">
            <tr>
              <td>
                <pre class="PROGRAMLISTING">
my $base_dir = &#39;/usr/squid&#39;; 
my $conf_name = &#39;/usr/squid/etc/squid.conf&#39;; 
my $log_dir = $base_dir . &#39;/var/logs&#39;; 
my $log_name = &#39;access.log.0&#39;; 
   
</pre>
              </td>
            </tr>
          </table>

          <p>A questo punto lanceremo i seguenti comandi al fine di creare
          i report:</p>

          <table border="0" bgcolor="#E0E0E0" width="100%">
            <tr>
              <td>
                <pre class="PROGRAMLISTING">
[root@Norad root]# /usr/local/bin/squeezer2.pl /var/squid/logs/access.log.0 \
&gt;/www/squeezer/SQ`date +%Y%m%d`.html 
[root@Norad root]# /usr/local/bin/squeezer2.pl &gt; /www/squeezer/all.html 
   
</pre>
              </td>
            </tr>
          </table>

          <p>Il sito di riferimento &egrave; alla URL&#39;s <a href=
          "http://www.rraz.net/squeezer2/" target=
          "_top">http://www.rraz.net/squeezer2/</a>.</p>
        </div>

        <div class="SECT2">
          <hr />

          <h3 class="SECT2"><a name="SUBSEC-YAALA" id=
          "SUBSEC-YAALA"></a>22.9.5. Yaala</h3>

          <p>Anche questa applicazione rappresenta un ottimo sistema per la
          gestione e l&#39;analisi del log di Squid in particolare per
          quello che concerne i siti internet acceduti dai nostri utenti.
          La particolarit&agrave; di Yaala sta nel fatto che la creazione
          dei report in HTML &egrave; completamente configurabile, Yaala
          utilizza un linguaggio molto simile all&#39;SQL, l&#39;estrazione
          dei dati dal file di log analizzato pu&ograve; risultare molto
          simile ad una vera e propria select. E&#39; possibile quindi
          concatenare i dati stabilendo un criterio di aggregazione ed
          estrarre le informazioni desiderate dal file di log preso in
          considerazione.</p>

          <p>Esistono tre tipi di aggregazione possibili:</p>

          <ul>
            <li>
              <p>richieste</p>
            </li>

            <li>
              <p>bytes</p>
            </li>

            <li>
              <p>tempo intercorso</p>
            </li>
          </ul>

          <p>Dati questi tre tipi di aggregazione si possono estrarre i
          dati per campi, i campi disponibili sono:</p>

          <ul>
            <li>
              <p>client</p>
            </li>

            <li>
              <p>date</p>
            </li>

            <li>
              <p>hierarchycode</p>
            </li>

            <li>
              <p>hour</p>
            </li>

            <li>
              <p>httpstatus</p>
            </li>

            <li>
              <p>method</p>
            </li>

            <li>
              <p>mime</p>
            </li>

            <li>
              <p>peer</p>
            </li>

            <li>
              <p>protocol</p>
            </li>

            <li>
              <p>resultcode</p>
            </li>

            <li>
              <p>server</p>
            </li>
          </ul>

          <p>Per spiegare meglio passiamo direttamente ad un esempio di
          configurazione, editando il file &quot;config&quot; si devono
          definire quindi le variabili necessarie ed i criteri di
          estrazione dei dati:</p>

          <table border="0" bgcolor="#E0E0E0" width="100%">
            <tr>
              <td>
                <pre class="PROGRAMLISTING">
directory: &#39;reports&#39;; 
report: &#39;Classic&#39;; 
logtype: &#39;Squid&#39;; 
select: &quot;requests BY client, date, httpstatus, method, mime&quot;; 
   
</pre>
              </td>
            </tr>
          </table>

          <p>Analizzando l&#39;ultima riga aggregheremo i dati concatenando
          le richieste in base al client, la data, il codice http, il
          metodo http e il mimetype. Ora per creare i nostri report
          baster&agrave; lanciare il seguente comando:</p>

          <table border="0" bgcolor="#E0E0E0" width="100%">
            <tr>
              <td>
                <pre class="PROGRAMLISTING">
[root@Norad root]# yaala /path/verso/squid/logs/access.log.0 
   
</pre>
              </td>
            </tr>
          </table>

          <p>Ulteriori delucidazioni e riferimenti sono reperibili sulla
          URL&#39;s <a href="http://verplant.org/yaala/" target=
          "_top">http://verplant.org/yaala/</a>.</p>
        </div>

        <div class="SECT2">
          <hr />

          <h3 class="SECT2"><a name="SUBSEC-SQUIDALYSER" id=
          "SUBSEC-SQUIDALYSER"></a>22.9.6. SquidAlyser</h3>

          <p>SquidAlyser &egrave; un programma di analisi dei log molto
          potente. E&#39; scritto in perl e si appoggia ad un database
          (<em>MySQL</em> o <em>PostgreSQL</em>) per lo storage dei dati.
          L&#39;autore dell&#39;applicazione sconsiglia questo programma in
          scenari ad alta densit&agrave; d&#39;utenza in quanto esiste un
          grande impatto sia in termini di prestazioni (utilizzo del perl e
          di un database) che gestionali (mantenimento e manutenzione di
          una macchina DB).</p>

          <p>I dati che si possono estrarre sono tutti inerenti
          l&#39;utenza e si possono anche analizzare gli accessi in base a
          file chiamati o byte. L&#39;installazione comprende quindi la
          creazione di un database, l&#39;utilizzo di uno script che nel
          caso specifico si occupa di estrarre le informazioni e metterle
          nel DB e la configurazione corretta del web server per il CGI che
          creer&agrave; i report.</p>

          <p>Dato che la struttura di SquidAlyser &egrave; alquanto
          variegata non discuteremo della configurazione di questo sistema,
          ulteriori informazioni a riguardo sono reperibili sulla URL&#39;s
          <a href="http://ababa.org/index.html" target=
          "_top">http://ababa.org/index.html</a>.</p>
        </div>

        <div class="SECT2">
          <hr />

          <h3 class="SECT2"><a name="SUBSEC-LOGREP" id=
          "SUBSEC-LOGREP"></a>22.9.7. Logrep</h3>

          <p>Logrep &egrave; un software molto potente per la gestione dei
          log. Questa applicazione viene citata non tanto per la
          qualit&agrave; dei report che &egrave; in grado di generare
          quanto per la possibilit&agrave; che offre nel riunire in una
          unica applicazione la completa gestione dei molti file di log che
          oggi vengono prodotti.</p>

          <p>Nello specifico, Logrep pu&ograve; essere molto utile nel caso
          si volesse implementare una macchina preposta allo storage dei
          file di log ed alla creazione della reportistica. Tra i formati
          supportati da Logrep vale la pena citare oltre a Squid anche IIS,
          Apache, Exchange, Snort, Postfix, Iptables, NT Event ed altri.
          Ricordiamo che naturalmente nel caso si volesse implementare uno
          scenario simile a quello sopra descritto, si deve necessariamente
          procedere a copiare l&#39;<em>access.log.0</em> sul
          log-server.</p>

          <p>il sito di riferimento &egrave; alla URL&#39;s <a href=
          "http://logrep.sourceforge.net/" target=
          "_top">http://logrep.sourceforge.net/</a> .</p>
        </div>

        <div class="SECT2">
          <hr />

          <h3 class="SECT2"><a name="SUBSEC-LIRE" id=
          "SUBSEC-LIRE"></a>22.9.8. LIRE</h3>

          <p>Anche LIRE, come Logrep, &egrave; un software che consente la
          gestione e la creazione di report centralizzata, supporta una
          grande variet&agrave; di formati di files di log. LIRE viene
          inoltre citato perch&egrave; offre la possibilit&agrave; di
          installare sulla macchina log-server, che abbiamo brevemente
          descritto nel paragrafo precedente, un demone che rimane in
          ascolto delle informazioni che vengono trasmesse dal suo client
          che potr&agrave; essere installato sulla macchina Squid. In
          questo modo il client LIRE si occuper&agrave; di inviare il file
          di log direttamente al log-server sulla base dei dei criteri da
          noi impostati.</p>

          <p>Ulteriori informazioni possono essere reperite sulla URLs:
          <a href="http://logreport.org/lire/" target=
          "_top">http://logreport.org/lire/</a>.</p>
        </div>

        <div class="SECT2">
          <hr />

          <h3 class="SECT2"><a name="SUBSEC-SQUIDEFENDER" id=
          "SUBSEC-SQUIDEFENDER"></a>22.9.9. Squidefender</h3>

          <p>Squid Defender &egrave; un semplice script scritto in
          linguaggio perl che si occupa di analizzare il file
          <em>access.log</em> al fine di trovare possibili entry
          riguardanti possibili attacchi:</p>

          <ul>
            <li>
              <p>di tipo Worm.</p>
            </li>

            <li>
              <p>basati sul metodo HTTP_CONNECT (mail relaying, Aol MSG
              Etc. etc.)</p>
            </li>
          </ul>

          <p>Tra le altre funzionalit&agrave; importanti riportiamo:</p>

          <ul>
            <li>
              <p>&egrave; in grado di creare report in formato html e di
              inviare una e-mail di avviso ogni attacco riconosciuto</p>
            </li>

            <li>
              <p>consente, attraverso il suo file di configurazione, di
              creare dei propri criteri e delle proprie regole di
              altering</p>
            </li>

            <li>
              <p>&egrave; inoltre integrabile con iptables o ipchains per
              l&#39;inserimento di regole di firewalling ad hoc in base
              all&#39;alert.</p>
            </li>
          </ul>

          <p>Il suo funzionamento &egrave; alquanto semplice, basta editare
          il file squidefender.conf, inserendo correttamente alcune
          variabili importanti, tra le quali citiamo:</p>

          <table border="0" bgcolor="#E0E0E0" width="100%">
            <tr>
              <td>
                <pre class="PROGRAMLISTING">
squidlog=/squid/var/logs/access.log.0 
mailhost=IP.DEL.SMTP 
logfile=squidresults.log 
htmlout=/path/www/index.html 
   
</pre>
              </td>
            </tr>
          </table>

          <p>Una volta preparato il file di configurazione baster&agrave;
          lanciare l&#39;eseguibile e puntare il nostro browser verso il
          report, ulteriori informazioni possono essere reperite sulla
          URL&#39;s <a href="http://www.jeroen.se/squidefender.php" target=
          "_top">http://www.jeroen.se/squidefender.php</a>.</p>
        </div>
      </div>
    </div>

    <div class="CHAPTER">
      <hr />

      <h1><a name="CHA-UNA-CONFIGURAZIONE-OPERATIVA" id=
      "CHA-UNA-CONFIGURAZIONE-OPERATIVA"></a>Capitolo 23. Una
      configurazione operativa</h1>

      <p>Con la versione 2.0 dello Squid-Book si apre anche una sezione
      aperta ai contributi degli utenti che intendono partecipare alla
      diffusione delle informazioni pubblicando le loro configurazioni. Le
      configurazioni possono essere inoltrare nella mail-box
      dell&#39;autore del Book <a href="mailto:squid@merlinobbs.net"
      target="_top">Stefano Tagliaferri</a>.</p>

      <ul>
        <li>
          <p>La configurazione inviata da <a href=
          "mailto:postaveloce@virgilio.it" target="_top">Giovanni</a> -
          <a href="contrib/squid.giovanni.conf" target="_top">file di
          testo</a> 3,25 Kb</p>
        </li>
      </ul>

      <p>Di seguito si riporta una configurazione funzionante che consente
      di effettuare sia blocchi di rete che autorizzazione, autenticazione
      ed accounting, i commenti alla configurazione sono a cura di Federico
      Lombardo.</p>

      <table border="0" bgcolor="#E0E0E0" width="100%">
        <tr>
          <td>
            <pre class="PROGRAMLISTING">
http_port 3128 # <em>porta di utilizzo della cache</em>
icp_port 3130 # <em>porta di utilizzo per le connessioni ICP</em> 
#
acl QUERY urlpath_regex cgi-bin \?
no_cache deny QUERY # <em>Questa ACL fa in modo che gli oggetti</em>
                    # <em>in questione non vengano registrati nella cache</em>
cache_mem  96 MB                   
# <em>memoria max utilizzata dal processo che amministra la cache</em>
maximum_object_size 8192 KB        
# <em>Grandezza massima di un oggetto registrato nella cache</em> 
cache_dir ufs /squidcache0 7500 16 256 
# <em>storage e filesystem system dedicato alla cache </em>
cache_dir ufs /squidcache1 7500 16 256     
# <em>storage e filesystem dedicato alla cache</em> 
cache_access_log /var/log/squid/access.log 
cache_log /var/log/squid/cache.log 
cache_store_log /var/log/squid/store.log  
# <em>file di log e percorsi</em> 
emulate_httpd_log on               
# <em>formato dei log compatibile con la struttura &quot;httpd&quot; </em>
mime_table /etc/squid/mime.conf    
# <em>ubicazione del file di configurazione che specifica i mimetypes</em> 
pid_filename /var/run/squid.pid    
# <em>ubicazione del file pid</em> 
ftp_user netmaster@nomeazienda.com 
# <em>nome utente utilizzato per le connessioni ftp anonime</em> 
dns_nameservers 192.168.1.8 192.168.1.7      
# <em>DNS da utilizzare per la risoluzione dei nomi </em>
authenticate_program /usr/lib/squid/msntauth 
# <em>programma utilizzato per autenticare gli utenti</em> 
authenticate_children 15                      
# <em>numero massimo di autenticatori lanciati alla partenza di squid</em> 
refresh_pattern  ^ftp:  1440 20% 10080 
refresh_pattern  ^gopher: 1440 0% 1440 
refresh_pattern  .  0 20% 4320               
# <em>direttive che specificano ogni quando un pattern va riverificato</em> 
reference_age 6 months 
acl password proxy_auth REQUIRED  
# <em>acl per la richiesta</em> <em>un&#39;autenticazione valida</em> 
acl all src 0.0.0.0/0.0.0.0 
acl manager proto cache_object 
acl localhost src 127.0.0.1/255.255.255.255 
acl locallan src 192.168.1.0/255.255.255.0 
acl localla1 src 192.168.2.1 
acl localla2 src 192.168.4.0/255.255.255.0 
acl porn url_regex &quot;/etc/squid/block/porn.block.txt&quot; 
acl notporn url_regex &quot;/etc/squid/block/porn.unblock.txt&quot; 
acl SSL_ports port 443 563 
acl Safe_ports port 80 21 443 563 70 210 1025-65535 
acl Safe_ports port 280  # http-mgmt 
acl Safe_ports port 488  # gss-http 
acl Safe_ports port 591  # filemaker 
acl Safe_ports port 777  # multiling http 
acl CONNECT method CONNECT        
# <em>discrimina il metodo CONNECT secondo le specifiche HTTP/1.1</em> 
acl snmpManager src 192.168.1.14/255.255.255.255 
acl snmppublic snmp_community public 
acl ftpblock url_regex -i \.mp3$ \.asx$ \.avi$ \.mpeg$ \.mpg$ \.qt$ \
\.ram$ \.rm$ \.iso$ \.wav$ 
# <em>fa in modo che non vengano fatti scaricare i file di quelle desinenze</em> 
http_access allow password 
http_access allow manager localhost 
http_access deny manager 
http_access deny !Safe_ports 
http_access deny CONNECT !SSL_ports 
http_access allow localhost 
http_access allow notporn 
http_access deny porn 
http_access deny ftpblock 
http_access allow password
http_access deny all 
icp_access allow all 
miss_access allow all 
proxy_auth_realm Enterprise Nome_Azienda web Gateway 
cache_mgr netmaster@nome_azienda.com 
visible_hostname proxy.nome_azienda.com 
unique_hostname proxy.nome_azienda.com 
forwarded_for off 
snmp_port 3401 
snmp_access allow snmpManager 
snmp_access allow snmppublic localhost 
snmp_access allow snmppublic locallan 
snmp_access deny all
 
</pre>
          </td>
        </tr>
      </table>
    </div>

    <div class="CHAPTER">
      <hr />

      <h1><a name="CHA-COLOPHON" id="CHA-COLOPHON"></a>Capitolo 24.
      Colophon e revisioni</h1>

      <div class="SECT1">
        <h2 class="SECT1"><a name="SEC-APPLICAZIONI-REALIZZAZIONE-LIBRO"
        id="SEC-APPLICAZIONI-REALIZZAZIONE-LIBRO"></a>24.1. Applicazioni
        utilizzate</h2>

        <p>Questo libro &egrave; stato scritto utilizzando il WYSIWYM
        Document Processor Lyx (<a href="http://www.lyx.org/" target=
        "_top">http://www.lyx.org/</a>). LyX &egrave; Copyright (C) 1995 di
        Matthias Ettrich. Lyx &egrave; una applicazione che funziona su
        diverse piattaforme Unix, OS/2 e Windows/Cygwin ed &egrave; inoltre
        disponibile una versione nativa per Mac OS X.</p>

        <p>LyX consente di produrre un output di altissima qualit&agrave;
        grazie allo standard LaTeX, LaTex &egrave; un motore di typesetting
        di livello industriale, in questo caso, LyX &egrave; molto di
        pi&ugrave; di un frontend per LaTeX, Lyx riconosce anche i DocBook
        files. DocBook &egrave; uno dei pi&ugrave; popolari DTD
        (<em>Document Type Definition</em>), il supporto allo standard
        DocBook viene incluso in molte distribuzioni Linux, DocBook dispone
        di un set di tags (pi&ugrave; di 300) che vengono utilizzati per
        descrivere il contenuto di un documento. DocBook include i formati
        XML e SGML, grazie a questo tipo di supporto &egrave; possibile
        utilizzare le regole grammaticali dei formati XML ed SGML.</p>

        <p>Questo documento viene formattato con Lyx e successivamente
        viene esportato nel formato LinuxDoc, i formati utilizzabili sono
        DocBook XML v. 4.2, DocBook SGML v. 4.2 e LinuxDoc SGML.</p>

        <p>Per realizzare una corretta formattazione del documento vengono
        utilizzati i fogli di stile, in particolare viene utilzzato il il
        foglio di stile DSL fornito da LPD (<a href=
        "http://www.merlinobbs.net/LDP/LDP/LDP-Author-Guide/html/templates.html"
           target=
           "_top">http://www.merlinobbs.net/LDP/LDP/LDP-Author-Guide/html/templates.html</a>).
           Questo foglio di stile viene fornito da <a href=
           "http://tille.soti.org/" target="_top">Tille</a> e viene
           utilizzato per utilizzare la trasformazione DSSSL.</p>

        <p>Per l&#39;eliminazione degli errori dalle pagine HTML &egrave;
        stata utilizzata l&#39;utility tidy (<a href=
        "http://tidy.sourceforge.net/" target=
        "_top">http://tidy.sourceforge.net/</a>). Gli script che consentono
        la generazione automatica dei vari formati sono stati realizzati da
        Antonio Fragola aka Mr. Shark (<a href="mailto:mrshark@libero.it"
        target="_top">mrshark@libero.it</a>).</p>
      </div>

      <div class="SECT1">
        <hr />

        <h2 class="SECT1"><a name="SEC-REVISIONI-DEL-LIBRO" id=
        "SEC-REVISIONI-DEL-LIBRO"></a>24.2. Revisioni del libro</h2>

        <ul>
          <li>
            <p>4.10</p>

            <p>23 Maggio 2004</p>

            <p>Correzioni ed integrazioni varie relativamente agli schemi
            di autenticazione <em>Basic</em> ed <em>NTLM</em>, note
            sull&#39;inserimento delle macchine UNIX&reg; nei domini
            Windows, proxy trasparente con <em>ipfw</em> ed <em>ipf</em>,
            WCCP</p>
          </li>

          <li>
            <p>4.00</p>

            <p>24 Aprile 2004</p>

            <p>Nuova riorganizzazione documento, il capitolo
            &quot;Controllare Squid&quot; &egrave; stato integrato con il
            paragrafo dedicato al cache manager, rivisitato il capitolo
            dedicato alle ACL al quale sono state aggiunte le
            funzionalit&agrave; dei nuovi helper external ACL
            <em>squid_unix_group</em>, <em>ip_user_check</em> e
            <em>win32_check_group</em>, altre informazioni sulla
            compilazione, avviare una versione compilata con Red Hat Linux,
            IRCACHE e GARR, i modelli di cache store, il tuning del file
            system, acceleratore SSL, alcune aggiunte relative al capitolo
            dedicato ai delay pools, troubleshooting con il file
            <em>access.log</em>, codici di stato, metodi di richiesta e
            codici gerarchici.</p>
          </li>

          <li>
            <p>3.60</p>

            <p>27 Marzo 2004</p>

            <p>Nuova riorganizzazione documento, il capitolo &quot;Hardware
            consigliato per Squid&quot; &egrave; stato integrato nel
            capitolo <a href="#SEC-SISTEMA-OTTIMALE">Configurare Squid</a>,
            lavorare con il codice sorgente di Squid, istruzioni per
            scegliere l&#39;ambiente di lavoro ottimale, compilare ed
            installare Squid, disponibilit&agrave; dei pacchetti
            precompilati, il Cache Manager, Ad Zapping con Squid</p>
          </li>

          <li>
            <p>3.50</p>

            <p>6 Marzo 2004</p>

            <p>Introduzione a Squid: il concetto di webcache, i vantaggi di
            un sistema webcache tra performance, policy e sicurezza,
            elementi che compongono le ACL, ACL basate sul MAC address.
            Configurare WPAD con ISC DHCP, WPAD round robin, ulteriori
            riferimenti, revisioni ed aggiornamenti alla versione
            2.5.STABLE5 (supporto NTLMv2)</p>
          </li>

          <li>
            <p>3.40</p>

            <p>23 Gennaio 2004</p>

            <p>Problemi comuni riscontrati con il sistema di autenticazione
            NTLM, descrizione delle funzionalit&agrave; del nuovo helper
            external acl &quot;<em>squid_ldap_group</em>&quot;,
            integrazione delle istruzioni per l&#39;avvio multipiattaforma,
            integrazione delle istruzioni per l&#39;avvio con GNU Debian
            Linux e i sistemi Windows, nuova riorganizzazione ed
            adeguamento</p>
          </li>

          <li>
            <p>3.30</p>

            <p>3 Gennaio 2004</p>

            <p>Riorganizzazione ed adeguamento del capitolo relativo ai
            <a href="#CHA-AUTENTICAZIONE-UTENTI">sistemi di
            autenticazione</a>, riorganizzazione ed adeguamento del
            capitolo relativo ai <a href=
            "#CHA-CONTROLLI-DI-ACCESSO">controlli di accesso</a> a cura di
            <a href="mailto:guido.serassio@acmeconsulting.it" target=
            "_top">Guido Serassio</a>, aggiornamento della storia dello
            <a href="#SEC-LE-ORIGINI-SQUID-BOOK">Squid-Book</a> con
            relativo riepilogo degli autori, addendum al capitolo <a href=
            "#SEC-CONTROLLO-ACCESSO-SUI-SITI-WEB">relativo al controllo di
            accesso</a>, aggiornamento del capitolo relativo
            all&#39;avviamento di <a href=
            "#CHA-AVVIARE-SQUID">Squid</a></p>
          </li>

          <li>
            <p>3.22</p>

            <p>9 Novembre 2003</p>

            <p>HTCP e Cache Digest, privacy ed anonimato, TrendMicro
            InterScan Web Security Suite e Squid di <a href=
            "mailto:squid@merlinobbs.net" target="_top">Stefano
            Tagliaferri</a>, annotazioni sull&#39;utilizzo di <a href=
            "#SUBSEC-WB-GROUP">wb-group 1.20</a>, alcuni cenni
            sull&#39;<a href=
            "#SEC-AUTENTICAZIONE-CON-SAMBA-3.X">Autenticazione con Samba
            3.x</a>, ampliamento della sezione sulle <a href=
            "#SEC-COSA-SONO-LE-CACHE-GERARCHICHE">Cache gerarchiche</a> di
            <a href="mailto:guido.serassio@acmeconsulting.it" target=
            "_top">Guido Serassio</a></p>
          </li>

          <li>
            <p>3.21</p>

            <p>14 Settembre 2003</p>

            <p>Alcune annotazioni sull&#39;utilizzo delle <a href=
            "#SEC-LISTE-DI-CONTROLLO-ACL">acl</a> e dei <a href=
            "#CHA-CONTROLLI-DI-ACCESSO">controlli di accesso</a></p>
          </li>

          <li>
            <p>3.20</p>

            <p>19 Agosto 2003</p>

            <p>Correzioni al paragrafo relativo alle <a href=
            "#SEC-PUBBLICAZIONI-SU-CARTA">pubblicazioni su carta</a> e al
            paragrafo dei <a href="#SEC-RIFERIMENTI">riferimenti</a>,
            ulteriore integrazione al capitolo relativo a <a href=
            "#SUBSEC-ISTRUZIONE-RISORSE-MRTG">MRTG e Squid</a>,
            rielaborazione dello schema e dei riferimenti sulla questione
            dell&#39;<a href="#SEC-AUTENTICAZIONE">autenticazione</a>,
            integrazione del paragrafo relativo ai <a href=
            "#SUBSEC-CONTROLLI-DI-ACCESSO-SITI-WEB">controlli di accesso
            sui siti web</a> ed altro</p>
          </li>

          <li>
            <p>3.10</p>

            <p>26 Giugno 2003</p>

            <p>Grazie al grande contributo di <a href=
            "mailto:mrshark@libero.it" target="_top">Antonio Fragola</a>
            a.k.a. <a href="http://www.mrshark.it" target=
            "_top">MrShark</a> &egrave; stato possibile rilasciare la
            versione &quot;portabile&quot; dello Squid-Book, apportate
            piccole modifiche alla <a href="#SEC-LICENZA-UTILIZZO">Licenza
            utilizzo</a>, revisione globale di tutti i capitoli</p>
          </li>

          <li>
            <p>3.00</p>

            <p>8 Giugno 2003</p>

            <p>I log di Squid e la loro analisi, salvaguardare la privacy
            con Junkbuster e Privoxy, aggiornato la <a href=
            "#SEC-LE-ORIGINI-SQUID-BOOK">La storia di questo documento</a>,
            <a href="#SEC-INTRO-SQUID-CONCLUSIONI">Squid Proxy Server</a>,
            <a href="#CHA-CONFIGURARE-SNMP">Configurare SNMP</a> e le
            <a href="#SEC-CONTROLLO-ACCESSO-SUI-SITI-WEB">FAQ per il
            controllo accesso ai siti web</a></p>
          </li>

          <li>
            <p>2.01</p>

            <p>25 Aprile 2003</p>

            <p>GARR Network&#39;s FTP Archive diviene mirror ufficiale
            dello Squid-Book</p>
          </li>

          <li>
            <p>2.00</p>

            <p>7 Aprile 2003</p>

            <p>Autenticazione con NTLM nei domini Windows NT o in Active
            directory (<a href="mailto:ego_pfe@inwind.it" target=
            "_top">Federico Lombardo</a> - note per la compilazione di
            <a href="mailto:guido.serassio@acmeconsulting.it" target=
            "_top">Guido Serassio</a>), commenti alle configurazioni
            operative e inserimento di nuove configurazioni fornite dagli
            utenti di Squid. Il capitolo 19 &egrave; stato totalmente
            trasformato: gli utilizzi estremi ora sono security ed utilizzi
            estremi (determinante il contributo di Federico Lombardo, le
            verifiche sono a cura dell&#39;autore del libro)</p>
          </li>

          <li>
            <p>1.30</p>

            <p>12 Gennaio 2003</p>

            <p>Differenze tra rel. 2.4 e 2.5 (<a href=
            "mailto:ego_pfe@inwind.it" target="_top">Federico
            Lombardo</a>), schemi di autenticazione (<a href=
            "mailto:guido.serassio@acmeconsulting.it" target="_top">Guido
            Serassio</a>)</p>
          </li>

          <li>
            <p>1.29</p>

            <p>16 Novembre 2002</p>

            <p>Modificato il capitolo con il quale si spiega cosa &egrave;
            Squid (aggiornato con il link relativo al porting per la
            piattaforma Win32)</p>
          </li>

          <li>
            <p>1.28</p>

            <p>1 Novembre 2002</p>

            <p>Modificato il capitolo dedicato alle funzionalit&agrave; di
            reverse proxy (aggiunta di esempi reali sul funzionamento dei
            reverse proxy)</p>
          </li>

          <li>
            <p>1.27</p>

            <p>15 Ottobre 2002</p>

            <p>Rilascio della prima versione pubblica in formato HTML</p>
          </li>
        </ul>
      </div>
    </div>

    <div class="CHAPTER">
      <hr />

      <h1><a name="CHA-GNU-FREE-DOCUMENTATION" id=
      "CHA-GNU-FREE-DOCUMENTATION"></a>Capitolo 25. GNU Free Documentation
      License</h1>

      <p>GNU Free Documentation License - Version 1.1, March 2000 -
      Copyright (C) 2000 Free Software Foundation, Inc. 59 Temple Place,
      Suite 330, Boston, MA 02111-1307 USA Everyone is permitted to copy
      and distribute verbatim copies of this license document, but changing
      it is not allowed.</p>

      <p>PREAMBLE</p>

      <p>The purpose of this License is to make a manual, textbook, or
      other written document &quot;free&quot; in the sense of freedom: to
      assure everyone the effective freedom to copy and redistribute it,
      with or without modifying it, either commercially or noncommercially.
      Secondarily, this License preserves for the author and publisher a
      way to get credit for their work, while not being considered
      responsible for modifications made by others.</p>

      <p>This License is a kind of &quot;copyleft&quot;, which means that
      derivative works of the document must themselves be free in the same
      sense. It complements the GNU General Public License, which is a
      copyleft license designed for free software. We have designed this
      License in order to use it for manuals for free software, because
      free software needs free documentation: a free program should come
      with manuals providing the same freedoms that the software does. But
      this License is not limited to software manuals; it can be used for
      any textual work, regardless of subject matter or whether it is
      published as a printed book. We recommend this License principally
      for works whose purpose is instruction or reference.</p>

      <p>APPLICABILITY AND DEFINITIONS</p>

      <p>This License applies to any manual or other work that contains a
      notice placed by the copyright holder saying it can be distributed
      under the terms of this License. The &quot;Document&quot;, below,
      refers to any such manual or work. Any member of the public is a
      licensee, and is addressed as &quot;you&quot;. A &quot;Modified
      Version&quot; of the Document means any work containing the Document
      or a portion of it, either copied verbatim, or with modifications
      and/or translated into another language.</p>

      <p>A &quot;Secondary Section&quot; is a named appendix or a
      front-matter section of the Document that deals exclusively with the
      relationship of the publishers or authors of the Document to the
      Document&#39;s overall subject (or to related matters) and contains
      nothing that could fall directly within that overall subject. (For
      example, if the Document is in part a textbook of mathematics, a
      Secondary Section may not explain any mathematics.) The relationship
      could be a matter of historical connection with the subject or with
      related matters, or of legal, commercial, philosophical, ethical or
      political position regarding them. The &quot;Invariant Sections&quot;
      are certain Secondary Sections whose titles are designated, as being
      those of Invariant Sections, in the notice that says that the
      Document is released under this License.</p>

      <p>The &quot;Cover Texts&quot; are certain short passages of text
      that are listed, as Front-Cover Texts or Back-Cover Texts, in the
      notice that says that the Document is released under this
      License.</p>

      <p>A &quot;Transparent&quot; copy of the Document means a
      machine-readable copy, represented in a format whose specification is
      available to the general public, whose contents can be viewed and
      edited directly and straightforwardly with generic text editors or
      (for images composed of pixels) generic paint programs or (for
      drawings) some widely available drawing editor, and that is suitable
      for input to text formatters or for automatic translation to a
      variety of formats suitable for input to text formatters. A copy made
      in an otherwise Transparent file format whose markup has been
      designed to thwart or discourage subsequent modification by readers
      is not Transparent. A copy that is not &quot;Transparent&quot; is
      called &quot;Opaque&quot;.</p>

      <p>Examples of suitable formats for Transparent copies include plain
      ASCII without markup, Texinfo input format, LaTeX input format, SGML
      or XML using a publicly available DTD, and standard-conforming simple
      HTML designed for human modification. Opaque formats include
      PostScript, PDF, proprietary formats that can be read and edited only
      by proprietary word processors, SGML or XML for which the DTD and/or
      processing tools are not generally available, and the
      machine-generated HTML produced by some word processors for output
      purposes only.</p>

      <p>The &quot;Title Page&quot; means, for a printed book, the title
      page itself, plus such following pages as are needed to hold,
      legibly, the material this License requires to appear in the title
      page. For works in formats which do not have any title page as such,
      &quot;Title Page&quot; means the text near the most prominent
      appearance of the work&#39;s title, preceding the beginning of the
      body of the text.</p>

      <p>VERBATIM COPYING</p>

      <p>You may copy and distribute the Document in any medium, either
      commercially or noncommercially, provided that this License, the
      copyright notices, and the license notice saying this License applies
      to the Document are reproduced in all copies, and that you add no
      other conditions whatsoever to those of this License. You may not use
      technical measures to obstruct or control the reading or further
      copying of the copies you make or distribute. However, you may accept
      compensation in exchange for copies. If you distribute a large enough
      number of copies you must also follow the conditions in section 3.
      You may also lend copies, under the same conditions stated above, and
      you may publicly display copies.</p>

      <p>COPYING IN QUANTITY</p>

      <p>If you publish printed copies of the Document numbering more than
      100, and the Document&#39;s license notice requires Cover Texts, you
      must enclose the copies in covers that carry, clearly and legibly,
      all these Cover Texts: Front-Cover Texts on the front cover, and
      Back-Cover Texts on the back cover. Both covers must also clearly and
      legibly identify you as the publisher of these copies. The front
      cover must present the full title with all words of the title equally
      prominent and visible. You may add other material on the covers in
      addition. Copying with changes limited to the covers, as long as they
      preserve the title of the Document and satisfy these conditions, can
      be treated as verbatim copying in other respects. If the required
      texts for either cover are too voluminous to fit legibly, you should
      put the first ones listed (as many as fit reasonably) on the actual
      cover, and continue the rest onto adjacent pages.</p>

      <p>If you publish or distribute Opaque copies of the Document
      numbering more than 100, you must either include a machine-readable
      Transparent copy along with each Opaque copy, or state in or with
      each Opaque copy a publicly-accessible computer-network location
      containing a complete Transparent copy of the Document, free of added
      material, which the general network-using public has access to
      download anonymously at no charge using public-standard network
      protocols. If you use the latter option, you must take reasonably
      prudent steps, when you begin distribution of Opaque copies in
      quantity, to ensure that this Transparent copy will remain thus
      accessible at the stated location until at least one year after the
      last time you distribute an Opaque copy (directly or through your
      agents or retailers) of that edition to the public. It is requested,
      but not required, that you contact the authors of the Document well
      before redistributing any large number of copies, to give them a
      chance to provide you with an updated version of the Document.</p>

      <p>MODIFICATIONS</p>

      <p>You may copy and distribute a Modified Version of the Document
      under the conditions of sections 2 and 3 above, provided that you
      release the Modified Version under precisely this License, with the
      Modified Version filling the role of the Document, thus licensing
      distribution and modification of the Modified Version to whoever
      possesses a copy of it. In addition, you must do these things in the
      Modified Version:</p>

      <p>A. Use in the Title Page (and on the covers, if any) a title
      distinct from that of the Document, and from those of previous
      versions (which should, if there were any, be listed in the History
      section of the Document). You may use the same title as a previous
      version if the original publisher of that version gives
      permission.</p>

      <p>B. List on the Title Page, as authors, one or more persons or
      entities responsible for authorship of the modifications in the
      Modified Version, together with at least five of the principal
      authors of the Document (all of its principal authors, if it has less
      than five).</p>

      <p>C. State on the Title page the name of the publisher of the
      Modified Version, as the publisher.</p>

      <p>D. Preserve all the copyright notices of the Document.</p>

      <p>E. Add an appropriate copyright notice for your modifications
      adjacent to the other copyright notices.</p>

      <p>F. Include, immediately after the copyright notices, a license
      notice giving the public permission to use the Modified Version under
      the terms of this License, in the form shown in the Addendum
      below.</p>

      <p>G. Preserve in that license notice the full lists of Invariant
      Sections and required Cover Texts given in the Document&#39;s license
      notice.</p>

      <p>H. Include an unaltered copy of this License.</p>

      <p>I. Preserve the section entitled &quot;History&quot;, and its
      title, and add to it an item stating at least the title, year, new
      authors, and publisher of the Modified Version as given on the Title
      Page. If there is no section entitled &quot;History&quot; in the
      Document, create one stating the title, year, authors, and publisher
      of the Document as given on its Title Page, then add an item
      describing the Modified. Version as stated in the previous
      sentence.</p>

      <p>J. Preserve the network location, if any, given in the Document
      for public access to a Transparent copy of the Document, and likewise
      the network locations given in the Document for previous versions it
      was based on. These may be placed in the &quot;History&quot; section.
      You may omit a network location for a work that was published at
      least four years before the Document itself, or if the original
      publisher of the version it refers to gives permission.</p>

      <p>K. In any section entitled &quot;Acknowledgements&quot; or
      &quot;Dedications&quot;, preserve the section&#39;s title, and
      preserve in the section all the substance and tone of each of the
      contributor acknowledgements and/or dedications given therein.</p>

      <p>L. Preserve all the Invariant Sections of the Document, unaltered
      in their text and in their titles. Section numbers or the equivalent
      are not considered part of the section titles.</p>

      <p>M. Delete any section entitled &quot;Endorsements&quot;. Such a
      section may not be included in the Modified Version.</p>

      <p>N. Do not retitle any existing section as &quot;Endorsements&quot;
      or to conflict in title with any Invariant Section. If the Modified
      Version includes new front-matter sections or appendices that qualify
      as Secondary Sections and contain no material copied from the
      Document, you may at your option designate some or all of these
      sections as invariant. To do this, add their titles to the list of
      Invariant Sections in the Modified Version&#39;s license notice.
      These titles must be distinct from any other section titles. You may
      add a section entitled &quot;Endorsements&quot;, provided it contains
      nothing but endorsements of your Modified Version by various
      parties--for example, statements of peer review or that the text has
      been approved by an organization as the authoritative definition of a
      standard. You may add a passage of up to five words as a Front-Cover
      Text, and a passage of up to 25 words as a Back-Cover Text, to the
      end of the list of Cover Texts in the Modified Version. Only one
      passage of Front-Cover Text and one of Back-Cover Text may be added
      by (or through arrangements made by) any one entity. If the Document
      already includes a cover text for the same cover, previously added by
      you or by arrangement made by the same entity you are acting on
      behalf of, you may not add another; but you may replace the old one,
      on explicit permission from the previous publisher that added the old
      one. The author(s) and publisher(s) of the Document do not by this
      License give permission to use their names for publicity for or to
      assert or imply endorsement of any Modified Version.</p>

      <p>COMBINING DOCUMENTS</p>

      <p>You may combine the Document with other documents released under
      this License, under the terms defined in section 4 above for modified
      versions, provided that you include in the combination all of the
      Invariant Sections of all of the original documents, unmodified, and
      list them all as Invariant Sections of your combined work in its
      license notice. The combined work need only contain one copy of this
      License, and multiple identical Invariant Sections may be replaced
      with a single copy. If there are multiple Invariant Sections with the
      same name but different contents, make the title of each such section
      unique by adding at the end of it, in parentheses, the name of the
      original author or publisher of that section if known, or else a
      unique number. Make the same adjustment to the section titles in the
      list of Invariant Sections in the license notice of the combined
      work. In the combination, you must combine any sections entitled
      &quot;History&quot; in the various original documents, forming one
      section entitled &quot;History&quot;; likewise combine any sections
      entitled &quot;Acknowledgements&quot;, and any sections entitled
      &quot;Dedications&quot;. You must delete all sections entitled
      &quot;Endorsements.&quot;</p>

      <p>COLLECTIONS OF DOCUMENTS</p>

      <p>You may make a collection consisting of the Document and other
      documents released under this License, and replace the individual
      copies of this License in the various documents with a single copy
      that is included in the collection, provided that you follow the
      rules of this License for verbatim copying of each of the documents
      in all other respects. You may extract a single document from such a
      collection, and distribute it individually under this License,
      provided you insert a copy of this License into the extracted
      document, and follow this License in all other respects regarding
      verbatim copying of that document.</p>

      <p>AGGREGATION WITH INDEPENDENT WORKS</p>

      <p>A compilation of the Document or its derivatives with other
      separate and independent documents or works, in or on a volume of a
      storage or distribution medium, does not as a whole count as a
      Modified Version of the Document, provided no compilation copyright
      is claimed for the compilation. Such a compilation is called an
      &quot;aggregate&quot;, and this License does not apply to the other
      self-contained works thus compiled with the Document, on account of
      their being thus compiled, if they are not themselves derivative
      works of the Document. If the Cover Text requirement of section 3 is
      applicable to these copies of the Document, then if the Document is
      less than one quarter of the entire aggregate, the Document&#39;s
      Cover Texts may be placed on covers that surround only the Document
      within the aggregate. Otherwise they must appear on covers around the
      whole aggregate.</p>

      <p>TRANSLATION</p>

      <p>Translation is considered a kind of modification, so you may
      distribute translations of the Document under the terms of section 4.
      Replacing Invariant Sections with translations requires special
      permission from their copyright holders, but you may include
      translations of some or all Invariant Sections in addition to the
      original versions of these Invariant Sections. You may include a
      translation of this License provided that you also include the
      original English version of this License. In case of a disagreement
      between the translation and the original English version of this
      License, the original English version will prevail.</p>

      <p>TERMINATION</p>

      <p>You may not copy, modify, sublicense, or distribute the Document
      except as expressly provided for under this License. Any other
      attempt to copy, modify, sublicense or distribute the Document is
      void, and will automatically terminate your rights under this
      License. However, parties who have received copies, or rights, from
      you under this License will not have their licenses terminated so
      long as such parties remain in full compliance.</p>

      <p>FUTURE REVISIONS OF THIS LICENSE</p>

      <p>The Free Software Foundation may publish new, revised versions of
      the GNU Free Documentation License from time to time. Such new
      versions will be similar in spirit to the present version, but may
      differ in detail to address new problems or concerns. See
      http://www.gnu.org/copyleft/. Each version of the License is given a
      distinguishing version number. If the Document specifies that a
      particular numbered version of this License &quot;or any later
      version&quot; applies to it, you have the option of following the
      terms and conditions either of that specified version or of any later
      version that has been published (not as a draft) by the Free Software
      Foundation. If the Document does not specify a version number of this
      License, you may choose any version ever published (not as a draft)
      by the Free Software Foundation.</p>

      <p>ADDENDUM: <em>note dell&#39;autore</em></p>

      <p>Questo libro viene rilasciato sotto la <a href=
      "http://www.gnu.org/licenses/licenses.html" target="_top">GNU Free
      Documentation License</a>, chiunque pu&ograve; modificarlo e
      migliorarlo rispettandone la sola propriet&agrave; intellettuale
      dell&#39;Autore o di chi con l&#39;Autore ha collaborato, citando in
      modo visibile, in tutte le sue pagine: &quot;Versione originale di
      Stefano Tagliaferri (<a href="mailto:squid@merlinobbs.net" target=
      "_top">Squid@merlinobbs.net</a> - <a href="http://www.merlinobbs.net"
      target="_top">http://www.merlinobbs.net</a>), alla stesura di alcune
      parti del documento ha partecipato Leo Pedone (<a href=
      "mailto:lan.to@tiscalinet.it" target=
      "_top">lan.to@tiscalinet.it</a>). Questo libro &egrave; rilasciato
      sotto<a href="http://www.gnu.org/licenses/licenses.html" target=
      "_top">GNU Free Documentation License</a> - &copy; 1999 - 2004
      Stefano Tagliaferri&quot;.</p>

      <p>Per divenire mirror autorizzato della distribuzione in HTML o in
      altri formati &egrave; necessario richiedere espressa autorizzazione
      a Stefano Tagliaferri (<a href="mailto:squid@merlinobbs.net" target=
      "_top">squid@merlinobbs.net</a>),l&#39;elenco dei mirror autorizzati
      dall&#39;autore viene specificato in un capitolo del libro
      stesso.</p>

      <p>Il censimento dei mirror, oltre ad essere una questione di pura
      &quot;statistica&quot; consente anche di mantenere una versione
      sempre aggiornata e centralizzata dell&#39;opera.</p>

      <p>Questo libro, in tutte le sue versioni (anche quelle modificare da
      terzi in Italiano o in qualsiasi altra lingua), per volont&agrave;
      dell&#39;autore, pu&ograve; essere riprodotto anche integralmente
      senza violare nessuna legge in quanto questo libro &egrave;
      rilasciato sotto <a href="http://www.gnu.org/licenses/licenses.html"
      target="_top">GNU Free Documentation License</a>.</p>

      <p>Questa pubblicazione si &egrave; perfezionata senza eventuali
      protezioni di brevetti d&#39;invenzione, inoltre, i nomi coperti da
      eventuale marchio registrato vengono utilizzati senza tenerne
      conto.</p>
    </div>

    <div class="CHAPTER">
      <hr />

      <h1><a name="CHA-ELENCO-DEI-MIRROR-AUTORIZZATI" id=
      "CHA-ELENCO-DEI-MIRROR-AUTORIZZATI"></a>Capitolo 26. Elenco dei
      mirror autorizzati</h1>

      <ul>
        <li>
          <p>MerlinoBBS Internetworking Vortal - <a href=
          "http://www.merlinobbs.net/Squid-Book/" target=
          "_top">http://www.merlinobbs.net/Squid-Book/</a> - Velletri
          (RM)</p>
        </li>

        <li>
          <p>Latina LUG - <a href="http://www.llg.it/Squid-Book/" target=
          "_top">http://www.llg.it/Squid-Book/</a> - Latina (LT)</p>
        </li>

        <li>
          <p>Acme Consulting S.r.l. - <a href=
          "http://www.acmeconsulting.it/Squid-Book/" target=
          "_top">http://www.acmeconsulting.it/Squid-Book/</a> - Torino
          (TO)</p>
        </li>

        <li>
          <p>GARR Network&#39;s ROMA Ftp-Archive - <a href=
          "http://rm.mirror.garr.it/mirrors/Squid-Book/" target=
          "_top">http://rm.mirror.garr.it/mirrors/Squid-Book/</a> - Roma
          (RM)</p>
        </li>

        <li>
          <p>Progetto Italiano Documentazione eCS ed OS/2 (Pido2) -
          <a href="http://www.ecomstation.it/pido2/home/djspider8/squidbook/"
             target=
             "_top">http://www.ecomstation.it/pido2/home/djspider8/squidbook/</a>
             - La Spezia (SP)</p>
        </li>
      </ul>
    </div>
  </div>

  <h3 class="FOOTNOTES">Note</h3>

  <table border="0" class="FOOTNOTES" width="100%">
    <tr>
      <td align="left" valign="top" width="5%"><a name="FTN.AEN748" href=
      "#AEN748" id="FTN.AEN748">[1]</a></td>

      <td align="left" valign="top" width="95%">
        <p>UFS &egrave; l&#39;acronimo di <em>Unix File System</em></p>
      </td>
    </tr>

    <tr>
      <td align="left" valign="top" width="5%"><a name="FTN.AEN751" href=
      "#AEN751" id="FTN.AEN751">[2]</a></td>

      <td align="left" valign="top" width="95%">
        <p>AD &egrave; l&#39;acronimo di Active Directory</p>
      </td>
    </tr>

    <tr>
      <td align="left" valign="top" width="5%"><a name="FTN.AEN755" href=
      "#AEN755" id="FTN.AEN755">[3]</a></td>

      <td align="left" valign="top" width="95%">
        <p>RAID 5 - questa configurazione in realt&agrave; si compone di
        due macchine e si tratta di un Cluster HA (High Availability), una
        configurata come <em>master</em> (il server) e la seconda come
        <em>slave</em> (si tratta da un PC Pentium III 500Mhz, disco IDE
        5000RPM, FreeBSD 4.9-STABLE ed ufs disk store su filesystem UFS con
        alimentatore ridondato). Tale configurazione consente di mantenere
        un&#39;altissimo livello di affidabilit&agrave; ed una rapida e
        veloce manutenzione in caso di fault. Per altre informazioni
        riferirsi al capitolo <a href=
        "#SEC-PREAMBOLO-LOAD-BALANCER">relativo al Proxy Load Balancer</a>
        (WPAD protocol)</p>
      </td>
    </tr>

    <tr>
      <td align="left" valign="top" width="5%"><a name="FTN.AEN802" href=
      "#AEN802" id="FTN.AEN802">[4]</a></td>

      <td align="left" valign="top" width="95%">
        <p>Disk Store aufs: in presenza di carico significativo e di una
        cache store di dimensioni consistenti (superiore a 2 GB) un
        diskstore <em>multi threaded asincrono</em> come <em>aufs</em>,
        <em>awin32</em> o <em>diskd</em> garantisce prestazioni decisamente
        migliori</p>
      </td>
    </tr>

    <tr>
      <td align="left" valign="top" width="5%"><a name="FTN.AEN865" href=
      "#AEN865" id="FTN.AEN865">[5]</a></td>

      <td align="left" valign="top" width="95%">
        <p>con il temine <em>oggetto</em> si definisce un valore generico
        con il quale si identifica qualsiasi documento o altro tipo di dato
        disponibile via web, le URL (Uniform Resource Locator) solitamente
        identificano gli oggetti</p>
      </td>
    </tr>

    <tr>
      <td align="left" valign="top" width="5%"><a name="FTN.AEN919" href=
      "#AEN919" id="FTN.AEN919">[6]</a></td>

      <td align="left" valign="top" width="95%">
        <p>SMP &egrave; acronimo di Simmetric Multi Processor</p>
      </td>
    </tr>

    <tr>
      <td align="left" valign="top" width="5%"><a name="FTN.AEN926" href=
      "#AEN926" id="FTN.AEN926">[7]</a></td>

      <td align="left" valign="top" width="95%">
        <p>EIDE &egrave; acronimo di enhanced IDE</p>
      </td>
    </tr>

    <tr>
      <td align="left" valign="top" width="5%"><a name="FTN.AEN928" href=
      "#AEN928" id="FTN.AEN928">[8]</a></td>

      <td align="left" valign="top" width="95%">
        <p>l&#39;interfaccia ATA viene utilizzata per connettere device di
        storage come hard disks, DVDs e CD-R/W</p>
      </td>
    </tr>

    <tr>
      <td align="left" valign="top" width="5%"><a name="FTN.AEN930" href=
      "#AEN930" id="FTN.AEN930">[9]</a></td>

      <td align="left" valign="top" width="95%">
        <p>DMA &egrave; acronimo di Direct Memory Access</p>
      </td>
    </tr>

    <tr>
      <td align="left" valign="top" width="5%"><a name="FTN.AEN944" href=
      "#AEN944" id="FTN.AEN944">[10]</a></td>

      <td align="left" valign="top" width="95%">
        <p>RAID &egrave; l&#39;acronimo di Redundant Array of Inexpensive
        Disks, si tratta di un metodo che permette l&#39;immagazzinamento
        delle informazioni su pi&ugrave; dischi, usando tecniche come lo
        striping dei dischi (RAID Livello 0) e il mirroring di dischi (RAID
        Livello 1) per ottenere ridondanza, bassa latenza e/o banda
        pi&ugrave; elevata in lettura e/o scrittura, e la
        possibilit&agrave; di recupero delle informazioni dopo la rottura
        di un disco, sono stati definiti 6 diversi tipi di configurazioni
        RAID.</p>
      </td>
    </tr>

    <tr>
      <td align="left" valign="top" width="5%"><a name="FTN.AEN962" href=
      "#AEN962" id="FTN.AEN962">[11]</a></td>

      <td align="left" valign="top" width="95%">
        <p>il sistema di diskstorage <em>aufs</em> attiva le
        funzionalit&agrave; di async-io, il disk I/O viene eseguito in
        modalit&agrave; threaded per evitare attese e blocchi durante i
        tentativi di accesso al disco</p>
      </td>
    </tr>

    <tr>
      <td align="left" valign="top" width="5%"><a name="FTN.AEN973" href=
      "#AEN973" id="FTN.AEN973">[12]</a></td>

      <td align="left" valign="top" width="95%">
        <p>&egrave; noto che i dischi in tecnologia SCSI utilizzano un
        minor tempo di CPU rispetto al classico disco UDMA su bus
        IDE/EIDE</p>
      </td>
    </tr>

    <tr>
      <td align="left" valign="top" width="5%"><a name="FTN.AEN1015" href=
      "#AEN1015" id="FTN.AEN1015">[13]</a></td>

      <td align="left" valign="top" width="95%">
        <p>ANSI C &egrave; un linguaggio di programmazione</p>
      </td>
    </tr>

    <tr>
      <td align="left" valign="top" width="5%"><a name="FTN.AEN1050" href=
      "#AEN1050" id="FTN.AEN1050">[14]</a></td>

      <td align="left" valign="top" width="95%">
        <p>Bourne Shell (sh) &egrave; la pi&ugrave; vecchia delle shell di
        sistema e prende il nome dal suo creatore, <em>Stephen Bourne</em>.
        Si tratta di una shell molto primitiva se paragonata con quelle
        pi&ugrave; moderne e funzionali</p>
      </td>
    </tr>

    <tr>
      <td align="left" valign="top" width="5%"><a name="FTN.AEN1535" href=
      "#AEN1535" id="FTN.AEN1535">[15]</a></td>

      <td align="left" valign="top" width="95%">
        <p>l&#39;utility <em>crontab</em> &egrave; l&#39;applicazione che
        viene utilizzata per installare o disinstallare una serie di
        procedure automatiche attivabili tramite la tabella di
        <em>cron</em>(8) nel Vixie Cron</p>
      </td>
    </tr>

    <tr>
      <td align="left" valign="top" width="5%"><a name="FTN.AEN1570" href=
      "#AEN1570" id="FTN.AEN1570">[16]</a></td>

      <td align="left" valign="top" width="95%">
        <p>MIME &egrave; l&#39;acronimo di Multimedia Internet Mail
        Extension e consente a Squid di determinare il tipo di file in base
        alla sua estensione, la lista dei <em>mime type</em> viene
        generalmente inclusa in un file dal nome <em>mime.conf</em>, una
        lista aggiornata di <em>mime type</em> pu&ograve; essere prelevata
        alla URLs <a href=
        "http://www.isi.edu/in-notes/iana/assignments/media-types/media-types"
           target=
           "_top">http://www.isi.edu/in-notes/iana/assignments/media-types/media-types</a></p>
      </td>
    </tr>

    <tr>
      <td align="left" valign="top" width="5%"><a name="FTN.AEN1708" href=
      "#AEN1708" id="FTN.AEN1708">[17]</a></td>

      <td align="left" valign="top" width="95%">
        <p>Unix File System, si tratta del file system utilizzato dai
        sistemi *BSD</p>
      </td>
    </tr>

    <tr>
      <td align="left" valign="top" width="5%"><a name="FTN.AEN1710" href=
      "#AEN1710" id="FTN.AEN1710">[18]</a></td>

      <td align="left" valign="top" width="95%">
        <p>ext2 &egrave; il file system originario dei Sistemi Linux</p>
      </td>
    </tr>

    <tr>
      <td align="left" valign="top" width="5%"><a name="FTN.AEN1918" href=
      "#AEN1918" id="FTN.AEN1918">[19]</a></td>

      <td align="left" valign="top" width="95%">
        <p>Interprocess Communication Resources</p>
      </td>
    </tr>

    <tr>
      <td align="left" valign="top" width="5%"><a name="FTN.AEN2723" href=
      "#AEN2723" id="FTN.AEN2723">[20]</a></td>

      <td align="left" valign="top" width="95%">
        <p>regex &egrave; acronimo di regular expression. Le espressioni
        regolari (ER, &laquo;regular expression&raquo;) sono definite dallo
        standard POSIX 1003.2, la loro sintassi pu&ograve; essere
        utilizzata per definire dei modelli che possono essere utilizzati
        per eseguire delle liste di confronto</p>
      </td>
    </tr>

    <tr>
      <td align="left" valign="top" width="5%"><a name="FTN.AEN3482" href=
      "#AEN3482" id="FTN.AEN3482">[21]</a></td>

      <td align="left" valign="top" width="95%">
        <p>DOS &egrave; l&#39;acronimo di Disk Operating System</p>
      </td>
    </tr>

    <tr>
      <td align="left" valign="top" width="5%"><a name="FTN.AEN4099" href=
      "#AEN4099" id="FTN.AEN4099">[22]</a></td>

      <td align="left" valign="top" width="95%">
        <p>SSL &egrave; l&#39;acronimo di Secure Socket Layer</p>
      </td>
    </tr>

    <tr>
      <td align="left" valign="top" width="5%"><a name="FTN.AEN4101" href=
      "#AEN4101" id="FTN.AEN4101">[23]</a></td>

      <td align="left" valign="top" width="95%">
        <p>TSL &egrave; l&#39;acronimo di Transport Layer Security</p>
      </td>
    </tr>

    <tr>
      <td align="left" valign="top" width="5%"><a name="FTN.AEN4546" href=
      "#AEN4546" id="FTN.AEN4546">[24]</a></td>

      <td align="left" valign="top" width="95%">
        <p>fratelli con i quali si condivide un solo genitore</p>
      </td>
    </tr>

    <tr>
      <td align="left" valign="top" width="5%"><a name="FTN.AEN4548" href=
      "#AEN4548" id="FTN.AEN4548">[25]</a></td>

      <td align="left" valign="top" width="95%">
        <p>un messaggio di cache MISS definisce un oggetto che non esiste
        pi&ugrave; nella cache o che ha perso validit&agrave;</p>
      </td>
    </tr>

    <tr>
      <td align="left" valign="top" width="5%"><a name="FTN.AEN4565" href=
      "#AEN4565" id="FTN.AEN4565">[26]</a></td>

      <td align="left" valign="top" width="95%">
        <p>Object: termine generico con il quale viene definito un
        qualsiasi tipo di dato disponibile via web, le URL identificano gli
        oggetti</p>
      </td>
    </tr>

    <tr>
      <td align="left" valign="top" width="5%"><a name="FTN.AEN4567" href=
      "#AEN4567" id="FTN.AEN4567">[27]</a></td>

      <td align="left" valign="top" width="95%">
        <p>una cache HIT definisce una copia valida di un&#39;oggetto</p>
      </td>
    </tr>

    <tr>
      <td align="left" valign="top" width="5%"><a name="FTN.AEN4887" href=
      "#AEN4887" id="FTN.AEN4887">[28]</a></td>

      <td align="left" valign="top" width="95%">
        <p>LVS &egrave; l&#39;acronimo di Linux Virtual Server</p>
      </td>
    </tr>

    <tr>
      <td align="left" valign="top" width="5%"><a name="FTN.AEN5030" href=
      "#AEN5030" id="FTN.AEN5030">[29]</a></td>

      <td align="left" valign="top" width="95%">
        <p>SSL &egrave; l&#39;acronimo di Secure Socket Layer</p>
      </td>
    </tr>

    <tr>
      <td align="left" valign="top" width="5%"><a name="FTN.AEN5036" href=
      "#AEN5036" id="FTN.AEN5036">[30]</a></td>

      <td align="left" valign="top" width="95%">
        <p>PEM e PGP sono dei programmi che grazie alla crittografia
        consentono di comunicare in maniera riservata</p>
      </td>
    </tr>

    <tr>
      <td align="left" valign="top" width="5%"><a name="FTN.AEN5171" href=
      "#AEN5171" id="FTN.AEN5171">[31]</a></td>

      <td align="left" valign="top" width="95%">
        <p>HA &egrave; l&#39;acronimo di <em>High Availability</em> che
        tradotto in lingua italiana significa <em>Alta
        Disponibilit&agrave;</em></p>
      </td>
    </tr>

    <tr>
      <td align="left" valign="top" width="5%"><a name="FTN.AEN5461" href=
      "#AEN5461" id="FTN.AEN5461">[32]</a></td>

      <td align="left" valign="top" width="95%">
        <p>Il termine <em>chrooting</em> definisce un processo con il quale
        viene confinata una applicazione in una parte speciale del
        filesystem che prende il nome di <em>jail</em> (gabbia). Quando
        viene eseguita una chiamata <em>chroot()</em> l&#39;applicazione
        non pu&ograve; pi&ugrave; accedere ai files che si trovano al
        difuori della gabbia. Solo l&#39;utente <em>root</em> pu&ograve;
        scappare dalla gabbia, infatti una parte vitale del processo di
        <em>chroot()</em> &egrave; proprio quella di non concedere i
        permessi dell&#39;utente root</p>
      </td>
    </tr>

    <tr>
      <td align="left" valign="top" width="5%"><a name="FTN.AEN5681" href=
      "#AEN5681" id="FTN.AEN5681">[33]</a></td>

      <td align="left" valign="top" width="95%">
        <p>CA &egrave; l&#39;acronimo di Certification Authority</p>
      </td>
    </tr>

    <tr>
      <td align="left" valign="top" width="5%"><a name="FTN.AEN5683" href=
      "#AEN5683" id="FTN.AEN5683">[34]</a></td>

      <td align="left" valign="top" width="95%">
        <p>HTCP &egrave; l&#39;acronimo di Hyper Text Caching Protocol</p>
      </td>
    </tr>

    <tr>
      <td align="left" valign="top" width="5%"><a name="FTN.AEN5855" href=
      "#AEN5855" id="FTN.AEN5855">[35]</a></td>

      <td align="left" valign="top" width="95%">
        <p>RTT &egrave; l&#39;acronimo di Round Trip Time</p>
      </td>
    </tr>
  </table>
</body>
</html>
